[{"content":" Colora - Chrome 扩展 关灯 - Chrome 扩展 OhMyCookie - Chrome 扩展 OhMyBox - Npm 包 Colora Colora 是⼀款基于 Chrome 的扩展程序，它⾮常的轻量级、纯粹并且免费的截图美化⼯具，不滥⽤权限、使⽤最原始、恰到好处的技术实现，并且没有任何⼴告。核⼼逻辑只有不到 5 KB，Chrome 扩展商店搜索「Colora」\n⽆需繁琐⽆聊的设计技巧。只需⼀次点击，就可以获得精美绝伦、惊⼈震撼的图⽚，让图⽚编辑变得更有趣，那就是 Colora，快来享受它吧！\n在 Chrome 扩展商店查看 「Colora」\n关灯 Chrome 扩展程序，暗黑模式一键切换。\n特性 ❇️ 极致小巧，核心代码实现只有不到 3KB\n❇️ 新拟物化 UI 设计，尽显优雅格调\n❇️ 纯粹至极，仅专注于实现必要功能，依赖精简，技术运用恰到好处\n❇️ 安全并且谨慎，仅获取读取 TAB 页面信息权限，用于注入样式。绝不触及任何其他权限与信息\n❇️ 永久免费，这是一个开源项目，随时可以查看最新的源代码\n关于「关灯」的更多\n开源仓库地址\n在 Chrome 扩展商店查看 「关灯」\nOhMyCookie ⽤来扩展 Chrome 浏览器中 Cookie，Local、SessionStorage 的增删改查、导出操作。Chrome 扩展商店搜 「ohmycookie」\n基于开源脚⼿架⼯具 vtemp-chrome-extension， 来实现使⽤ Vue 开发 可编辑 Cookie 8 种属性，并⽀持以 JSON 导出 本⻚⾯全部 Cookie 开源仓库地址\n在 Chrome 扩展商店查看 「OhMyCookie」\nOhMyBox 基于 vue 的移动端滑动组件，类似抖⾳⾸⻚滑屏效果。npm 商店搜「ohmybox」\n内部单元组件使⽤ Slot 插槽，可⾼度⾃定义内容 ⽀持 六种参数 和 两种事件 设置：翻⻚⾼度，持续滚动时⻓，快速翻⻚⾼度、模拟点击 ⽅法等 开源仓库地址\n在 npm 商店查看 「OhMyBox」\n","permalink":"http://localhost:1313/apps/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#colora\"\u003eColora - Chrome 扩展\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%85%B3%E7%81%AF\"\u003e关灯 - Chrome 扩展\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ohmycookie\"\u003eOhMyCookie - Chrome 扩展\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ohmybox\"\u003eOhMyBox - Npm 包\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"colora\"\u003eColora\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eColora 是⼀款基于 Chrome 的扩展程序，它⾮常的轻量级、纯粹并且免费的截图美化⼯具，不滥⽤权限、使⽤最原始、恰到好处的技术实现，并且没有任何⼴告。核⼼逻辑只有不到 5 KB，Chrome 扩展商店搜索「Colora」\u003c/p\u003e","title":"我的应用"},{"content":"如果有一个布尔变量，来控制某个按钮的显示隐藏，就有两种命名方法：\nshow = 布尔值 hide = 布尔值 当使用 show 变量时，好像，代码的逻辑更像是在问 “是否要显示按钮？” 如果答案是肯定的（true），就显示按钮；如果是否定的（false），就隐藏按钮。这种逻辑符合人们日常对于 “展示” 事物的思考方式。\n而 hide 就正好相反，是反直觉的，也许是更强调隐藏这个角度？也许是一种补充的、不是必须的配置，默认是显示的，你将更改默认配置，hide 突出对特殊状态（隐藏状态）的关注，在一些需要重点强调隐藏条件的业务逻辑中，能够使代码的意图更加明确。\n如果业务逻辑侧重于正常情况下元素的展示，强调正向判断流程，“show” 变量无疑是更优选择；而当特殊的隐藏条件较为突出，需要着重关注隐藏状态的设置时，“hide” 变量或许能更好地体现代码意图。但无论选择哪种方式，保持项目内代码风格的统一和清晰的代码注释，都是确保代码质量和可维护性的关键。\n","permalink":"http://localhost:1313/blogs/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%91%BD%E5%90%8D/","summary":"\u003cp\u003e如果有一个布尔变量，来控制某个按钮的显示隐藏，就有两种命名方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eshow = 布尔值\u003c/li\u003e\n\u003cli\u003ehide = 布尔值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当使用 show 变量时，好像，代码的逻辑更像是在问 “是否要显示按钮？” 如果答案是肯定的（true），就显示按钮；如果是否定的（false），就隐藏按钮。这种逻辑符合人们日常对于 “展示” 事物的思考方式。\u003c/p\u003e","title":"有意思的命名"},{"content":" 离散数学中命题逻辑的真值表如下：\nP Q P ∧ Q P ∨ Q ¬ P P → Q P ↔ Q T T T T F T T T F F T F F F F T F T T T F F F F F T T T 下面对各逻辑运算符进行解释：\nP ∧ Q（合取）：仅当 P 和 Q 同时为真时，其结果才为真，否则为假。 P ∨ Q（析取）：只要 P 或者 Q（或者两者同时）为真，结果即为真，否则为假。 ¬ P（否定）：若 P 为假，结果为真；若 P 为真，结果为假。 P → Q（蕴含）：只有在 P 为真且 Q 也为真的情况下，结果才为真（否则为假），常被读作“若 P，则 Q” 。 P ↔ Q（等价）：当且仅当 P 和 Q 的真值一致时，结果为真，否则为假。 以下通过具体例子来进一步说明 合取 假设有两个命题 P 和 Q：\nP：今天天气晴朗。 Q：学校举行户外运动会。 逻辑与运算“P ∧ Q”代表“今天天气晴朗并且学校举行户外运动会”。只有当 P 和 Q 均为真时，整个表达式才是真的。\n析取 依旧使用上述命题 P 和 Q。 逻辑或运算“P ∨ Q”表示“今天天气晴朗或者学校举行户外运动会”。只要 P 或者 Q（或者二者同时）为真，整个表达式就为真。\n否定 使用命题 P：\nP：今天天气晴朗。 逻辑非运算“¬P”即“今天天气不晴朗”。当 P 为真时，¬P 为假；当 P 为假时，¬P 为真。\n蕴含 例子 1：假设有两个命题 P 和 R：\nP：你完成了作业。 R：你可以出去玩。 逻辑蕴含运算“P → R”表示“如果你完成了作业，那么你可以出去玩”。这里，P 是前提（前件），R 是结论（后件）。当 P 为真而 R 为假时，整个表达式为假；在其他情形下（即 P 为真 R 也为真，或者 P 为假时），整个表达式为真。需要注意的是，逻辑蕴含并不等同于因果关系，它仅仅关注真值之间的关联。在实际生活中，我们会说“如果完成了作业（P），那么就可以出去玩（R）”，但这并不表明完成作业是能够出去玩的唯一原因或者必要条件。\n为了更好理解蕴含，再举一个例子： 例子 2：假设有两个命题 P 和 R：\nP：我当选美国总统。 R：我就给你涨工资。 对于蕴含式 P → R ：\n为真的情况：我当选了美国总统，并且我给你涨了工资，此时蕴含式结果为真 。 为假的情况： 我没有当选美国总统，那么无论我是否给你涨工资，整个蕴含式都为假 。 我当选了美国总统，但我没有给你涨工资，此时蕴含式结果为假。 等价 使用命题 P 和另一个命题 S：\nP：你完成了作业。 S：你的作业已经提交。 逻辑等价运算“P ↔ S”表示“你完成了作业当且仅当你的作业已经提交”。当 P 和 S 的真值相同（即都为真或者都为假）时，整个表达式为真；否则为假。这意味着 P 和 S 在逻辑层面是等价的，它们的真假情况必然一致。\n","permalink":"http://localhost:1313/blogs/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8/","summary":"这篇文章先给出离散数学中命题逻辑真值表，介绍了合取、析取、否定、蕴含、等价运算规则及结果，后分别以具体生活实例对每种运算进行详细说明，并特别指出蕴含运算中逻辑关系与因果关系的区别","title":"命题逻辑真值表"},{"content":" 为什么要写这篇博客 最近在和同事午饭的时候聊到这个问题。想到了刚接触编程时粗略了解过，但是又没办法讲清楚，所以决定利用这篇博客复习一下。也希望给相关的二进制存储的疑问画上一个句号。\n先来了解存储数字的标准 计算机是二进制的。浮点数是没有办法用二进制进行精确表示。我们的 CPU 表示浮点数由两个部分组成：指数 和 尾数，这样的表示方法一般会失去一定的精确度，有些浮点数运算也会产生一定的误差，是实数的无限精度跟计算机的有限内存之间的矛盾，通用语言中的浮点数都是按照 二进位浮点数算术标准 (IEEE 754)标准存储。\n一般语言把数字区分整数型和小数型以不同标准存储，但是 js 比较特殊，在 js 中，不管是整数还是小数都是以 IEEE 754 标准中的 双精度浮点法 (Double 64)存储的。整数 1 被当成 1.0 存储。\n那什么是双精度浮点法 ? 先来介绍一下 双精度浮点法，比起 单精度浮点法，双精度浮点法 使用 64 位二进制来储存一个浮点数。它可以表示二进位制的 53 位有效数字，其可以表示的数字的范围为\n$$ [-(2^{53}), 2^{53} - 1] $$\n结构包含 64 位二进制位，分别是符号位，指数位，尾数位。\nsign bit（符号）：用来表示数值正负，0 代表数值为正，1 代表数值为负。占位 1 比特。 exponent（指数）：用来表示次方数，占位越多，可以表示数字的范围越大。可以理解成它表示 小数点 在数字的什么位置上，这也是小数在计算机中被叫做浮点数的原因。占位 11 比特。 mantissa（尾数）：用来表示精确度，可以理解成占位越多，那么保存小数点后更多的位数。占位 52 比特。 二进制转换 那么把一个数字存入到内存中是如何实现的呢？首先先把数字转换计算机可识别二进制格式再通过 双精度浮点法 存储，这里区分两种情况：整数和小数(整数部分和小数部分)\n整数：整数除以 2，记录结果和余数。然后用上次结果继续除以 2，再次记录商和余数。重复这个步骤，直到商为 0 为止。那么所得余数从后往前排列就是这个整数的二进制。\n小数：小数位乘以 2，记录结果，区分整数位和小数位，然后继续用小数位乘以 2，再次记录结果。重复这个步骤，直到小数位为 0 为止，那么其中得到的整数结果从前往后排列就是小数的二进制。\n整数 8 转换二进制过程 8 / 2 = 4 // 余数 0 4 / 2 = 2 // 余数 0 2 / 2 = 1 // 余数 0 1 / 2 = 0 // 余数 1 然后把倒过来把余数排列，1000 就是 8 的二进制结果。\n小数 0.25 转换二进制过程 0.25 * 2 = 0.5 // 整数位：0 小数位：0.5 0.5 * 2 = 1 // 整数位：1 小数位：0 整数位结果从前往后取出得到 01 就是 0.25 的二进制结果。\n8.25 的二进制过程 实际拆解成整数位 8 和小数 0.25，分别按照对应的方法去转换，8 的二进制就是 1000，0.25 的二进制是 01，加个小数点合并到一起就是 1000.01，所以 8.25 的二进制为 1000.01。\n以双精度浮点法存储到内存 按照上述步骤，8.25 转换二进制得到 1000.01，那么 1000.01 是如何以双精度浮点法存储的呢，第一步先用二进制科学记数法表示，得到 1.00001 * 2^3，然后我们把它拆分下，分别存入符号位，指数位，尾数位。\n符号位存入 0，因为 1000.01 是正数 指数位存入 1026 的二进制 10000000010，指数应该是 3，为什么存入 1026 ? 参考下面标题为 为什么指数位要设置偏移量 ? 尾数位存入 00001，把 1.0001 小数点前的 1 省略，因为转换为二进制位后，只可能是 0 和 1，再进行二进制科学记数法，第一位一定大于 0，所以又排除了 0，所以小数点前的数只能是 1，就可以省略掉 至此使用双精度浮点法 8.25 存储的结果为： 为什么指数位要设置偏移量 ? 这里需要解释下，按照上面的例子，指数应该是 3，为什么存入 1026 ?\n是因为指数位有 11 位，可以表示 0 ~ 2^11，也就是 0 ~ 2048， 因为指数可能 正 或 负 的，这种情况下计算机不仅仅要识别指数有多大，还需要识别是正是否，无疑增加了复杂度。\n为了简化这个问题，指数位只存储无符号整数，所以使用了偏移量的概念，因为指数有正负， 0 ~ 2048 没办法表示负数，就把 0 ~ 2048 从中一刀切开，范围变成 -1024 到 +1024， 对了，其中还包括 0 ，就是 -1024 到 +1023 。存储的时候让原本的指数不管正负都加上1024 的偏移量，可以保证，存储的都是整数，当二进制转回十进制的时候，再减去 1024 就可以了，那 1024 + 3 应该是 1027 啊，为什么实际用了 1026 呢，因为人们为了特殊用处，不允许使用 0 和 1023 这两个数字表示指数，因为这两个极值，来表示一些特别的含义，比如 NaN，Infinity，0 等。这样的话少了 2 个数字，偏移量的设置自然就只好采用最大值 1023 了。因为-1023 + 1023 = 0，最小的指数为0，所以指数位 3 + 1023 为 1026 。这就是移码的概念。IEEE 754 的指数位采用移码来表示，为了实现表示的范围都是正数，而小数部分用原码来表示。\n从内存中如何取出使用呢？ 按照 双精度浮点法 存入内存的数字如何拿出来使用呢？先看转换公式：\n$$ (-1)^{sign} \\times 2^{exponent} \\times (1 + mantissa) $$\n还是用 8.25 举例，符号位为 0，指数位为 1026 - 1023 (偏移量) = 3，尾数为 00001，可得：\n$$ (-1)^{0} \\times 2^{3} \\times (1 + 0.00001) = 1 \\times 1000.01 $$\n把二进制结果 1000.01 转换为十进制，先把小数位按照第 1 位的值*2^(-1)，第 2 位的值*2^(-2)，第 3 位的值*2^(-3) …到最后一项 第 n 位的值*2^(-n)，然后把最后结果相加，因为 1000.01 只有两位小数位 .01，按照下面方法计算可得 0.25：\n$$ 0 \\times 2^{-1} + 1 \\times 2^{-2} = 0.25 $$\n整数位 1000 转十进制，和小数位计算方式一样，只是指数从负数换成整数就好了，最终结果是 8，把 小数位 和 **整数位 **结果加到一起就是最终结果了 8.25 了\n$$ 0 \\times 2^{1} + 0 \\times 2^{2} + 0 \\times 2^{3} + 1 \\times 2^{4} = 8 $$\n总结 js 中数字存入内存的步骤：\n分别把整数位、小数位转二进制 使用二进制科学计数法表示 按照双精度浮点法存入符号位、指数位、尾数位 数字从内存中步骤：\n按照公式，替换符号、指数、尾数 得到的结果转十进制 扩展为什么 0.1 + 0.2 !== 0.3 从上文我们知道了一个数是如何存储的，那我们按照上面的方式模拟一下 0.1 + 0.2 的过程：\n0.1 转换为二进制为 0.0001100110011(0011 循环)，因为尾数只能存储 52 位，没办法，就把 52 位以后截取掉了，实际存入结果为：\n0.2 同理，也是循环二进制，存储结果为：\n按照上面的方法分别转回十进制可得：\n0.1 为 0.100000001490116119384765625\n0.2 为 0.20000000298023223876953125\n相加结果为 0.30000000447034836，原因就是在二进制中都只能精准表示 2 除尽的数字 1/2, 1/4, 1/8，当无法精准表示时，会舍弃存储。就好比，十进制的世界中，1/3，是 0.33333\u0026hellip; 是无限循环的，如果人的理解也像计算机一样，是按照固定长度去表示的话，那是无法精准表示的一样。\n","permalink":"http://localhost:1313/blogs/js%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E5%AD%97%E7%9A%84/","summary":"\u003chr\u003e\n\u003ch2 id=\"为什么要写这篇博客\"\u003e为什么要写这篇博客\u003c/h2\u003e\n\u003cp\u003e最近在和同事午饭的时候聊到这个问题。想到了刚接触编程时粗略了解过，但是又没办法讲清楚，所以决定利用这篇博客复习一下。也希望给相关的二进制存储的疑问画上一个句号。\u003c/p\u003e","title":"js是如何存储数字的"},{"content":"为什么要总结这个问题 这几天和我的同事聊到这个问题，他提出了一些深入的问题，想了想，我也有相同的疑问。真是验证了那句话，了解的越多就发现自己了解的越少！so 被迫研究了下这个问题总结起来。便于以后查看和补充。\n单线程和事件循环 因为多线程会产生共享资源，修改彼此，等复杂问题。并且早期 js 只是来显示简单页面的，但今非昔比，或许 js 作者可能都没想到现在的 js 发展的如此迅猛！所以单线程更适合 js ，一直延续至今。那问题来了，只有单线程是如何处理耗时任务且实现不阻塞的呢，这里就用到了事件循环。事件循环(event loop)是一种计算机系统运行机制。作为单线程的 js 来说，事件循环是来解决当执行耗时任务时不阻塞主线程的调度机制。来自维基百科的解释\n事件循环工作流程 以当前最新版 chrome_v98.0 浏览器为准\njs 中的任务可分为\n同步任务 异步任务 打开一个 tab 页面，浏览器会新开辟一个进程。包含执行栈( js 主执行线程)和一些其他线程(属于浏览器)。当一个包含 css， js 的 html 页面被加载时，会从上往下，从左到右按顺序解析。当遇到同步任务时，它的执行上下文会被放入执行栈，执行完毕后，出栈。下一个放入，依次执行。\n当遇到耗时(异步)任务，会根据不同的任务类型，提供给专门的线程来处理，举出一些例子，不限于这些：\nsetInterval / setTimeout\u0026hellip; ⇒ timer 线程 网络请求 ⇒ 网络请求线程 dom 绘制渲染 ⇒gui 线程 dom 元素的事件监听 ⇒ 事件线程 等到这些异步任务应该被执行时，比如用户点击按钮、网络请求、延时器时间到了等，会把相应的回调函数放入异步队列中，按先后顺序排列起来待命。\n直到执行栈的所有同步任务执行完毕后，同步栈会从异步队列中第一位开始取出入栈，依次执行。如果每个异步队列中的任务被执行的过程中，再次产生异步任务，会被放到任务队列的最后，等待执行。\n有一些问题 这些专门线程处理一些任务时候，拿到结果后，都按照先后顺序放入队列被执行，没有办法控制任务优先级，希望一些任务不在队列最末尾排队，而是直接插队执行。为了解决这个问题，在异步任务队列中再细分成两种类型，微任务和宏任务，微任务可以理解是插队的任务，优先级更高。根据类型的不同会被放入不同的队列：\n微任务队列 : promise、 queueMicroTask、 mutationObserver 宏任务队列 : setTimeout、 setInterval、 requestAnimationFrame等 按照先微再宏的顺序执行：每一个宏任务开始前，都先要把上一个宏任务产生的微任务执行完毕再开始新的宏任务，微任务是宏任务的一部分，换句话来说，就是当执行栈空了之后，先检查微任务队列，再检查宏任务队列。\n总结 更通熟易懂事件循环动画参考 B 站\n存在的疑问 在分配宏/微任务时有总的调度系统分配？还是一句代码执行过程中有一次机会，让每个线程依次检查一下，把自己任务拿走 每个宏任务都有属于自己的微任务队列，还是一共只有一条微任务队列？ 回答：node 端的执行规律是一个宏任务队列搭配一个微任务队列，而浏览器是一个单独的宏任务搭配一个微任务队列。但是在 node11 之后，node 和浏览器的规律趋同。 如何区分微任务和宏任务的呢，具体是通过哪些特征分类的？ 最后整一道经典面试题 基于 chrome_v98.0 浏览器环境\nasync function async1() { console.log(\u0026#34;async1 start\u0026#34;); await async2(); console.log(\u0026#34;async1 end\u0026#34;); } async function async2() { console.log(\u0026#34;async2\u0026#34;); } console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); async1(); new Promise(function (resolve) { console.log(\u0026#34;promise1\u0026#34;); resolve(); }).then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); 解析：按照从上往下顺序先执行同步代码，前两个函数async和async2是函数声明，忽略。然后第 1 个输出的是script start，然后看到setTimeout, 由于它是异步且属于宏任务，放到最后执行。然后看到 async1 函数被执行了，进入async1函数体。\n第 2 个输出的是async1 start, 看到 await 规则是：await 右的语句被同步执行，所以第 3 个输出的是async2，await 下的语句(函数体内)被当作 async 函数返回一个 promsise 的回调函数体的语句去处理，且被放入了异步任务队列中，等待中。\n然后跳出 async1 函数体，继续执行同步代码，遇到 new Promise，第 4 次输出promise，看到 resolve，就把 then 中回调，放入任务队列中，然后继续向下执行同步代码，第 5 次输出的最后的script end。\n至此同步执行栈空了，开始把任务队列中的上下文拿到执行栈执行，由于队列先进先出，所以第一个被入栈的是 async1 的回调，也就是第 6 次输出的是async1 end，然后把第二个队列中的上下文放入执行栈，也就是 promise 的 resolve，所以第 7 次输出promise2，至此微任务执行完成，现在执行宏任务，也就是 timeout，所以第 8 次输出为setTimeout。\n最终结果\nscript start async1 start async2 promise1 script end async1 end promise2 setTimeout ","permalink":"http://localhost:1313/blogs/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","summary":"\u003ch2 id=\"为什么要总结这个问题\"\u003e为什么要总结这个问题\u003c/h2\u003e\n\u003cp\u003e这几天和我的同事聊到这个问题，他提出了一些深入的问题，想了想，我也有相同的疑问。真是验证了那句话，了解的越多就发现自己了解的越少！so 被迫研究了下这个问题总结起来。便于以后查看和补充。\u003c/p\u003e","title":"浏览器事件循环"},{"content":"为什么要写这篇博客 一个是感觉自己的计算机网络基础薄弱，关于七层模型和 tcp、udp 看过几次了，都不够透彻，知其然不知其所以然。再一个，最近和同事有聊到这个事，感觉自己也说不明白，又意识到很重要，所以决定整理一下，自己感觉自己会了和可以给别人讲明白这个事儿，区别还是很大的啊。就参考资料和自己理解记录一下。\n先说什么是网络协议 两台设备进行网络通信时，双方要提前约定一些规则。这样才可以让对方设备理解你要做什么。比如，如何发起通信，如何发出/接收数据，如何关闭链接。\n再说 OSI 7 层模型 和 TCP/IP 4 层模型 OSI(Open System Interconnection) 开放式系统互联参考模型，为了统一处理，模块化，易于维护，OSI 采用分层结构。包含七层，每一层实现各自的功能和协议，通过接口提供给更高一层并完成与相邻层的接口通信。\nIOS 7 层模型是一种网络通信理论模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，设备就能互联了。OSI 参考模型是学术上和法律上的国际标准，是完整的权威的网络参考模型。\n关系如下：\nOSI 7 层模型 功能 传送介质 对应 TCP/IP 4 层模型 对应协议 应用层 Application 为应用进程提供网络服务。 报文 应用层 HTTP、FTP、SMTP 表示层 Presentation 数据格式化，加密和解密。 报文 应用层 Telnet、Rlogin、SNMP、Gopher 会话层 Session 建立应用和应用之间的连接。 报文 应用层 SMTP、DNS 传输层 Transport 建立设备和设备之间的连接。 报文 传输层 TCP、UDP 网络层 Network 为数据包选择路由，寻址。 数据包 网络层 IP、ICMP、ARP、RARP、AKP、UUCP 数据链路层 Data Link 根据以太网协议将一组电信号组成一个数据包，称作”帧”，控制传输。通俗说，就是控制数据在网线、光纤传输。 数据帧 链路层 FDDI、Ethernet、Arpanet、PDN、SLIP、PPP 物理层 Physical 把网线，光纤将设备链接起来组网。物理传输介质。 比特流 链路层 IEEE 802.1A、IEEE 802.2 到 IEEE 802.11 TCP/IP 4 层模型 (协议簇) TCP/IP 协议簇是 internet 的基础，是多个协议的统称，命名为 TCP/IP 是因为TCP和IP是其中很重要的两个协议。\nTCP/IP 分为四层，每一个层都有各自的协议和功能，其中 TCP 和 UDP 协议位于 TCP/IP 协议簇的传输层。\nTCP/IP 借鉴了 OSI 的分层概念建立TCP/IP模型，TCP/IP 已被广泛使用，成为网络互联事实上的标准。\n使用 TCP/IP 协议传递数据图解： TCP TCP(Transmission Control Protocol )全称是传输控制协议，是一种面向连接的、可靠的、全双工、单播传输的、基于字节流的传输层通信协议。属于TCP/IP协议簇的传输层。\n面向连接： 即传递数据前在两端建立连接，使用“三次握手”确保两端的发送和接收能力，提供可靠的连接。 仅支持单播传输：只能进行一对一的数据传输，不支持组播和广播传输方式。 拥堵控制：网络拥堵的时，TCP能够减小向网络注入数据的速率和数量，缓解拥堵，提供对流量控制和服务质量的访问。 全双工： 双端既可以当接收者，也可以当发送者。 基于字节流模式： 比如发送端发送 100 字节到目标端，目标端可以分 10 次，每次 10 字节接受，也就是以少量数据分以任意次接收。 UDP UDP(User Data Protocol)全称用户数据报协议，是一种无连接的、不可靠的、支持组播和广播、基于数据报的传输层通信协议。属于TCP/IP协议簇的传输层。\n无连接不可靠： 不需要繁琐的三次握手，确认、重传、拥塞控制等机制，没有这些安全机制，速度更快的同时，安全性变差，易丢包。UDP 使用尽可能最大努力交付，但不保证可靠交付。 支持组播和广播： 可以一对一，一对多，多对一、多对多数据传输。 基于数据报模式： 一次发送对应一次接收，一次只读取一个报文，多个报文不可以合并。 UDP 和 TCP 区别总结 指标 TCP UDP 连接 面向连接 无连接 报文 面向字节流 面向报文 效率 低 高 是否可靠 可靠 不可靠 拥塞控制 有 无 速度 慢 快 双共性 全双工 一对一、一对多、多对一、多对多 使用 nodejs 实现 TCP 连接 服务端\nconst net = require(\u0026#34;net\u0026#34;); const HOST = \u0026#34;127.0.0.1\u0026#34;; const PORT = 8081; const server = net.createServer(); server.on(\u0026#34;listening\u0026#34;, () =\u0026gt; { console.log(`TCP server at ${HOST}:${PORT}`); }); server.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { socket.on(\u0026#34;data\u0026#34;, (buffer) =\u0026gt; { const msg = buffer.toString(); console.log(msg); socket.write(Buffer.from(`来自服务端 ${msg}`)); }); }); server.on(\u0026#34;close\u0026#34;, () =\u0026gt; { console.log(\u0026#34;TCP server close!\u0026#34;); }); server.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(`TCP server error :${err}`); setTimeout(() =\u0026gt; { server.close(); }, 1000); }); server.listen(PORT, HOST); 客户端\nconst net = require(\u0026#34;net\u0026#34;); const HOST = \u0026#34;127.0.0.1\u0026#34;; const PORT = 8081; const client = net.createConnection({ host: HOST, port: PORT, }); client.on(\u0026#34;connect\u0026#34;, () =\u0026gt; { setTimeout(() =\u0026gt; { client.write(\u0026#34;客户端向服务端发送消息: 1\u0026#34;); }, 1000); setTimeout(() =\u0026gt; { client.write(\u0026#34;客户端向服务端发送消息: 2\u0026#34;); }, 2000); setTimeout(() =\u0026gt; { client.write(\u0026#34;客户端向服务端发送消息: 3\u0026#34;); }, 3000); }); client.on(\u0026#34;data\u0026#34;, (buffer) =\u0026gt; { console.log(buffer.toString()); }); client.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(\u0026#34;TCP server error\u0026#34;, err); }); client.on(\u0026#34;close\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;client disconnects\u0026#34;, err); }); 使用 nodejs 实现 UDP 连接 服务端\nconst dgram = require(\u0026#34;dgram\u0026#34;); const HOST = \u0026#34;127.0.0.1\u0026#34;; const PORT = 8082; const server = dgram.createSocket(\u0026#34;udp4\u0026#34;); server.on(\u0026#34;listening\u0026#34;, function () { const address = server.address(); console.log(`UDP server at ${HOST}:${PORT}`); }); server.on(\u0026#34;message\u0026#34;, function (message, remote) { console.log(`来自服务端 ${message}`); }); server.bind(PORT, HOST); 客户端\nconst dgram = require(`dgram`); const PORT = 8082; const HOST = \u0026#34;127.0.0.1\u0026#34;; const client = dgram.createSocket(\u0026#34;udp4\u0026#34;); setTimeout(() =\u0026gt; { sendMsg(Buffer.from(`客户端向服务端发送消息: 1`)); }, 1000); setTimeout(() =\u0026gt; { sendMsg(Buffer.from(`客户端向服务端发送消息: 2`)); }, 2000); setTimeout(() =\u0026gt; { sendMsg(Buffer.from(`客户端向服务端发送消息: 3`)); }, 3000); setTimeout(() =\u0026gt; { client.close(); console.log(\u0026#34;客户端主动关闭\u0026#34;); }, 4000); function sendMsg(_msg) { client.send(_msg, PORT, HOST, function (err, bytes) { if (err) throw err; console.log(_msg.toString()); }); } ","permalink":"http://localhost:1313/blogs/%E4%BB%8Eosi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%88%B0tcp/","summary":"\u003ch2 id=\"为什么要写这篇博客\"\u003e为什么要写这篇博客\u003c/h2\u003e\n\u003cp\u003e一个是感觉自己的计算机网络基础薄弱，关于七层模型和 tcp、udp 看过几次了，都不够透彻，知其然不知其所以然。再一个，最近和同事有聊到这个事，感觉自己也说不明白，又意识到很重要，所以决定整理一下，自己感觉自己会了和可以给别人讲明白这个事儿，区别还是很大的啊。就参考资料和自己理解记录一下。\u003c/p\u003e","title":"从OSI七层模型到TCP"},{"content":" 发布订阅模式 简单来说，需要三个角色\n发布者 事件队列 订阅者 发布者 -\u0026gt; 事件队列 \u0026lt;=\u0026gt; 订阅者\n一次完整流程\n订阅者向事件队列订阅事件E 发布者向事件队列发布事件E 事件队列通知事件E的所有订阅者，订阅者接收 class Event { constructor() { // 事件队列 this.listeners = {}; } // 订阅方法 on(eventType, listener) { if (!this.listeners[eventType]) { this.listeners[eventType] = []; } this.listeners[eventType].push(listener); } // 发布方法 emit(eventType, data) { const callbacks = this.listeners[eventType]; if (callbacks) { callbacks.forEach((c) =\u0026gt; { c(data); }); } } } const event = new Event(); event.on(\u0026#34;open\u0026#34;, (data) =\u0026gt; { console.log(data); }); event.emit(\u0026#34;open\u0026#34;, { open: true }); 观察者模式 需要两个角色\n目标 观察者 目标 \u0026lt;=\u0026gt; 观察者\n一次完整流程\n观察者观察目标 一旦目标发生变化，目标会主动通知观察者 function observer(obj, target, callback) { if (!obj.data) { obj.data = {}; } Object.defineProperty(obj, target, { get() { return this.data[target]; }, set(val) { this.data[target] = val; // 目标通知观察者 callback \u0026amp;\u0026amp; callback(val); }, }); if (obj.data[target]) { callback \u0026amp;\u0026amp; callback(obj.data[target]); } } ","permalink":"http://localhost:1313/blogs/%E8%AE%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"\u003chr\u003e\n\u003ch2 id=\"发布订阅模式\"\u003e发布订阅模式\u003c/h2\u003e\n\u003cp\u003e简单来说，需要三个角色\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e发布者\u003c/li\u003e\n\u003cli\u003e事件队列\u003c/li\u003e\n\u003cli\u003e订阅者\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e发布者\u003c/strong\u003e -\u0026gt; \u003cstrong\u003e事件队列\u003c/strong\u003e \u0026lt;=\u0026gt; \u003cstrong\u003e订阅者\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e一次完整流程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e订阅者\u003c/code\u003e向事件队列订阅\u003ccode\u003e事件E\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e发布者\u003c/code\u003e向事件队列发布\u003ccode\u003e事件E\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e事件队列通知\u003ccode\u003e事件E\u003c/code\u003e的所有\u003ccode\u003e订阅者\u003c/code\u003e，\u003ccode\u003e订阅者\u003c/code\u003e接收\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 事件队列\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 订阅方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003elistener\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003elistener\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 发布方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eemit\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;open\u0026#34;\u003c/span\u003e, (\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eemit\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;open\u0026#34;\u003c/span\u003e, { \u003cspan style=\"color:#a6e22e\"\u003eopen\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e });\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"观察者模式\"\u003e观察者模式\u003c/h2\u003e\n\u003cp\u003e需要两个角色\u003c/p\u003e","title":"记发布订阅和观察者模式"},{"content":"旅行者计划 30 多年前，美国发起了一项太空计划：旅行者计划。目的是为了探测木星和土星，其中包含旅行者1号和旅行者2号，在 1977 年，美国向太空发射了这两颗探测器。\n伟大的旅行者 1 号 它重 800 公斤，上面搭载了 11 个探测器，有 16 个推进器和一个燃料箱，和三个核能电池，上面还有一台电脑，只有 74kb，没有内存和硬盘，用磁带存储，就这样一个简陋的设备，到目前为止还在工作。\n旅行者 1 号自 1977 年 9 月 5 号发射，已经飞行了44年，距离地球214亿公里，他已经不在太阳系以内了，是目前人造探测器飞行距离最远的一颗探测器，部分功能到目前为止仍可正常运作。 选择在 1977 年发射也是有原因的，正好那个时候，土星木星天王星海王星冥王星，都在太阳的同一侧，几乎连成一条线。这种情况 175 ～ 176 年才会出现一次。大大减少了探测成本。 关于动力，为什么可以飞这么久，因为它采用两个飞行方式，一个是惯性飞行，一个是重力协助，惯性飞行就是宇宙真空没什么阻力，给它一个力就可以一直飞。重力协助是当飞行到大行星附近时，会被大行星的重力拉过来，当和大行星有一定距离后，也由于重力会被甩出去，也叫引力弹弓。利用这两个飞行方式非常节约能源，基本不需要什么燃料，搭载三颗核能电池也是用于照相机和探测器的工作消耗。 发射旅行者 1 号主要有两个目的：一个是探测木星和土星，另外一个探测地外文明。第一个目的完美的完成了，设计之初，就没准备让这这颗飞行器回到地球，一直飞出太阳系向宇宙深处进发，考虑到这一点，在上面装了一个金唱盘，铜制的，表面镀金。 这个上面记载了太阳系的坐标，里面的行星的具体参数，特别标注的地球，证明唱盘来自这里。大自然的声音，包括滑浪，风，雷，鸟鸣，歌声，鲸鱼等其他动物叫声，并挑选来自不同文化的及年代的音乐。人体构造解刨图，计量单位的标准，时间和长度，里面还有一块非常纯的铀238， 因为铀 238 的半衰期是44.7亿年，收到的人根据衰变程度就可以推断出，就能反推唱盘的生产日期。 如上图，在唱盘的一面上，标注了使用方法，包括旋转周期，唱片的时间单位，地球在银河系的位置，图片读取方式等，内容有一些人类生活，自然的图片。 除此外，还有 90 分钟的歌曲，包括不同文化的古典音乐，其中包括有一首中国曲子：高山流水。还有用 55 种语言说的\u0026quot;你好\u0026quot;，包括普通话和粤语。\n金唱盘内全部内容，见 B 站\n旅行者 1 号，去土星其实是为了要去探测土星的一个卫星，泰坦，因为泰坦的环境地球类似，当旅行者 1 号到达泰坦，果然泰坦上有着厚厚的黄色大气，主要是氮气和甲烷，地表温度为零下179度。 旅行者 1 号在探测完泰坦之后，由于土星重力，偏移了黄道面，也就是 9 大行星的平面。在九年后，nasa 又联系了旅行者 1 号，让它拍一张太阳系全家福，就分别拍了 39 张九大行星照片。 这个项目的首席天文学家：卡尔萨根看完地球照片后写了一本非常著名的书《暗淡蓝点》，其中非常经典的一段话：\n如果再来看一眼这个小点， 那是我们的家园，我们的所有。 你所爱所知的每一个人、所听说乃至所存在过的每一个人，都在小点上度过一生。 欢乐与痛苦，宗教与学说，猎人与强盗，英雄与懦夫，文明的创造者与毁灭者，国王与农夫，情侣，父母，儿童，发明家和探险家，崇高的老师，腐败的政客，耀眼的明星，至高无上的领袖，历史上所有的圣人与罪犯，都住在这里——它仅仅是一粒悬浮再阳光中的浮尘\n拍完暗淡蓝点后，nasa 就把旅行者 1 号的相机永久关闭了，为了省电。现在正在以每秒 14 公里的速度远离太阳向宇宙深处进发，但在 2025 年之后，旅行者一号就会彻底和地球失去联系，并成为漂浮在宇宙中的一艘“流浪探测器”。\n推测再过 4 万年，他将利用引力弹弓到达离太阳系最近的一颗恒星上 gliese 445，大概几百万年后，就能到另外一颗恒星附近，或许那个时候人类已经不存在了。对于最多有 120 年寿命的梦想着星辰大海的人类来说，的确让人感到绝望，可有金唱盘，它可以证明人类在浩瀚无垠的宇宙存在过的的一个证据吧\n在21/05/13，也就是两天前，有一条关于旅行者 1 号的新闻，“旅行者 1 号”听到星际“温柔雨声”\n","permalink":"http://localhost:1313/blogs/%E6%97%85%E8%A1%8C%E8%80%851%E5%8F%B7/","summary":"\u003ch2 id=\"旅行者计划\"\u003e旅行者计划\u003c/h2\u003e\n\u003cp\u003e30 多年前，美国发起了一项太空计划：\u003cstrong\u003e旅行者计划\u003c/strong\u003e。目的是为了探测木星和土星，其中包含\u003ccode\u003e旅行者1号\u003c/code\u003e和\u003ccode\u003e旅行者2号\u003c/code\u003e，在 1977 年，美国向太空发射了这两颗探测器。\u003c/p\u003e","title":"旅行者1号"},{"content":"持续更新，为了高效率访问，也算自己复习！！把遇到的手写题，抽空都撸了一遍。满满干货，不墨迹，直接上代码。总结道这篇博客里，下次面试前快速过一遍，临阵磨刀～\n实现 sleep 函数 // 运行log函数后，希望得到结果：打印1，等待一秒钟，打印2，实现sleep函数 function log() { console.log(1); sleep(1000); console.log(2); } log(); // 解1：阻塞主线程 function sleep(time) { let t = Date.now(); while (Date.now() - t \u0026lt;= time) {} } // 解2：async/await调用 function sleep(time) { return new Promise((res) =\u0026gt; { setTimeOut(() =\u0026gt; { resolve(); }, time); }); } 柯里化(currying) // 题目：实现add函数, 输出6 add(1, 2, 3); add(1)(2)(3); add(1, 2)(3); add(1)(2, 3); // 解1：不确定参数数量，一个方法 function add(...agrg1) { let t = function (...agrg2) { return add( Array.from(agrg1) .concat(Array.from(agrg2)) .reduce((a, b) =\u0026gt; { return a + b; }) ); }; t.toString = () =\u0026gt; { return Array.from(agrg1).reduce((a, b) =\u0026gt; { return a + b; }); }; return t; } console.log(add(1, 2, 3)); // 6 console.log(add(1)(2)(3)); // 6 console.log(add(1, 2)(3)); // 6 console.log(add(1)(2, 3)); // 6 // 解2：确定参数数量，两个方法 function currying(fn, ...args) { if (args.length \u0026gt;= fn.length) { return fn(...args); } else { return (...args2) =\u0026gt; currying(fn, ...args, ...args2); } } // add只可以接受三个参数 let add = function (a, b, c) { return a + b + c; }; // 利用currying函数改造add函数，使add函数具备柯里化 const curry_add = currying(add); console.log(curry_add(1, 2, 3)); // 6 console.log(curry_add(1)(2)(3)); // 6 console.log(curry_add(1, 2)(3)); // 6 console.log(curry_add(1)(2, 3)); // 6 约瑟夫环问题 // N个人围成一圈，第一个人从1开始报数，报M的将被淘汰，下一个人接着从1开始报。如此反复，最后剩下两个，求最后的胜利者。 function f(n) { if (n \u0026lt;= 2) { return n === 1 ? [1] : [1, 2]; } let temp = []; for (let i = 1, len = n + 1; i \u0026lt; len; i++) { temp.push(i); } return fun_inner(temp); function fun_inner(temp, count) { if (temp.length == 2) { return temp; } count = count || 1; for (let i = 0, len = temp.wlength; i \u0026lt; len; i++) { count++; if (count === 3) { temp.splice(i, 1); count = 1; } } return fun_inner(temp, count); } } console.log(f(10)); // [4, 10] console.log(f(11)); // [3, 9] console.log(f(12)); // [6, 9] 字符串相加 let addStrings = function (a, b) { let res = []; let temp = 0; if (a.length \u0026gt; b.length) { let t = a.length - b.length; for (let i = 0; i \u0026lt; t; i++) { b = \u0026#34;0\u0026#34; + b; } } else { let t = b.length - a.length; for (let i = 0; i \u0026lt; t; i++) { a = \u0026#34;0\u0026#34; + a; } } for (let len = Math.max(a.length, b.length) - 1; len \u0026gt;= 0; len--) { let i = len; let t_a = Number(a.charAt(i) || 0); let t_b = Number(b.charAt(i) || 0); let count = String(t_a + t_b + temp); temp = 0; if (count.length \u0026gt; 1) { temp = Number(count.charAt(0)); res.push(count.charAt(1)); } else { res.push(count); } } if (temp !== 0) { res.push(temp); } return res.reverse().join(\u0026#34;\u0026#34;); }; 插入排序 let insertion = function (arr) { let len = arr.length; for (let i = 1; i \u0026lt; len; i++) { let cur = i; let j = i - 1; while (j \u0026gt;= 0) { if (arr[cur] \u0026lt; arr[j]) { [arr[cur], arr[j]] = [arr[j], arr[cur]]; cur = j; // 交换后i值变了，那把交换后的i找回来就可以了 } j--; } } return arr; }; 选择排序 let selection = function (arr) { let len = arr.length; for (let i = 0; i \u0026lt; len; i++) { let idx = i; for (let j = i + 1; j \u0026lt; len; j++) { if (arr[j] \u0026lt; arr[idx]) { idx = j; } } [arr[idx], arr[i]] = [arr[i], arr[idx]]; } return arr; }; 快速排序 let quickSort = function (arr) { if (arr.length \u0026lt;= 1) { return arr; } // 递归边界条件 let pointIdx = Math.floor(arr.length / 2); // 在数组中间位置取一个基准点 let point = arr.splice(pointIdx, 1)[0]; // 通过基准点找到这个值 let left = []; let right = []; for (let i = 0, len = arr.length; i \u0026lt; len; i++) { if (arr[i] \u0026lt; point) { // 循环数组，小于point的放在left中，大的放在right中 left.push(arr[i]); } else { right.push(arr[i]); } } // 递归，让每一个left和right继续排序，直到left或right只有一项为止 return quickSort(left).concat(point, quickSort(right)); }; call \u0026amp; apply \u0026amp; bind 实现 window.name = 2; let obj = { name: 1, }; function fn(a, b) { console.log(this.name, a, b); return 1; } // call Function.prototype.myCall = function (context) { context = context || window; // 如果上下文是null或者undefined，那么默认为window context.fn = this; // 设置执行函数到obj上，利用谁调用，谁就是this的特性，来实现this转换 // let arg = Array.from(arguments).slice(1) 截取参数也能这么写 let arg = [...arguments].slice(1); // 截取除了第一个参数以后的参数 let t = context.fn(...arg); // 传参执行 delete context.fn; // 设置完成后删除 return t; // 并返回 }; // apply Function.prototype.myApply = function (context) { context = context || window; context.fn = this; // 设置执行函数到obj上，利用谁调用，谁就是this的特性，来实现this转换 let arg = [...arguments][1]; // 参数是一个数组 if (!arg) { // 如果没参数，那么就不传参执行 return context.fn(); } let t = context.fn(...arg); delete context.fn; return t; }; // bind Function.prototype.Mybind = function (ref, ...arg) { // 当这个函数被new调用，需要解决两个问题 // 1: 不应该使用ref为this，根据情况判断，如果new调用那么this为实例。普通调用this为ref // 2: \b因为bind返回是新函数，所有要bind新函数要继承_this的原型 let _this = this; let fun = function (...arg2) { // 1的实现：this instanceof fun表达式为true说明被new调用，那么this就是新函数的this，也就是一个新的对象，否则就是第一个参数ref thisArg = this instanceof fun ? this : ref; return _this.apply(ref, [...arg, ...arg2]); }; // 2的实现：如果有prototype，那么继承 _this.prototype \u0026amp;\u0026amp; (fun.prototype = Object.create(_this.prototype)); return fun; }; console.log(fn(1, 2)); console.log(fn.myCall(obj, 1, 2)); console.log(fn.myApply(obj, [1, 2])); console.log(fn.Mybind(obj, [1, 2])()); 二叉树反转 let reverseTree = function (root) { if (!root) return null; if (root.left || root.right) { let temp = root.left; root.left = root.right; root.right = temp; reverseTree(root.left); reverseTree(root.right); } return root; }; 链表反转 var reverseList = function (head) { let [prev, curr] = [null, head]; while (curr) { let tmp = curr.next; // 1. 临时存储当前指针后续内容 curr.next = prev; // 2. 反转链表 prev = curr; // 3. 接收反转结果 curr = tmp; // 4. 接回临时存储的后续内容 } return prev; }; 二叉树遍历 以前序遍历举例\n// 递归版 function preTraverse(root) { if (root) { console.log(root.value); preOrder(root.left); preOrder(root.right); } } // 非递归版 function preTraverse(root) { if (!root) { return false; } let stack = []; let p = root; while (stack.length || p) { if (p) { console.log(p.val); stack.push(p); p = p.left; } else { p = stack.pop(); p = p.right; } } } promise 重试 Promise.retry = function(fn, num = 3){ return new Promise(function(resolve, reject){ while(num\u0026gt;0){ try{ const res = await fn resolve(res) num = 0 } catch(e){ if(!num) reject(e) } num -- } }) } ","permalink":"http://localhost:1313/blogs/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/","summary":"\u003cp\u003e持续更新，为了高效率访问，也算自己复习！！把遇到的手写题，抽空都撸了一遍。满满干货，不墨迹，直接上代码。总结道这篇博客里，下次面试前快速过一遍，临阵磨刀～\u003c/p\u003e","title":"手写代码面试题合集"},{"content":" HTML 和 CSS BFC 全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。\n怎么触发： 根元素 body float： right | left position： absolute | fixed display：inline-block | tabel-cells | flex overflow： hidden | auto | scroll 效果 清除浮动，常用 overflow hidde 垂直方向 margin 会重叠 重排和重绘 网页加载过程大致分为 5 步：\nHTML 代码转化成 DOM CSS 代码转化成 CSSOM 结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 其中第 4 步为排列布局，重排指的就是第 4 步重做；第 5 步是绘制，那重绘指的就是第 5 步重做。按照网页加载顺序，第 4 步之后执行第 5 步，所以重排必将触发重绘，而重绘不一定会触发重排。\n重绘：修改元素字体颜色，背景颜色，阴影效果等 重排：位置发生改变，如margin padding width。 删除增加dom 调用offsetHeight等读取实时量值时\n由于重排性能消耗大，那么减少重排次数也就成了一个优化页面的方法，下面总结几个常用方法：\n不要一条一条修改 css，尽量通过 class 修改，或者 csstext 先 display: none; 再修改样式，然后再 display: block; 一个元素大量修改 css，可以设置为 position: fixed | absolute, 这样重排消耗少，因为不用考虑其他元素位置 react vue 虚拟 dom link 和@import 区别 @import属于 css 语法，只能加载 css，link是 html 语法，不仅可以加载 css，还可以加载网站 icon 等\n为什么要使用 css 预处理语言 类似 scss(sass3+)，less 等预处理 css 语言，扩展了 css，具备变量、mixins、函数, 嵌套，带有作用域，支持块注释 //\nsrc 和 href 的区别 src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系。src 加载资源会阻塞页面，href 是加载并行。\nsrc:\n\u0026lt;img src=\u0026#34;/img.jpg\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; href:\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/main.css\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 行内元素特点 可以设置所有方向margin和padding，但是垂直方向无法更改布局 设置width和height属性无效 不会另起一行 实现换肤功能 设置多种颜色类名，覆盖实现 http 请求动态加载 .css 文件 预编译 css 变量 js 部分 箭头函数和普通函数区别 没有自己 this，继承父级的 this 没有自己 arguments // Uncaught ReferenceError: arguments is not defined 没有原型 // undefined script 的 defer 和 async 属性区别 相比于基本的 script 标签、都可以实现异步加载脚本，只是执行脚本的时机不同，\nasync：加载完成后，立即执行，可以在 dom 没完全加载执行，如果多个 script async，那么哪个先加载完就执行哪个，适合加载无依赖的 js defer：加载完成后，等到dom加载完成后执行，如果多个 script defer，会严格按照他们的书写顺序依次执行，适合加载互相依赖的 js 深拷贝 // 冷门深拷贝利用MessageChannel function deepClone(obj) { return new Promise(function (resolve, reject) { var { port1, port2 } = new MessageChannel(); port1.onmessage = function (e) { resolve(e.data); }; port2.postMessage(obj); }); } // 利用weakmap解决了循环引用报错问题，完全版 function deepClone1(_target, map = new WeakMap()) { if (!_target || typeof _target !== \u0026#34;object\u0026#34;) { return _target; } if (map.get(_target)) { console.log(\u0026#34;进入map判断\u0026#34;); console.log(map.get(_target)); return map.get(_target); } let res = Array.isArray(_target) ? [] : {}; console.log(\u0026#34;map set\u0026#34;); console.log(_target, res); map.set(_target, res); for (let i in _target) { console.log(\u0026#34;循环\u0026#34;); if (typeof _target[i] === \u0026#34;object\u0026#34;) { console.log(\u0026#34;是对象\u0026#34;); res[i] = deepClone1(_target[i], map); } else { console.log(\u0026#34;不是对象\u0026#34;); res[i] = _target[i]; } } return res; } 函数防抖和节流 防抖： function debounce(event, delay) { let timer = null; return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理 timer = setTimeout(() =\u0026gt; { event.apply(this, args); }, delay); }; } 节流： function throttle(event, delay) { let prev = Date.now(); return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 let now = Date.now(); if (now - prev \u0026gt;= delay) { event.apply(this, args); prev = Date.now(); } }; } 查看详解\n继承 原型链继承： Cat 继承了 Animal，缺点：所有 Cat 实例都会共享原型链，不可以向 Animal 传参。\nfunction Cat() {} Cat.prototype = new Animal(); call 继承/构造继承: 解决上面原型链建成俩问题，但是只是 Cat 实例，不是 Animal 的实例\nfunction Cat(name) { Animal.call(this); } 组合继承：也就是前面两个方法合并，解决上面两个继承的缺点，唯一的缺点调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\nfunction Cat(name) { Animal.call(this); } Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; //修复构造函数指向 // 优点： // 既是cat实例，又是Animal实例 // 没有共享原型方法问题，并可以传参数 跨域 jsonp： 利用 script 标签跨域，本质是加载一个外部 js\ncors：全程跨域资源共享，服务端操作，把请求头的origin的值取出，响应头会增加Access-Control-Allow-Origin key 并把值设置为origin取出的值也可以是通配符，浏览器就不会拦截响应了，从而解决跨域问题\npostMassage：利用可访问服务资源的iframe，和当前页面互相通信，传递消息，来实现跨域，postMassage本质是两个页面的消息传递方法。\n// 页面1(可以获取后端数据的)传递数据，第二个参数是url匹配规则，可以是通配符 window.frames[0].postMessage(data, \u0026#34;*\u0026#34;); // 页面2(不能接收后端数据的)，接收页面1的数据 window.addEventListener(\u0026#34;message\u0026#34;, function (e) { console.log(e.data); }); 服务器中转： 由于服务端没跨域，服务端代替客户端请求目标接口，并把响应数据返回给客户端\n数组方法 改变原数组 splice: array.splice(index,howmany,item1,\u0026hellip;..,itemX) 删除/添加 sort: 排序 unshift: 首加 shift: 首删; pop: 尾删; push: 尾加 reverse: 倒序排列 fill: 数组填充 array .fill(value, startIndex | 0, endIndex | array.length) [(1, 2, 3, 4, 5)].fill(\u0026#34;a\u0026#34;, 1, 3); // [1, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, 4, 5] 不改变原数组，生成新数组 slice: 浅拷贝 array.slice(startIdx, endIdx) join: 转字符串并分割 toLocaleString: 转换成字符串数组 concat: 连接数组 可用\u0026hellip;替代 indexOf: 检查下标 includes: 是否包含。可替代 indexOf，indexOf === -1 不够语义化 循环方法 forEach、map、filter every、some、reduce、reduceRight(和 reduce 区别是相反方向) 字符串方法 var str = \u0026#34;hello world\u0026#34;; str.charAt(1); //e 返回指定下标的字符 str.charcodeAt(1); //101 返回指定下标字符的字符编码 str.concat(123); // hello world123 连接字符串，生成新的 str.slice(0, 2); // he 截取字符串，参数为下标 str.substring(0, 2); // he 截取字符串，参数为下标 str.substr(0, 2); // he 截取字符串，第一个参数是起始下标，第二个参数为截取数量 str.indexOf(\u0026#34;h\u0026#34;, 0); // 0 查子字符下标，第一个参数是字符，第二个参数是起始下标 str.lastIndexOf(\u0026#34;h\u0026#34;, 0); // 0 查子字符下标，第一个参数是字符，第二个参数是结尾下标(和indexof区别) str.toLowerCase(); // hello world 转小写 str.toUpperCase(); // HELLO WORLD 转大写 str.trim(); // 删除前后空格 str.split(\u0026#34;e\u0026#34;); // [\u0026#34;h\u0026#34;, \u0026#34;llo world\u0026#34;] 转数组，参数为分割符 str.replace(\u0026#34;o\u0026#34;, \u0026#34;a\u0026#34;); // hella world 替换字符，第一个参数可以是正则 str.match(/hello/g); // [\u0026#34;hello\u0026#34;] 匹配字符串返回一个数组，参数常是正则 js 垃圾回收机制 当内存中的数据不需要时候，js 会自动使用垃圾回收算法释放掉\n引用计算 : 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。这是最初级的垃圾收集算法。 该算法有个限制：无法处理引用循环，两个对象互相引用的情况下，引用次数至少是 1，所以不会被回收掉 标记清除 : 此算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法从根（root）全局对象开始先下查找，找到不可以被获得的对象，然后清除掉 类型检测 typeof: 除了基本数据类型，检测不到具体 object 类型(数组，对象，时间对象，正则，set，map) instanceof: 例 a instanceof Fun 原理是检测 a 是不是 Fun 的实例，缺点就是被检测的值必须是引用，如下所示 new Number(1) instanceof Number; // true 1 instanceof Number; // false constructor: 实例.constructor === 构造器，缺点是 constructor 属性容易被修改 Object.prototype.toString.call: 目前最好用的一个方法，缺点是使用 object 构造函数的 toString 方法，此方法可能被修改 Object.prototype.toString.call(1) // \u0026#34;[object Number]\u0026#34; Object.prototype.toString.call(\u0026#39;1\u0026#39;) // \u0026#34;[object String]\u0026#34; Object.prototype.toString.call([1]) // \u0026#34;[object Array]\u0026#34; // 如果修改原型 Object.prototype.toString = Array.prototype.toString Object.prototype.toString.call([1,2,3]) // \u0026#34;1,2,3\u0026#34; ... valueOf 和 toString valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 对象转字符串或者数字的过程：如果转换成字符串，会优先调用 toString 方法，转数字，会优先调用 valueOf 方法\n相关面试题：\n// 下面代码a在什么值情况下会输出1 var a = ?; if (a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3) { console.log(1); } // 解 var a = { n : 0, valueOf(){ return ++this.n; } }; proxy 和 reflect proxy 对目标读取、函数调用等操作进行拦截，然后操作处理。它不直接操作对象，而是像代理模式。\nlet target = { name: \u0026#34;Tom\u0026#34;, age: 24, }; let handler = { get: function (target, key) { console.log(\u0026#34;getting \u0026#34; + key); return target[key]; // 不是target.key }, set: function (target, key, value) { console.log(\u0026#34;setting \u0026#34; + key); target[key] = value; }, }; // target为目标对象，handler为代理处理 let proxy = new Proxy(target, handler); reflect 优化了 object 内部操作，修改一些函数的返回值，如 Object.defineProperty，Reflect 与 Proxy 是一一对应的对象，是 Proxy 的方法也是 Reflect 的方法，Proxy 修改的过的方法可以在 Reflect 获取默认值。\n// 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 Object.defineProperty(target, property, attributes) // 报错 Reflect.defineProperty(target, property, attributes // false // 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 \u0026#39;assign\u0026#39; in Object // true Reflect.has(Object, \u0026#39;assign\u0026#39;) // true requestAnimationFrame 针对实现动画 setInterval 的优化方法，执行速率和设备屏幕帧率有关系，不需要调用者指定帧速率，交给浏览器自行决定最佳帧效率，每一帧只执行一次，多次改变触发一次重拍，这样不会引起丢帧现象，也不会导致动画卡顿\n事件循环 同步任务在执行栈，异步任务执行后回调区分微任务和宏任务放入对应的微宏队列中，等同步执行栈执行完毕，会先检查微任务队列，执行完毕后，检查宏任务队列，执行。其中 Promise.resolve 调用静态方法，会优先于正常的 promise 的 resolve 方法\n异步微任务有哪些：\nnew Promise() 异步宏任务有哪些：\nsetInterval() setTimeout() 执行顺序： 同步放入执行栈 =\u0026gt; 异步放入任务队列 =\u0026gt; 异步区分微宏任务 =\u0026gt; 微任务 =\u0026gt; 宏任务\nasync/await，await 后的语句是同步的，在函数体内，await 下的语句会被放入 promise 回调函数体中，async 函数默认返回一个 promise 对象\n经典面试题：\nasync function async1() { console.log(\u0026#34;async1 start\u0026#34;); await async2(); console.log(\u0026#34;async1 end\u0026#34;); } async function async2() { console.log(\u0026#34;async2\u0026#34;); } console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); async1(); new Promise(function (resolve) { console.log(\u0026#34;promise1\u0026#34;); resolve(); }).then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); 解析：按照从上往下顺序先执行同步代码，前两个函数async1和async2是函数声明，忽略。然后第 1 个输出的是script start，然后看到setTimeout, 由于它是异步且属于宏任务，放到最后执行。然后看到 async1 函数被执行了，进入async1函数体，第 2 个输出的是async1 start, 看到 await 规则是：await 右的语句被同步执行，所以第 3 个输出的是async2，await 下的语句(函数体内)被当作 async 函数返回一个 promsise 的回调函数体的语句去处理，且被放入了异步任务队列中，等待中。然后跳出 async1 函数体，继续执行同步代码，遇到 new Promise，第 4 次输出promise1，看到 resolve，就把 then 中回调，放入任务队列中，然后继续向下执行同步代码，第 5 次输出的最后的script end。至此同步执行栈空了，开始把任务队列中的上下文拿到执行栈执行，由于队列先进先出，所以第一个被入栈的是 async1 的回调，也就是第 6 次输出的是async1 end，然后把第二个队列中的上下文放入执行栈，也就是 promise 的 resolve，所以第 7 次输出promise2，至此微任务执行完成，现在执行宏任务，也就是 timeout，所以第 8 次输出为setTimeout。\n结果：\nscript start async1 start async2 promise1 script end async1 end promise2 setTimeout 迭代器和生成器 先来瞅一段代码：\nfunction createIterator(items) { var i = 0; return { // 返回一个迭代器对象 next: function () { // 迭代器对象一定有个next()方法 let done = i \u0026gt;= items.length; let value = !done ? items[i++] : undefined; return { value: value, done: done, }; }, }; } var iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // \u0026#34;{ value: 1, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 2, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 3, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: undefiend, done: true}\u0026#34; 这就是迭代器，迭代器是一个特殊对象，可以通过每调用一次 next，获取下一项结果。可以用迭代器替代 for 循环，因为 for 通过下标获取，多层嵌套比较复杂。\n// 用迭代器模拟for var colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;]; var iterator = createIterator(colors); while (!iterator.next().done) { console.log(iterator.next().value); } 迭代器模拟 for 的方法看起来太麻烦了，不如 for 来的方便，这个时候可以用生成器(* 和 yield)来快速生成迭代器。\nfunction* createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } let iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // \u0026#34;{ value: 1, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 2, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 3, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: undefiend, done: true}\u0026#34; 通过*和yield关键字创建，*来表示这个函数内部是可以用 yield 返回每次迭代的值，和 async、await 一样。需要组合使用，yield后面接每次迭代的值。这样就可以外部调用.next()获取下一个值。\n在 es6 中，数组、Set、Map、字符串集合，都属于可迭代对象，内部都有默认迭代器，可通过object[Symbol.iterator]()访问默认迭代器。\nes6 中也提供了一个通过方法来快速使用迭代器\nfor(item of 集合迭代器) {...} 常见的迭代器和得到 item 的值：\nobject.keys(): key(对象)/下标(数组) object.values(): 每项 value object.entries(): [下标/key, value] 事件委托与冒泡和捕获 什么是事件委托：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n什么是冒泡和捕获：其实都是事件传播路径。冒泡：从外到事件源进行事件传播；捕获：从内向事件源进行事件传播；\nDOM 标准事件流的触发的先后顺序为：先捕获再冒泡。即当触发 dom 事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。 addEventListener事件监听方法的第三个参数默认值是false，表示冒泡阶段调用，true为捕获阶段调用\n\u0026lt;body\u0026gt; \u0026lt;button\u0026gt;append\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;0\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; window.onload = function () { document.querySelector(\u0026#34;button\u0026#34;).onclick = function (e) { let li = document.createElement(\u0026#34;li\u0026#34;); li.innerHTML = \u0026#34;5\u0026#34;; document.querySelector(\u0026#34;ul\u0026#34;).appendChild(li); }; document.querySelector(\u0026#34;ul\u0026#34;).onclick = function (e) { // li 新增的li也是可以被点击的 console.log(e.target.nodeName.toLowerCase()); }; }; addeventListener 和 onclick 不同点：\naddeventListener 可以给一个事件注册多个 listener addEventListener 可以控制时间传播行为（捕获/冒泡，使用 removeEventListener 来解决） 实现 instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 let objProto = obj.__proto__; while(objProto) { if (objProto === ctor.prototype) { return true; } objProto = objProto.__proto__; } return false; } var Food = function() {}; var Meat = function() {}; Meat.prototype = new Food(); var meat = new Meat(); newInstanceof(meat, Meat) // true newInstanceof(meat, Food) // true meat instanceof Meat // true meat instanceof Food // true 总的来说就是meat.__proto__.constructor === Meat，由于原型链是一条链，所以循环所有__proto__; 直到null为止，符合Meat.prototype === meat.__proto__即返回true，否则返回false。\nconstructor 和 super 关键字 class是ES6新增的关键字，为了看起来更像java等面向对象语言，实际上是一个语法糖，等同于ES5的function来创建构造函数。\nconstructor ：constructors是 class 中默认的一个关键字，会自动调用该方法，class中必须要有constructor，如果没有，会被默认添加。当 new 时，constructor会被执行返回一个 this，就是实例。 super ： 当class有继承时，在constructor内部必须执行一遍 super()函数，B 继承 A，super相当于A.prototype.constructor.call(this, props)，另外 super()也指向父亲 A 的原型对象， 详细解释。如果当前类和父类都有同名方法，如何区分地获取呢，获取父类：super().fun，获取当前类：fun vue 部分 vue 组件通信 props 和 $emit provide inject：在组件 a 声明，在 a 下面所有子组件通过 inject 调用，通过参数传递 event bus： new 出一个 vue，通过 emit 和 on 来派发和监控 vuex 全局状态管理 this.$children 和 this.$parent 层级较深不推荐，provid 可以替代此方法 vue 生命周期父子组件执行顺序 父 beforeCreate -\u0026gt; 父 created -\u0026gt; 父 beforeMount -\u0026gt; 子 beforeCreate -\u0026gt; 子 created -\u0026gt; 子 beforeMount-\u0026gt;子 mounted-\u0026gt;父 mounted\n子组件更新：父 beforeUpdate -\u0026gt; 子 beforeUpdate -\u0026gt; 子 updated -\u0026gt; 父 updated\n父组件更新：父 beforeUpdate -\u0026gt; 父 updated\n销毁：父 beforeDestroy -\u0026gt; 子 beforeDestroy -\u0026gt; 子 destroyed -\u0026gt; 父 destroyed\n总结带 beofre 的生命周期都是从父到子调用，带 ed 的生命周期都是从子到父\n前端路由 hash 14 年前，前端路由都是用 hash 的方式实现的，地址长这个样子url#hash， 修改hash部分不会重载这个页面，每次 hash 改变，可以用 window 的hashchange方法来监听，通过这个方法就可以实现前端路由了\nhistory 在 14 年，HTML5 标准发布，window 上新增了两个 api：pushState和replaceState，也 hash 一样，不刷新来实现前端路由，而且少了#更美观了，由于没#，所以刷新时候，默认会从服务器下载对应 url 资源，这个时候我们需要改下服务器配置，都加载前端 index.html 文件，来实现前端路由\n// 第一个参数是state，用于描述一些特性，会被放入历史栈中，开发者使用 // 第二个参数是title，表示新页面的标题，浏览器都会忽略这个参数 // 第二个参数是url，表示新页面的相对地址 // 跳转 window.history.pushState(null, null, \u0026#34;/profile\u0026#34;); window.history.replaceState(null, null, \u0026#34;/profile\u0026#34;); 和pushState的区别是不会把记录放入历史栈中; 共同点 都不会重载页面 都会把历史记录放入栈中 不同点 hash 只可以#后部分，必须是同源 url，history 没有限制 history 需要修改服务器配置，来解决刷新空白问题，hash 本身就是属于前端的，不需要设置 slot 插槽 匿名插插: 子组件包裹的内容会被显示到slot标签中 \u0026lt;child\u0026gt;父给子的内容\u0026lt;/child\u0026gt; // child组件中, 父给子的内容会显示slot标签里 \u0026lt;slot\u0026gt;父给子的内容\u0026lt;/slot\u0026gt; 具名插插：感觉名字多次显示，可复用 \u0026lt;div slot=\u0026#34;down\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;的内容 会被显示到\u0026lt;slot name=\u0026#34;down\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt;里 数据插槽： // 父亲中 \u0026lt;div v-slot:data=\u0026#34;{data}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 组件中就可以用data了 \u0026lt;myslot v-slot=\u0026#34;data\u0026#34;\u0026gt; {{ slotProps.user.firstName }} \u0026lt;/myslot\u0026gt; keep-alive keep-live 是 vue 提供的内置缓存组件，可以保存组件状态，避免重新渲染，keep-alive 有三个参数：\ninclude 匹配的组件会被缓存，参数：字符串、数组、正则 exclude 匹配的组件不会被缓存，参数：字符串、数组、正则，和 include 同时存在一个组件的的话，exclude 优先级更高 max 可以限制最大可以缓存组件的数量，字符串或者数字 \u0026lt;!-- 组件name为a或者b的组件缓存 --\u0026gt; \u0026lt;keep-alive include=\u0026#34;a,b\u0026#34;\u0026gt; \u0026lt;component\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;!-- 组件name为c的组件不缓存 --\u0026gt; \u0026lt;keep-alive exclude=\u0026#34;c\u0026#34;\u0026gt; \u0026lt;component\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; 缓存组件会多出两个生命周期，activated和deactivated，渲染和销毁\nkeep-alive 可配合 router-view 来实现组件缓存\n\u0026lt;keep-alive\u0026gt; \u0026lt;router-view v-if=\u0026#34;$route.meta.keepAlive\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;router-view v-if=\u0026#34;!$route.meta.keepAlive\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;a\u0026#39;, component: a, meta: { keepAlive: false // 不缓存 } }, { path: \u0026#39;/b\u0026#39;, name: \u0026#39;b\u0026#39;, component: b, meta: { keepAlive: true // 缓存 } } ] }) nextTick nextTick 可以获取下次最新 dom 的方法，因为 vue 的 dom 更新策略是异步的，只有一个事件循环结束后才会被应用来更新 dom，这导致数据的修改不会立即表现在 dom 上，如果要获取更新后的 dom 状态，这时候就需要用到 nextTick\n一些场景：\ncreated 中想要获取 DOM 更改数据获取最新的 dom mixin vue mixin 是针对组件间功能共享来做的。可以对组件的任意部分进行 mixin，也就是说不同的组件，想使用同一个数组，或者方法，那么 mixin 就是来做这个事的，把公共部分提取出来作为 mixin\n声明：\n// 声明 const toggle = { data() { isshowing: false; }, methods: { toggleShow() { this.isshowing = !this.isshowing; }, }, }; // 使用，toggle的方法会自动合并到当前组件中 mixins: [toggle]; vuex 核心概念：\nstate：数据 getter：类似计算属性，用来获取 state mutation： 同步方法，用于修改 state action： 异步方法，最后调用 mutation 修改 state // 声明 import Vuex from \u0026#39;vuex\u0026#39; const store = new Vuex.Store({ state: { count: 0 }, getter: { doneTodos: (state, getters) =\u0026gt; { return state.todos.filter(todo =\u0026gt; todo.done) }, count: (state) =\u0026gt; { return state.count } }, mutations: { increment (state, payload) { state.count++ } }, actions: { addCount(context) { // 可以包含异步操作 // context 是一个与 store 实例具有相同方法和属性的 context 对象 } } }) // 使用 // 调用mutation this.$store.commit(\u0026#39;increment\u0026#39;, 10) // 调用actions this.$store.dispatch(\u0026#39;increment\u0026#39;, 10) // 利用mapGetters mapGetters mapMutations mapActions便捷使用 computed: { ...mapGetters([\u0026#39;audio\u0026#39;]), ...mapState({ this.count 等同于 state.count + this.localCount count(state) { return state.count + this.localCount } }, methods: { ...mapMutations({ add: \u0026#39;increment\u0026#39; // 将 `this.add()` 映射为`this.$store.commit(\u0026#39;increment\u0026#39;)` }), ...mapActions({ add: \u0026#39;increment\u0026#39; // 将 `this.add()` 映射为 `this.$store.dispatch(\u0026#39;increment\u0026#39;)` }) } react 部分 react 生命周期 componentWillMount：在渲染前调用，客户端服务端都会调用 componentDidMount：第一次渲染后调用，只在客户端 componentWillReceiveProps： 接收新的 props 被调用，初始化时不会被调用 shouldComponentUpdate： 组件更新(props,state)时调用；返回布尔值，T 为允许更新组件，F 为不更新组件 componentWillUpdate： 组件更新(props,state)前渲染前被调用，初始化时不会调用 componentDidUpdate：组件完成更新后调用。初始化时不会被调用 componentWillUnmount： 组件要销毁前调用 react 数据响应式 react 的响应式是使用 diff 算法实现的。react 在 state 改变时，会调用 render() 方法，生成一个虚拟 DOM 树，React 会将这棵树与上一次生成的树进行比较，找出其中的差异，并更新差异的部分。这个过程是递归的，react 会以当前组件为根，递归比较所以子节点。为了优化性能，React 提供了 shouldComponentUpdate 生命周期方法，这个方法有两个参数，nextProps和nextState，表示上次 props 和上次 stage，返回值是布尔值，如果这个方法返回 false，react 就跳过这个组件，不做 VDOM 比较，也不更新组件。\n在 react16+版本，对 diff 过程进行了优化，从原来的 diff 树结构+递归的方式优化成 fiber 双向链表+循环执行。整个的 diff 过程分为 render 阶段和 commit 阶段，render 就是对比过程，找到需要改变 dom 的那部分，commit 就是执行改变 dom 的那部分，render 阶段是可以分段的（中断，然后继续完成），类似原生的requestIdleCallback方法，在每个 16ms 帧内，会先执行用户输入，事件回调等优先级高的 js 任务。之后剩下的时间执行分段的 render 部分来进行数据更新，保证视觉上的页面流程度。\nhttp 部分 http 缓存 分为 强缓存 和 协商缓存，如果同时存在，强缓存 优先 协商缓存\n强缓存： 响应头 Expires：Fri, 31 Dec 2024 23:59:59 GMT，在这个时间之前，直接读缓存，否则请求新内容，因为值是一个服务端返回的时间，这是 http 1.0 的产物，如果客户端和服务端时间不一致，就会和预期不符，所以在 http 1.1 中新增 Cache Control 来控制缓存 Cache Control：max-age=x 秒，在 x 秒内直接读缓存，避免了 expires 时间不一致问题 Cache Control 其他的 value：\nPrivate: 私有缓存，资源可以仅可以被客户端缓存（默认值） Public: 资源可以被任何缓存（包括中间代理服务器）缓存 No-Cache: 协商缓存 No-Store: 绝对不缓存 Max-Age：强缓存 协商缓存 （Last-Modified 优先 ETag） 当 Cache Control 设置为 No-Cache 时使用\nLast-Modified / If-Modified-Since：服务器会返回上次修改时间 Last-Modified，浏览器下次请求时请求头会带上 If-Modified-Since ，然后由服务端验证，如果 If-Modified-Since 在 Last-Modified 时间以内 ，就返回 304，浏览器读缓存，否则返回新内容 ETag / If-None-Match：服务器会返回内容 hash ETag 响应头，浏览器下次请求时请求头会带上 If-None-Match ，然后由服务端验证，如果一致，就返回 304，浏览器读缓存，否则返回新内容 附上一张说明图：\nhttps 握手 https 是 http 的安全扩展，相当于 HTTP + SSL(TLS) = HTTPS。SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层即网络层，TLS 是 SSL 的新版本，最后一个 SSL 3.0 版本在 2015 年废弃，之后就是 TLS，现在常见的 TLS 版本是 1.2 和 1.3 版本。那么 TLS 是如何实现的呢？\n浏览器 =\u0026gt; 服务器：请求发起，建立 SSL 连接，发送 TLS 协议版本号 + 支持的加密方法列表 + 客户端随机数 服务器 =\u0026gt; 浏览器：判断加密协议版本是否一致，并确认加密方法，都没问题则返回服务器证书 + 服务端随机数 浏览器 =\u0026gt; 服务器：收到服务器证书，检查颁发机构、过期时间、域名，没有问题，则生成一个字符串（通过上面 客户端随机数 + 服务端随机数 生成），并用公钥（从服务器证书里取出）加密（非对称加密），发给服务器 服务器 =\u0026gt; 浏览器：服务器用自己的私钥解密，得到这个字符串，后续使用这个字符串进行对称加密进行通信 http1.1长连接和http2多路复用区别 http1.1 长连接 同一个域名访问同一个文件的多个请求都可以复用一个 tcp 连接（不用像 1.0 一样 每次请求都需要重新建立连接，但不是并行，只能按顺序执行。\nhttp2 多路复用 同一个域名访问多个文件的多个请求也可以复用一个 tcp 连接，且多个请求可以被并行处理。\n其他 npmRun 会自动到 package.json 找到对应的命令执行。如果没有全局命令，会自动到node_modules/.bin/下找到对应可执行文件执行，这时npm run xxx等同于直接调用/images/node_modules/.bin/xxx\ncookie 的几种属性和作用 name: 名字 value: 值 domain: 可以访问此 cookie 的域名 path: 可以访问此 cookie 的路径 sameSite: 跨站点携带 cookie 设置 None：不限制； Lax：默认值，介于 None 和 Strict 之间，会合理判断携带 cookie 时机，如链接 a 会携带 cookie； Strict：完全禁止跨站点传送 cookie； httponly: 值为 true 则仅在 http 请求中会传递 cookie，不可用 document.cookie 等操作获取 secure: 是否只能使用 https 传递此 cookie expires: 过期时间；值是时间意思是到这个时间，cookie 失效，否则是 session，即退出浏览器后自动失效 输入 url 到页面展示经历了什么 dns 解析：按照这个步骤查询，找到 ip，立即中断返回给客户端（浏览器缓存 =\u0026gt; 操作系统缓存(host) =\u0026gt; 路由器缓存 =\u0026gt; 本地服务器缓存 =\u0026gt; isp dnf 服务器查询 =\u0026gt; 根 dns 服务器）\ntcp 三次握手\n发送 http 请求报文：报文包括：请求行，请求头，请求体\n服务端接收到请求： 进入 web 服务器，如 apache、nginx，然后进入后台程序\n服务器响应报文：报文包括：响应行，响应头，响应体\n浏览器渲染页面\n根据 html 得到 dom 树 根据 css 得到 css 树 根据 dom 树和 css 树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 数据传送完成，四次挥手关闭：\n懒加载 页面中一些大资源加载较慢，比如 iframe，img。针对这个问题可以通过懒加载解决。\n拿img举例，先设置img的src属性为一个默认的资源，然后把真实url放在标签的某个属性中。并设置好图片的宽高，避免完成加载时出现页面闪动问题。\n然后实时监听页面滚动，如果当前图片是可见状态，那么把图片的真实 url 属性值取出替换到默认src上来实现加载图片资源，从而提升页面打开速度和合理使用客户端流量。\n// 获取浏览设备的网页可视高度 let clientHeight = document.documentElement.clientHeight; // 获取已被滚出的页面高度 let scrollTop = document.documentElement.scrollTop; // 图片顶部到网页顶部的高度 let imgOffsetTop = document.querySelector(\u0026#34;img\u0026#34;).offsetTop; // 判断img在可视区域内： imgOffsetTop \u0026lt; clientHeight + scrollTop; commonjs 模块和 es6 模块有什么区别 commonjs:\n对于基本数据类型，是值的拷贝 对于复杂数据类型，是浅拷贝，也就是修改一个模块的值，引用他的值也会发生改变 第一次加载模块会缓存，往后再加载会读取缓存的数据 es6：\n所有数据都是只读引用，当遇到 import 语句时，会生成一个只读引用，等到文件中真的使用到模块中的值时，根据只读引用，到加载中的模块取值 不允许修改模块中的数据，并且是动态的，比如模块中的值发生改变，引入得到的值也会改变。 前端优化 静态资源放在 cdn 首屏加载服务端渲染 可以升级到 http2，可以使用 http2 多路复用 多个请求并行，可以打乱顺序，最后重组 使用字体图标替代图片 gzip 压缩 uglify plugin 优化压缩代码 图片懒加载 图片压缩，优先使用 webp 减少重排，多使用类名或者 csstext 处理样式 多使用 flex，性能优，兼容性好 常见算法介绍 二分查找：也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。\n贪心算法：又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），贪图眼前局部的利益最大化。\n回溯算法：实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。\n分治算法：分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。\n动态规划：动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。\nbabel 工作原理 在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。简单来说就是一种描述源代码的结构，用于被计算机识别到，并成语言引擎执行\n工作原理大致可以理解成，字符串输入=\u0026gt;转换=\u0026gt;输出\n根据 babylon 解析器，把 js 代码按照规范解析成 AST 语法树 按照规则(stage-0,1,2,3),修改 AST 语法树，常见把高级语法，转换成低级语法 最后通过 babel-generator 将修改后的 AST 语法树转换成 js 代码 ","permalink":"http://localhost:1313/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","summary":"\u003c!-- [HTML 和 CSS 部分](#HTML和CSS)\n\n- [BFC](#BFC)\n- [重排和重绘](#重排和重绘)\n- [行内元素特点](#行内元素特点)\n- [实现换肤功能](#实现换肤功能)\n- [link 和@import 区别](#link和@import区别)\n- [为什么要使用 css 预处理语言](#为什么要使用css预处理语言)\n- [src 和 href 的区别](#src和href的区别)\n\n[js 部分](#js部分)\n\n- [箭头函数和普通函数区别](#箭头函数和普通函数区别)\n\n- [script 的 defer 和 async 属性区别](#script的defer和async属性区别)\n- [深拷贝](#深拷贝)\n- [函数防抖和节流](#函数防抖和节流)\n- [继承](#继承)\n- [跨域](#跨域)\n- [数组方法](#数组方法)\n- [字符串方法](#字符串方法)\n- [js 垃圾回收机制](#js垃圾回收机制)\n- [类型检测](#类型检测)\n- [valueOf 和 toString](#valueOf和toString)\n- [proxy 和 reflect](#proxy和reflect)\n- [requestAnimationFrame](#requestAnimationFrame)\n- [事件循环](#事件循环)\n- [迭代器和生成器](#迭代器和生成器)\n- [事件委托与冒泡和捕获](#事件委托与冒泡和捕获)\n- [实现 instanceof](#实现instanceof)\n- [constructor 和 super 关键字](#constructor和super关键字)\n\n[vue 部分](#vue部分)\n\n- [vue 组件通信](#vue组件通信)\n- [vue 生命周期父子组件执行顺序](#vue生命周期父子组件执行顺序)\n- [前端路由](#前端路由)\n- [slot 插槽](#slot插槽)\n- [keep-alive](#keep-alive)\n- [nextTick](#nextTick)\n- [mixin](#mixin)\n- [vuex](#vuex)\n\n[react 部分](#深拷贝)\n\n- [react 生命周期](#react生命周期)\n- [react 数据响应式](#react数据响应式)\n\n[http 部分](#http部分)\n\n- [http 缓存](#http缓存)\n- [https 握手](#https握手)\n- [http1.1 长连接和 http2 多路复用区别](#http1-1长连接和http2多路复用区别)\n\n[其他](#其他)\n\n- [npm run](#npmRun)\n- [cookie 的几种属性和作用](#cookie的几种属性和作用)\n- [输入 url 到页面展示经历了什么](#输入url到页面展示经历了什么)\n- [懒加载](#懒加载)\n- [commonjs 模块和 es6 模块有什么区别](#commonjs模块和es6模块有什么区别)\n- [前端优化](#前端优化)\n- [常见算法介绍](#常见算法介绍)\n- [babel 工作原理](#babel工作原理) --\u003e\n\u003ch1 id=\"html-和-css\"\u003eHTML 和 CSS\u003c/h1\u003e\n\u003ch2 id=\"bfc\"\u003eBFC\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。\u003c/p\u003e","title":"前端面试题总结"},{"content":"diff 算法 和 virtual dom 在现代 mvvm 框架 react 和 vue 中，因为直接操作 dom 相对是要耗费更多性能的，所以 react 和 vue 都使用了 virtual dom 来替代处理 dom，大致的过程是：按照 dom 结构生成一份 virtual dom 为对象结构。如果数据有更新，需要表现在 dom 上，那么先把变化表现在 virtual dom，再通过 diff 算法比对数据更新前后两次 virtual dom 找到差别。最后把仅仅改变的这部分更新到 dom 上，不用重新渲染整个页面。\n总结：diff 算法就是找到两个 virtual dom 树结构的不同\ndiff 原理 首先传入新旧 vnode 到 patch 函数开始比较:\nfunction patch(oldVnode, vnode) { if (sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode); // 如果两个vnode值得比较，调用patchVnode } else { const oEl = oldVnode.el; // oldVnode.el为对应的真实dom元素 let parentEle = api.parentNode(oEl); createEle(vnode); // 按照vnode结构创建真实dom插入父元素，直接替换oldVnode if (parentEle !== null) { api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)); api.removeChild(parentEle, oldVnode.el); oldVnode = null; } } return vnode; } 首先使用 sameVnode 方法判断两个 vnode 是否值得比较，代码如下\nfunction sameVnode(oldVnode, vnode) { // key代表当前节点数据的key属性，大概的意思就是div和span为不同标签。p.class1和p.class2为不同标签 return vnode.key === oldVnode.key \u0026amp;\u0026amp; vnode.sel === oldVnode.sel; } 一致就按照上步骤，继续往下处理。执行 patchVnode 方法，如不一致，直接用新元素 直接替换 到旧元素。\n如果两个 vnode 值得比较，调用 patchVnode:\npatchVnode (oldVnode, vnode) { const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return // 引用相同，就说明相同，直接return if (oldVnode.text !== null \u0026amp;\u0026amp; vnode.text !== null \u0026amp;\u0026amp; oldVnode.text !== vnode.text) { // 如果有文本内容，比较，如果不同直接设置，用新的替换旧的文本 api.setTextContent(el, vnode.text) }else { updateEle(el, vnode, oldVnode) if (oldCh \u0026amp;\u0026amp; ch \u0026amp;\u0026amp; oldCh !== ch) { // 如果都有子节点，且不同，开始比较子节点 updateChildren(el, oldCh, ch) }else if (ch){ // 如果只有新vnode上有子节点，直接新建 createEle(vnode) }else if (oldCh){ // 如果新vnode没子子节，而老vnode有，则删除老节点的子节点 api.removeChildren(el) } } } 如果都有子节点，且不同，开始比较子节点，调用 updateChildren 函数开始比较子节点:\nupdateChildren (parentElm, oldCh, newCh) { // parentElm：真是dom节点。oldCh：老vnode的所有子节点。newCh：新vnode的所有子节点。 // 通过下标，设置新旧vnode的前后两个元素， let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] // 设置一些比较过程需要的变量 let oldKeyToIdx let idxInOld let elmToMove let before // 两对节点，分别从头和尾向中间循环靠拢依次比对，如果起始下标大于结尾下标，证明比对结束，作为循环结束条件 while (oldStartIdx \u0026lt;= oldEndIdx \u0026amp;\u0026amp; newStartIdx \u0026lt;= newEndIdx) { if (oldStartVnode == null) { //对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] }else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx] }else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx] }else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] }else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newEndVnode)) { patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldEndVnode, newStartVnode)) { patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] }else { // 使用key时的比较 if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 } idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] } else { elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) }else { patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) } newStartVnode = newCh[++newStartIdx] } } } if (oldStartIdx \u0026gt; oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) }else if (newStartIdx \u0026gt; newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) } } 总结：\n调用 patch：传入 新旧vnode，调用 sameVnode，返回 true 说明值得比较，则调用 patchVnode，否则直接使用新节点替换旧节点\n调用 patchVnode：更详细的对比新旧 vnode，分几种情况：\n1: 对于新旧 vnode 的.el 真实 dom 属性，并对比，如果===那就证明是同一个，直接 return 2: 如果存在文本节点，直接用新 vnode 内文本替换旧 vnode 文本 3: 判断子节点，如果新 vnode 有，旧 vnode 没有，则直接把新 vnode 的子节点加入到真实 dom，相反就删除掉真实 dom 子节点 4: 如果都有子节点，且不同，调用 updateChildren，详细对比 调用 updateChildren： 从两边向中间收拢循环两个新旧 vnode 的每个子节点，以此对比，头头，尾尾，头尾，尾头。如果这四种比对调用 sameVnode，得到 true，证明值得对比，那么就调用第二步骤的 patchVnode 递归继续比，除了这四种情况。如果有 key，则会对比 key。否则直接替换新元素到真实 dom。\n","permalink":"http://localhost:1313/blogs/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"diff-算法-和-virtual-dom\"\u003ediff 算法 和 virtual dom\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"WechatIMG3177.png\" loading=\"lazy\" src=\"/images/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/HrGjhDp8ebSt62R.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在现代 \u003ccode\u003emvvm\u003c/code\u003e 框架 \u003ccode\u003ereact\u003c/code\u003e 和 \u003ccode\u003evue\u003c/code\u003e 中，因为直接操作 dom 相对是要耗费更多性能的，所以 \u003ccode\u003ereact\u003c/code\u003e 和 \u003ccode\u003evue\u003c/code\u003e 都使用了 \u003ccode\u003evirtual dom\u003c/code\u003e 来替代处理 dom，大致的过程是：按照 dom 结构生成一份 \u003ccode\u003evirtual dom\u003c/code\u003e 为对象结构。如果数据有更新，需要表现在 dom 上，那么先把变化表现在 \u003ccode\u003evirtual dom\u003c/code\u003e，再通过 \u003ccode\u003ediff\u003c/code\u003e 算法比对数据更新前后两次 \u003ccode\u003evirtual dom\u003c/code\u003e 找到差别。最后把仅仅改变的这部分更新到 dom 上，不用重新渲染整个页面。\u003c/p\u003e","title":"vue中的diff算法实现"},{"content":"promise 类 class Pro { callbacks = []; state = \u0026#34;pending\u0026#34;; value = null; constructor(fn) { // 初始化，把resolve作为参数传入，等待调用 fn(this.resolve.bind(this)); } // callback为回调，先注册，也就是放入callbacks数组中 then(callback) { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(callback); } else { // 由于state不是pending, 遵循promise状态只能改一次的要求，我们直接操作回调传入参数执行 callback(this.value); } return this; } // resolve也就是fn的第一次参数，循环执行所有callback resolve(value) { this.state = \u0026#34;fulfilled\u0026#34;; // setTimeout使内部变成异步，在同步执行完最后执行这里，处理fn是同步的情况下then中的回调函数已经注册，然后在这里去执行，不会出现callbacks是空数组的情况 setTimeout(() =\u0026gt; { this.value = value; this.callbacks.forEach((callback) =\u0026gt; callback(value)); }); } } 使用 new Pro((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(0); resolve(\u0026#34;resolve\u0026#34;); }, 2000); }) .then((tip) =\u0026gt; { console.log(1); console.log(tip); }) .then((tip) =\u0026gt; { console.log(2); console.log(tip); }); promise.all 实现 Promise.prototype.all = function (promises) { let results = []; let promiseCount = 0; let promisesLength = promises.length; return new Promise(function (resolve, reject) { for (let item of promises) { // 执行每个item Promise.resolve(item).then( function (res) { promiseCount++; // 按照顺序插入结果 results[i] = res; // 如果全部执行成功，返回成功 if (promiseCount === promisesLength) { return resolve(results); } }, function (err) { return reject(err); } ); } }); }; promise.race 实现 Promise.prototype.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (let item of promises) { Promise.resolve(item) .then((res) =\u0026gt; { return resolve(res); }) .catch((err) =\u0026gt; { return reject(err); }); } }); }; 简单来说就是声明 promise 时，会执行 promise 第一个函数参数和 then 的参数函数。 then 用来把回调传入 callback 数组中，相当于注册，规定好了 reslove 时，回调的执行，然后等待 resolve 调用，resolve 就会把 callback 数组中的函数全部执行\nthen 中 return this，用于实现 then 的链式调用 如果 promise 是同步的，则执行 resolve 的时候 callback 还没注册 ","permalink":"http://localhost:1313/blogs/promise%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"promise-类\"\u003epromise 类\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePro\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;pending\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003efn\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 初始化，把resolve作为参数传入，等待调用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003efn\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ebind\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// callback为回调，先注册，也就是放入callbacks数组中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;pending\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// 由于state不是pending, 遵循promise状态只能改一次的要求，我们直接操作回调传入参数执行\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// resolve也就是fn的第一次参数，循环执行所有callback\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;fulfilled\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// setTimeout使内部变成异步，在同步执行完最后执行这里，处理fn是同步的情况下then中的回调函数已经注册，然后在这里去执行，不会出现callbacks是空数组的情况\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003esetTimeout\u003c/span\u003e(() =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"使用\"\u003e使用\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePro\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003esetTimeout\u003c/span\u003e(() =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;resolve\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }, \u003cspan style=\"color:#ae81ff\"\u003e2000\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  .\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  })\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  .\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  });\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"promiseall-实现\"\u003epromise.all 实现\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePromise.\u003cspan style=\"color:#a6e22e\"\u003eprototype\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eall\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresults\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromiseCount\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromisesLength\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Promise(\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// 执行每个item\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      Promise.\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003epromiseCount\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 按照顺序插入结果\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#a6e22e\"\u003eresults\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 如果全部执行成功，返回成功\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003epromiseCount\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromisesLength\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eresults\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"promiserace-实现\"\u003epromise.race 实现\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePromise.\u003cspan style=\"color:#a6e22e\"\u003eprototype\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003erace\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Promise((\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Promise.\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        .\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        })\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        .\u003cspan style=\"color:#66d9ef\"\u003ecatch\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e简单来说就是声明 promise 时，会执行 promise 第一个函数参数和 then 的参数函数。\n\u003ccode\u003ethen\u003c/code\u003e 用来把回调传入 callback 数组中，相当于注册，规定好了 reslove 时，回调的执行，然后等待 resolve 调用，resolve 就会把 callback 数组中的函数全部执行\u003c/p\u003e","title":"promise的实现"},{"content":"index.html 部分 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;v\u0026#34; /\u0026gt; {{v}} \u0026lt;button @click=\u0026#34;reset\u0026#34;\u0026gt;重置\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const vm = new Mvvm({ el: \u0026#34;#app\u0026#34;, data: { v: \u0026#34;hello world\u0026#34;, }, methods: { reset() { this.v = \u0026#34;\u0026#34;; }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; index.js 部分 class Mvvm { constructor(options) { const { el, data, methods } = options; this.methods = methods; this.target = null; // 监听this[data的key]所有属性，让变化可追踪 this.observe(this, data); // dom解析：提取{{}}、v-model、事件重写：@click this.compile(document.querySelector(el)); } // 数据变化监听 observe(_this, data) { Object.keys(data).forEach((key) =\u0026gt; { let val = data[key]; Object.keys(data).forEach((key) =\u0026gt; { // 如果val是数组或者对象，使用递归实现深层监听，直到val为简单数据类型。从而保证所有属性变化都被监听 if (typeof val === \u0026#34;object\u0026#34;) { return this.observe(_this, val); } // dispatcher用来操作订阅者(watcher) add 或者 update。要配合Object.defineProperty的get和set来使用 const dispatcher = new Dispatcher(); Object.defineProperty(_this, key, { get: function () { console.log(\u0026#34;get\u0026#34;); // this.target会在compile方法中出现，把this.target(一个watcher)添加到dispatcher(将要更新的watcher的列表)中，用于未来更新这个watcher对应的dom dispatcher.add(this.target); return val; }, set: function (newV) { // 值无变化，不处理 if (newV === val) { return; } console.log(`set`); val = newV; // 因为set了，值发生变化了，所以要通知get中添加的所有订阅者(watcher)：你们要把对应的dom中使用的值更新成newV dispatcher.notify(newV); }, }); }); }); } // dom解析 compile(dom) { const childs = dom.childNodes; for (const node of childs) { // nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp if (node.nodeType === 1) { const attrs = node.attributes; for (const attr of attrs) { if (attr.name === \u0026#34;v-model\u0026#34;) { const name = attr.value; // 放到订阅者列表中 this.target = new Watcher(node, \u0026#34;input\u0026#34;); // this[name]是为了触发observe的get，才会被监听 this[name]; // 由于是demo，假设只有input一种情况，input就会有双向绑定。使用this[name], 并且赋值input的值，来触发observe的get。实现更新信息的发布 node.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { this[name] = e.target.value; }); } // 使用bind传递this。并代理click事件函数到@click上。这里仅拿click事件实现，实际会有多种事件 if (attr.name === \u0026#34;@click\u0026#34;) { const name = attr.value; node.addEventListener(\u0026#34;click\u0026#34;, this.methods[name].bind(this)); } } } // nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp if (node.nodeType === 3) { // 正则匹配{{}} const reg = /\\{\\{(.*)\\}\\}/; const match = node.nodeValue.match(reg); if (match) { const name = match[1].trim(); // 放到订阅者列表中 this.target = new Watcher(node, \u0026#34;text\u0026#34;); // this[name]是为了触发observe的get，才会被监听 this[name]; } } } } } // 发布者 class Dispatcher { constructor() { this.watchers = []; } // 增加订阅者 add(watcher) { this.watchers.push(watcher); } // 通知所有订阅者更新 notify(value) { this.watchers.forEach((item) =\u0026gt; { item.update(value); }); } } // 订阅者 class Watcher { constructor(node, type) { this.node = node; this.type = type; } update(value) { // 区别dom类型来赋值 if (this.type === \u0026#34;input\u0026#34;) { this.node.value = value; } if (this.type === \u0026#34;text\u0026#34;) { this.node.nodeValue = value; } } } 解释 vue 在初始化后，执行 Observe 函数把 data 利用 Object.defineProperty 属性监听。同时也会使用 Compile 函数循环 dom，提取 vue 相关的关键字，v-bind 或者 v-model，找到这些值，新建一个 Watcher 实例，然后手动 get 使这些 watch 放入 dep 列表中等待订阅。等待调用 Observer 的 set (input 事件，或者手动赋值)，然后通知 dep 中所有 Watcher 调用 update 方法。\n","permalink":"http://localhost:1313/blogs/vue%E5%8E%9F%E7%90%86mvvm%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"indexhtml-部分\"\u003eindex.html 部分\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;!DOCTYPE html\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003ehtml\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elang\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;en\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ehead\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003emeta\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echarset\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UTF-8\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003emeta\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;viewport\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econtent\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003etitle\u003c/span\u003e\u0026gt;Document\u0026lt;/\u003cspan style=\"color:#f92672\"\u003etitle\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ehead\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebody\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;app\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003einput\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev-model\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;v\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {{v}}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e@\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eclick\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;reset\u0026#34;\u003c/span\u003e\u0026gt;重置\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;./index.js\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evm\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMvvm\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eel\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;#app\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;hello world\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003ereset\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebody\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ehtml\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"indexjs-部分\"\u003eindex.js 部分\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMvvm\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eoptions\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eel\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e } \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eoptions\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 监听this[data的key]所有属性，让变化可追踪\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobserve\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// dom解析：提取{{}}、v-model、事件重写：@click\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecompile\u003c/span\u003e(document.\u003cspan style=\"color:#a6e22e\"\u003equerySelector\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eel\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 数据变化监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eobserve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003e_this\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object.\u003cspan style=\"color:#a6e22e\"\u003ekeys\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Object.\u003cspan style=\"color:#a6e22e\"\u003ekeys\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 如果val是数组或者对象，使用递归实现深层监听，直到val为简单数据类型。从而保证所有属性变化都被监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003etypeof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;object\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobserve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003e_this\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// dispatcher用来操作订阅者(watcher) add 或者 update。要配合Object.defineProperty的get和set来使用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edispatcher\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDispatcher\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Object.\u003cspan style=\"color:#a6e22e\"\u003edefineProperty\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003e_this\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e, {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e () {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;get\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// this.target会在compile方法中出现，把this.target(一个watcher)添加到dispatcher(将要更新的watcher的列表)中，用于未来更新这个watcher对应的dom\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#a6e22e\"\u003edispatcher\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003eset\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 值无变化，不处理\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e`set`\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 因为set了，值发生变化了，所以要通知get中添加的所有订阅者(watcher)：你们要把对应的dom中使用的值更新成newV\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#a6e22e\"\u003edispatcher\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enotify\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// dom解析\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edom\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echilds\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edom\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003echildNodes\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echilds\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeType\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattrs\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eattributes\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattrs\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;v-model\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 放到订阅者列表中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWatcher\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// this[name]是为了触发observe的get，才会被监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 由于是demo，假设只有input一种情况，input就会有双向绑定。使用this[name], 并且赋值input的值，来触发observe的get。实现更新信息的发布\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddEventListener\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e, (\u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 使用bind传递this。并代理click事件函数到@click上。这里仅拿click事件实现，实际会有多种事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;@click\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddEventListener\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;click\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003ebind\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeType\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 正则匹配{{}}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereg\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e/\\{\\{(.*)\\}\\}/\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeValue\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ereg\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 放到订阅者列表中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWatcher\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// this[name]是为了触发observe的get，才会被监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 发布者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDispatcher\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewatchers\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 增加订阅者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ewatcher\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewatchers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ewatcher\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 通知所有订阅者更新\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003enotify\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewatchers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eupdate\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 订阅者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWatcher\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eupdate\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 区别dom类型来赋值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeValue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解释\"\u003e解释\u003c/h2\u003e\n\u003cp\u003evue 在初始化后，执行 \u003cstrong\u003eObserve\u003c/strong\u003e 函数把 data 利用 \u003cstrong\u003eObject.defineProperty\u003c/strong\u003e 属性监听。同时也会使用 \u003cstrong\u003eCompile\u003c/strong\u003e 函数\u003cstrong\u003e循环 dom\u003c/strong\u003e，提取 vue 相关的关键字，v-bind 或者 v-model，找到这些值，新建一个 \u003cstrong\u003eWatcher\u003c/strong\u003e 实例，然后手动 get 使这些 watch 放入 dep 列表中等待订阅。等待调用 \u003cstrong\u003eObserver\u003c/strong\u003e 的 \u003cstrong\u003eset\u003c/strong\u003e (input 事件，或者手动赋值)，然后通知 dep 中所有 \u003cstrong\u003eWatcher\u003c/strong\u003e 调用 \u003cstrong\u003eupdate\u003c/strong\u003e 方法。\u003c/p\u003e","title":"vue原理mvvm实现"},{"content":"环境 macos 10.14 iterm 2 使用 生成密钥 keytool -genkeypair -alias \u0026lt;别名\u0026gt; -keystore \u0026lt;密钥库存储位置和名称\u0026gt;\nkeytool -genkeypair -alias demokey -keystore demo.keystore 内容填写后，生成完毕\n生成签名 jarsigner -verbose -keystore \u0026lt;使用密钥库位置\u0026gt; -signedjar \u0026lt;签名后的包保存位置和名字\u0026gt; \u0026lt;要签名的包保存位置和名字\u0026gt; \u0026lt;别名，对应上面的别名\u0026gt;\njarsigner -verbose -keystore /Users/liangqi/Desktop/apk/demo.keystore -signedjar ./tap_signed.apk ./tap_unsign.apk demokey 即可拿到签名后的包\n","permalink":"http://localhost:1313/blogs/%E4%BD%BF%E7%94%A8jarsigner%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8Dapk%E5%8C%85/","summary":"\u003ch2 id=\"环境\"\u003e环境\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003emacos 10.14\u003c/li\u003e\n\u003cli\u003eiterm 2\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"使用\"\u003e使用\u003c/h2\u003e\n\u003ch3 id=\"生成密钥\"\u003e生成密钥\u003c/h3\u003e\n\u003cp\u003ekeytool -genkeypair -alias \u0026lt;别名\u0026gt; -keystore \u0026lt;密钥库存储位置和名称\u0026gt;\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekeytool -genkeypair -alias demokey -keystore demo.keystore\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e内容填写后，生成完毕\u003c/p\u003e\n\u003ch3 id=\"生成签名\"\u003e生成签名\u003c/h3\u003e\n\u003cp\u003ejarsigner -verbose -keystore \u0026lt;使用密钥库位置\u0026gt; -signedjar \u0026lt;签名后的包保存位置和名字\u0026gt; \u0026lt;要签名的包保存位置和名字\u0026gt; \u0026lt;别名，对应上面的别名\u0026gt;\u003c/p\u003e","title":"使用jarsigner重新签名apk包"},{"content":"防抖（debounce） 什么是防抖？ 一个函数被触发n秒后，才执行此函数 如果n秒内再次触发此函数，那么重新以再次触发的时间开始重新延迟 n 秒后执行此函数 这样的函数 执行行为 叫做函数防抖。\n应用场景 监听设备窗口大小发生改变，只有停止改变后的200ms执行handleResize方法\nwindow.addEventListener(\u0026#34;resize\u0026#34;, debounce(handleResize, 200)); 监听表单填写，表达内容改变都去请求服务端数据，在每次表单执行输入停止的500ms后，才发起请求\ninput.addEventListener(\u0026#34;change\u0026#34;, debounce(handleRequest, 500)); 代码实现 function debounce(event, delay) { let timer = null; return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理 timer = setTimeout(() =\u0026gt; { event.apply(this, args); }, delay); }; } 节流（throttle） 什么是节流？ 单位时间内多次触发函数，函数只进行一次执行 如果在这个单位时间内，多余的触发，全部不做处理。使函数按照规定的速率执行 这样的函数 执行行为 叫做函数节流。\n应用场景 滚动事件，持续滚动，间隔200ms执行\ndom.addEventListener(\u0026#34;scroll\u0026#34;, throttle(handleScroll, 200)); 鼠标滑动事件，一秒钟大概可以执行60次。使用节流函数优化，200ms执行一次。如果不做节流处理，可想而知浏览器压力有多大\ndom.addEventListener(\u0026#34;mousemove\u0026#34;, throttle(handleMove, 200)); 代码实现 function throttle(fun, delay) { let prev = Date.now(); return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 let now = Date.now(); if (now - prev \u0026gt;= delay) { fun.apply(this, args); prev = Date.now(); } }; } ","permalink":"http://localhost:1313/blogs/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","summary":"\u003ch2 id=\"防抖debounce\"\u003e防抖（debounce）\u003c/h2\u003e\n\u003ch3 id=\"什么是防抖\"\u003e什么是防抖？\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e一个函数被触发\u003ccode\u003en\u003c/code\u003e秒后，才执行此函数\u003c/li\u003e\n\u003cli\u003e如果\u003ccode\u003en\u003c/code\u003e秒内再次触发此函数，那么重新以再次触发的时间开始重新延迟 n 秒后执行此函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样的函数 \u003cstrong\u003e执行行为\u003c/strong\u003e 叫做函数防抖。\u003c/p\u003e","title":"函数的防抖和节流"},{"content":"flex 布局概念 flex布局通常被叫做flex box，也叫弹性盒子或容器，是一种一维的布局模型，它能子元素(flex item)之间提供了强大的空间分布和对齐能力。\nflex容器中存在两个轴，一个水平方向main axis，一个竖直方向cross axis，这是flex布局最重要的点，内部元素flex item都是根据这个轴来排列对齐的。\nflex 布局好处 在一个html元素和内部多个子元的组合中。要实现子元素有序的，高度自定义的布局，在传统布局方式中，会使用position，float方式实现，比如多个子元素在父元素中垂直水平居中，比较困难。这个时候就可以用flex布局，只需要简单几句代码就可以优雅的实现。\nflex 容器属性 设置一个盒子为flex容器，首先设置display: flex;\nflex-direction flex-wrap justify-content align-items align-content flex-direction flex-direction属性规定所有flex item在flex容器从 第一个元素 开始的排列方式\nflex-direction: row(默认) | row-reverse | column | column-reverse; row： 从左往右水平展示\nrow-reverse： 从右向左(反向)水平展示\ncolumn： 从上往下垂直展示\ncolumn-reverse： 从下往上(反向)垂直展示\nflex-wrap flex-wrap属性规定flex容器内所有flex item总宽度超出flex容器时换行方式\nflex-wrap: nowrap(默认) | wrap | wrap-reverse; nowrap： 不换行，只展示一行。如果容器不够宽，平均缩小每个item的宽度\nwrap： 换行，向下换行\nwrap-reverse： 以相反方向换行，向上换行\njustify-content justify-content属性规定所有flex item作为一个整体在flex容器在主轴(默认为水平轴，通过flex-direcation设置)上的排列方式\njustify-content: flex-start(默认值) | flex-end | center | space-between | space-around; flex-start： 整体位于容器开头\nflex-end： 整体位于容器结尾\ncenter： 整体位于容器中心\nspace-between： 每个flex item平均分布在容器内； 第一个item和容器开头，最后一个item和容器结尾都无间距\nspace-around： 每个flex item平均分布在容器内， 第一个item和容器开头，最后一个item和容器结尾的间距都为每个item间距的一半\nalign-items align-items属性规定所有flex item作为一个整体在flex容器在副轴(非主轴，和justify-content相反)上的排列方式\nalign-items: stretch(默认值) | center | flex-start | flex-end | baseline; stretch： 整体占满整个主轴的高度, 前提必须是你没有设置 item 的高度(宽度)，否则不生效\ncenter： 整体位于主轴中心\nflex-start： 整体位于主轴开头\nflex-end： 整体位于主轴结尾\nbaseline： 主轴位于item中第一行文字 基线 对齐\n基线的概念：英文中大概就是一个小写字母 x 的最底部，f 的中下部；而中文大概就汉字中下部，不太准确，我没深入了解，有兴趣可以网上了解。\nalign-content align-content属性规定了多条主轴的情况下(只有item换行了，才会产生多条主轴)，这些主轴作为一个整体在他们的排列方向中的排列方式；注意：只有一条主轴(item不换行)不生效\nalign-content: stretch(默认) | center | flex-start | flex-end | space-between | space-around; stretch： 整体被拉伸以适应容器\ncenter： 整体内各个轴紧靠，并且位于容器中心，头尾留白\nflex-start： 整体内各个轴紧靠，并且位于容器头部\nflex-end： 整体内各个轴紧靠，并且位于容器尾部\nspace-between： 整体平分，其中头尾和容器头尾紧靠，中间间隙平分\nspace-around： 整体平分，其中头尾和容器头尾距离为中间 item 的空隙的一半，中间间隙平分\nflex item 属性 order flex-basis flex-grow flex-shrink align-self order order 属性规定了当前flex item排列前后顺序，越小排列越靠前，可以为负数\norder: 0 (默认值) | \u0026lt;number\u0026gt;; flex-basis flex-basis 属性规定了当前flex item的高度(主轴为水平轴则是高度，如果主轴为竖直轴则是宽度，主轴通过flex-direction设置)的伸缩比例或大小\nflex-basis: auto(默认) | number; number： 可以是具体的像素值，如 30px；也可以是 auto 大小百分比\nflex-grow flex-grow属性 前提在所有项目以flex-basis的值排列完如有剩余空间，则规定当前flex item的高度(主轴为水平轴则是高度，如果主轴为竖直轴则是宽度，主轴通过flex-direction设置)的剩余空间份比例\nflex-grow: 0 (默认值) | \u0026lt;number\u0026gt;; number：当剩余空间足够时，如果值为1那么高度(宽度)放大剩余空间1份，如果只有一个元素设置了此属性，那么剩余全部全部分给他；如果多个元素设置了此属性，比如a:1 b:2 c:3则会把剩余空间分成6份，a 在本身的大小基础上增加剩余空间的1/6份 a 则是2/6份 c 则是3/6份，如果剩余空间不足，则取剩余空间最大值，不支持负数\nflex-shrink flex-shrink属性规定了当剩余空间不足时候，当前flex item的高度(主轴为水平轴则是高度，如果主轴为竖直轴则是宽度，主轴通过flex-direction设置)的缩小超出空间份比例，和上面的flex-grow是相反的，一个放大，一个缩小\nflex-shrink: 1 (默认值) | \u0026lt;number\u0026gt;; number：当剩余空间不足时，默认按照比例 1 缩小，如果值为2那么高度(宽度)缩小超出空间2份\nalign-self flex-shrink属性规定当前flex item作为一个整体在flex容器在副轴(非主轴，和justify-content相反)上的排列方式\n注意：这个属性和align-item的区别是align-item影响全部flex item，而align-self只影响当前flex item\nalign-self: auto(默认值) | stretch | center | flex-start | flex-end | baseline; auto：继承父亲align-item的value\nstretch： 占满整个主轴的高度, 前提必须是你没有设置 item 的高度(宽度)，否则不生效\ncenter： 位于主轴中心\nflex-start： 位于主轴开头\nflex-end： 位于主轴结尾\nbaseline： 位于item中第一行文字 基线 对齐\n扩展一道面试题 实现一个元素包含内部两个元素。当 flex 水平轴为主轴，实现左固定，右自适应：\n\u0026lt;div class=\u0026#34;flex2\u0026#34;\u0026gt; \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; div.flex2 { display: flex; border: 1px solid red; width: 100%; height: 300px; } .flex2 p { width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; font-size: 80px; border: 1px solid blue; } .flex2 p:nth-child(1) { width: 200px; // 左侧元素固定为200px宽 } .flex2 p:nth-child(2) { flex-grow: 1; // 右侧元素自适应 } ","permalink":"http://localhost:1313/blogs/flex%E5%B8%83%E5%B1%80/","summary":"\u003ch2 id=\"flex-布局概念\"\u003eflex 布局概念\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eflex\u003c/code\u003e布局通常被叫做\u003ccode\u003eflex box\u003c/code\u003e，也叫\u003ccode\u003e弹性盒子\u003c/code\u003e或\u003ccode\u003e容器\u003c/code\u003e，是一种一维的\u003ccode\u003e布局模型\u003c/code\u003e，它能子元素(\u003ccode\u003eflex item\u003c/code\u003e)之间提供了强大的空间分布和对齐能力。\u003c/p\u003e","title":"flex布局介绍"},{"content":"什么是函数柯里化 在维基百科中，对函数柯里化有着这样的定义：\n在计算机科学领域，柯里化（Currying）指的是将一个接受多个参数的函数转化为一个仅接受单一参数（即原函数的第一个参数）的函数，并且该函数会返回一个新函数，这个新函数能够接收剩余的参数并最终返回计算结果。\n由此可见，函数柯里化是一种函数变形的思想，它本身并不会直接执行函数，函数柯里化的思想可在多种编程语言中实现，但实现方式因语言而异。上述解释已经十分通俗易懂了。简单来讲，当传入的参数数量不足时，柯里化会借助闭包将当前传入的参数保存起来，然后返回一个新函数。后续这个新函数可以继续被调用以获取更多参数，新传入的参数会与闭包中保存的参数合并。当参数数量达到被柯里化函数的形参数量时，函数就会开始执行；若参数数量仍然不足，则会继续返回新函数来保存参数，如此循环往复。下面以 JavaScript 为例进行说明：\nfunction add(...nums) { return nums.reduce((acc, num) =\u0026gt; acc + num, 0); } // 对该函数进行柯里化处理后，就可以将多个参数拆分成单个或多个参数组合的形式传入，最终得到相同的结果。示例如下： curryingAdd(1)(2)(3)(4); // 结果为 10 // 或者 curryingAdd(1, 2)(3)(4); // 结果为 10 // 又或者 curryingAdd(1)(2, 3, 4); // 结果为 10 柯里化的好处 乍看上述例子，你可能会觉得函数柯里化似乎没什么实际用途，反而让实现过程变得更加复杂。但实际上，它是一种高度抽象的编程规范，属于函数式编程思想的一部分，主要有以下优点：\n参数复用 此外，柯里化还具备“提前确认”和“延迟执行”的特性。“提前确认”强调的是提前固定部分参数，明确函数的部分行为，例如在网络请求中提前确定请求方法；“延迟执行”强调的是函数不会立即执行，而是等所有必要参数都传入后才执行。它们虽然侧重点不同，但都体现了柯里化在灵活控制函数调用上的优势。在我看来，参数复用是函数柯里化最为显著的优势。合理运用这一特性，能够编写出更加优雅的代码，让程序的执行过程更贴合人类解决问题的思维方式。下面通过一段代码来进一步说明：\nfunction ajax(method, url) { // 此处为 HTTP 请求的具体实现代码... console.log(`Sending ${method} request to ${url}`); } function currying(fn, ...args) { if (args.length \u0026gt;= fn.length) { return fn(...args); } else { return (...args2) =\u0026gt; currying(fn, ...args, ...args2); } } // 对 ajax 方法进行柯里化处理 let curryingAjax = currying(ajax); // 得到一个专门用于处理 GET 请求的函数，该操作仅需执行一次 let getAjax = curryingAjax(\u0026#34;get\u0026#34;); // 结合具体业务逻辑，获取用户信息的接口请求 let getUserInfo = getAjax(\u0026#34;http://api.test.com/getUserInfo\u0026#34;); // 结合具体业务逻辑，获取订单列表的接口请求 let getOrderList = getAjax(\u0026#34;http://api.test.com/getOrderList\u0026#34;); // 如果是 post 请求 let postAjax = curryingAjax(\u0026#34;post\u0026#34;); let postData = postAjax(\u0026#34;http://api.test.com/submitData\u0026#34;); 从上述代码可以看出，get 方法仅需传入 curryingAjax 函数一次，后续就可以多次调用 get 请求。先确定请求方法，再确定具体的请求地址，这样就实现了参数的复用。\n柯里化完整代码 柯里化函数 currying 的实现逻辑如下：\n首先判断从 currying 函数的第二个参数开始到最后一个参数（即 args）的长度。若该长度等于被柯里化函数 fn 的形参数量，那么直接执行 fn 函数，并将 args 作为参数传入。 若传入的参数（args）数量不足，就利用递归和闭包的特性，暂时保存已传入的参数，然后重新返回 currying 函数。 function currying(fn, ...args) { if (args.length \u0026gt;= fn.length) { return fn(...args); } else { return (...args2) =\u0026gt; currying(fn, ...args, ...args2); } } // 使用示例 const add = (a, b, c) =\u0026gt; { console.log(a + b + c); }; const currying_add = currying(add); // 不同参数传入方式的结果展示 currying_add(1, 2, 3); currying_add(1)(2, 3); currying_add(1, 2)(3); currying_add(1)(2)(3); ","permalink":"http://localhost:1313/blogs/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","summary":"文章介绍函数柯里化，说明其将多参函数转为单参函数的概念，以 JavaScript 举例阐述原理，讲解参数复用等好处并给出 ajax 请求示例，还提供了完整实现代码及用法","title":"函数柯里化(currying)"},{"content":"冒泡排序（Bubble sort） 原理和演示： 依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。 function bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { if (arr[i] \u0026gt; arr[i + 1]) { let temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } console.log(`执行${i + 1}次`); } return arr; } 通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。\nfunction bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { for (let j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } console.log(`执行${i + 1}次`); } } return arr; } 两个变量互换值可以使用es6的解构语法，省去使用temp缓存，语法为[a, b] = [b, a]，即可交换变量a和变量b的值。复杂数据类型Object和Array都适用；如果第二个循环中的大小判断，一次都没有执行，说明当前这组数据是正序无需排序，用一个变量isOk标记下配合break，实现方法优化。\n完整代码： function bubbleSort(arr) { console.time(\u0026#34;耗时\u0026#34;); for (let i = 0, len = arr.length; i \u0026lt; len - 1; i++) { // 要比对的次数，- 1是因为6个数俩俩比较只需要比对5次 let isOk = true; for (let j = 0; j \u0026lt; arr.length - 1 - i; j++) { // 当前和下一项的每次比较。完整进行一次比较后，最大的值就会在最后一位，- i意味着最大这个值不再需要比对了 if (arr[j] \u0026gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 当前值小于下一项，交换位置 isOk = false; // 如果第一次比较时，没有发现一个有效条件，那么说明整个数组默认就是排好序的 } } if (isOk) { break; } } console.timeEnd(\u0026#34;耗时\u0026#34;); return arr; } 冒泡排序动画演示： 选择排序（Selection Sort） 原理： 循环整个数组，找到最小的值，放在数组第一位(和第一位交换位置）。 从数组第二位开始重新循环，依旧找到最小的值，放在数组第二位，重复此步骤，直到对比完最后一组数据。 完整代码： function selectionSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { // arr.length - 1是因为假定数组中n个数，比较需要两个数，所以只需要比较n-1次 let minIndex = i; // 记录每次循环开始位置，等待和最小值交换位置 for (let j = i + 1; j \u0026lt; arr.length; j++) { // j+1 是避免比较自身，j永远是i的后一项，让他们俩做比较 if (arr[j] \u0026lt; arr[minIndex]) { // 如果后面的值小于前面的值，需要调换他们俩位置 minIndex = j; // 保存最小值的下标 } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // 使用es6的结构语法交换值，把最小值放到数组最前面 } return arr; } 选择排序动画演示： 插入排序（Insertion Sort） 原理： 将数组分成两部分，一部分为已排序(默认为数组第一个元素且只有这一个元素)，另一部分为未排序。 依次从未排序数组中取值，和已排序中的值依次做对比，如果未排序元素比已排序元素中某个元素小，那就将已排序元素向后移一位，使他本来位置变成一个空位，再将待排序数据插入空位。 完整代码： function insertionSort(arr) { let len = arr.length; for (let i = 1; i \u0026lt; len; i++) { // 循环未排序部分, i=1而不是0是因为默认0项为已排序部分 let cur = i; // 每次插入后，arr[i]会发生改变，先存下来 let j = i - 1; while (j \u0026gt;= 0) { // 循环已排序部分，默认数组第一项有且只有第一项，下标范围为(0 - (未排序元素下标-1))，也就是例子中的i-1 if (arr[cur] \u0026lt; arr[j]) { // 如果未排序元素比已排序元素小， [arr[cur], arr[j]] = [arr[j], arr[cur]]; // 交换 cur = j; // 交换后i值变了，那把交换后的i找回来就可以了 } j--; } } return arr; } 插入排序动画演示： 快速排序（Quick Sort） 原理： 选择数组中的一个元素作为基准值，用两个新数组分别存储原数组比基准值大的值，和小的值。 继续递归处理这两个新数组，最终用 concat 合并到一起，效果为：比基准值小的数组+基准值+比基准值小的数组。 快速排序有其它种实现方法，这是一种简单的实现，非原地排序，由于新建了多个新的数组，会增加空间复杂度，好处再于非常容易理解，可读性强，适合面试手写代码。\n完整代码： function quickSort(arr) { if (arr.length \u0026lt;= 1) { return arr; } // 递归边界条件 let pointIdx = Math.floor(arr.length / 2); // 在数组中间位置取一个基准点 let point = arr.splice(pointIdx, 1)[0]; // 通过基准点找到这个值，使用splice原因是：要获取这个基准值的同时要把这个基准值从排序数组里删除掉 let left = []; let right = []; for (let i = 0, len = arr.length; i \u0026lt; len; i++) { if (arr[i] \u0026lt; point) { // 循环数组，小于point的放在left中，大的放在right中 left.push(arr[i]); } else { right.push(arr[i]); } } // 递归，让每一个left和right继续排序，直到left或right只有一项为止 return quickSort(left).concat(point, quickSort(right)); } 快速排序动画演示： 另外说一下，js 的原生提供的 sort 排序方法原理：如果数组长度小于10，使用插入排序，否则使用快速排序。如其名，快速排序的性能还是很好的。\n动画来源：菜鸟教程\n查看例子：GitHub\n","permalink":"http://localhost:1313/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/","summary":"\u003ch2 id=\"冒泡排序bubble-sort\"\u003e冒泡排序（Bubble sort）\u003c/h2\u003e\n\u003ch3 id=\"原理和演示\"\u003e原理和演示：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e依次比较数组中相邻的每一对值，如果前面的值 \u003cstrong\u003e大于\u003c/strong\u003e 后面的值，则交换他们俩的位置。如果数组中\u003ccode\u003e5\u003c/code\u003e个数字(length 为 5)，由于比较 \u003cstrong\u003e两个一组\u003c/strong\u003e 的数字，那么只需要\u003ccode\u003e4次\u003c/code\u003e(length - 1)比较，就可以实现把数组中最大的一个数放到最后。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebubbleSort\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etemp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etemp\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e`执行\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e次`\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，\u003ccode\u003ej\u003c/code\u003e对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数\u003ccode\u003e- 1\u003c/code\u003e也就是下面例子中的\u003ccode\u003e- j\u003c/code\u003e。\u003c/p\u003e","title":"常用4种排序介绍"},{"content":"html \u0026lt;div class=\u0026#34;round\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; css 使用background-image渐变属性和动画状态的伪元素遮盖来实现：\n.round { width: 150px; height: 150px; border-radius: 50%; background-color: #eee; background-image: linear-gradient(to right, transparent 50%, blue 0); position: relative; } .round::before { width: 50%; height: 100%; content: \u0026#34;\u0026#34;; position: absolute; top: 0; left: 50%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; animation: spin 5s linear infinite, dye 10s step-end infinite; } @keyframes spin { to { transform: rotate(0.5turn); } } @keyframes dye { 50% { background: blue; } }s 效果 ","permalink":"http://localhost:1313/blogs/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/","summary":"\u003ch3 id=\"html\"\u003ehtml\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;round\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"css\"\u003ecss\u003c/h3\u003e\n\u003cp\u003e使用\u003ccode\u003ebackground-image\u003c/code\u003e渐变属性和动画状态的\u003ccode\u003e伪元素遮盖\u003c/code\u003e来实现：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.\u003cspan style=\"color:#a6e22e\"\u003eround\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewidth\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e150\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003epx\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eheight\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e150\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003epx\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eborder-radius\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ebackground-color\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e#eee\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ebackground-image\u003c/span\u003e: linear-gradient(\u003cspan style=\"color:#66d9ef\"\u003eto\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003etransparent\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eblue\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eposition\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003erelative\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.\u003cspan style=\"color:#a6e22e\"\u003eround\u003c/span\u003e::\u003cspan style=\"color:#a6e22e\"\u003ebefore\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewidth\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eheight\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econtent\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eposition\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eabsolute\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003etop\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eborder-radius\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ebackground-color\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003einherit\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003etransform-origin\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eanimation\u003c/span\u003e: spin \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003es\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elinear\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einfinite\u003c/span\u003e, dye \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003es\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estep-end\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einfinite\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e@\u003cspan style=\"color:#66d9ef\"\u003ekeyframes\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003espin\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003eto\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003etransform\u003c/span\u003e: rotate(\u003cspan style=\"color:#ae81ff\"\u003e0.5\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eturn\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e@\u003cspan style=\"color:#66d9ef\"\u003ekeyframes\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003edye\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ebackground\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eblue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\u003cspan style=\"color:#f92672\"\u003es\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"效果\"\u003e效果\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"demo.gif\" loading=\"lazy\" src=\"/images/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/E8CM6WZ1hRv7piy.gif\"\u003e\u003c/p\u003e","title":"使用css实现环状进度"},{"content":" 什么是 swap swap分区是Linux中特殊的一种存储，他在安装系统时被自动创建。\n用于当内存不够时，操作系统会取出内存中不活跃或不常用的一部分放到swap分区中，使内存空闲出一部分空间用于执行其他程序。相当于临时充当一部分内存，当操作系统想要访问swap空间上的的数据时，swap会把数据放回内存中供操作系统使用。\n类似windows中的虚拟内存。每个操作系统都有这种内存调度处理，当内存不够用，还想跑点东西，可以临时选择增加swap空间。以达到实际使用内存超过物理内存。由于swap的读取速度远不如内存，最好的办法还是加物理内存。\nswap 分区类型 swap 文件 swap 分区 速度比较：物理内存 \u0026gt; swap 分区 \u0026gt; swap 文件。\n由于swap分区需要一个新的磁盘，当你的磁盘已经装了不少内容，不方便重新规划的话，也只好使用 swap 文件了。本文使用 swap 文件方式。\n查看 swap 信息 基于 Cent OS 7.6\n使用swapon -s命令查看系统中当前swap信息：\nswapon -s Filename Type Size Used Priority /swapfile file 1048572 199668 -2 Filename：swap 分区/文件所在的位置 Type：swap 类型；partition为分区类型，file为文件类型 Size：总容量，单位是 KB Used：已被使用的容量 Priority：优先级，越高越优先被操作系统使用 若查不到 swap 信息，使用free -h命令，查看内存使用情况：\nfree -h total used free shared buff/cache available Mem: 487M 65M 289M 44K 132M 398M Swap: 1.0G 259M 764M 操作 swap 创建swap文件， fallocate命令可以为文件预分配物理空间，和 touch、vim 的区别就是可瞬间创建超大的文件。快速创建的原因是通过分配块并将它们标记为未初始化，无需对数据块进行 IO，可以快速完成预分配。当使用时再使用物理内存。-l后加大小，可以是 k、m、g。再后面是保存位置和名称。\n# 创建一个1g文件swapfile保存到/ sudo fallocate -l 1G /swapfile 修改权限，仅允许文件所有者进行读写操作：\nsudo chmod 600 /swapfile 将这个文件设为 Linux 交换区：\nsudo mkswap /swapfile 激活交换区：\nsudo swapon /swapfile 修改/etc/fstab，实现系统重启自动加载 swap 文件：\necho \u0026#39;/swapfile none swap sw 0 0\u0026#39; | sudo tee -a /etc/fstab 至此完成 swap 文件增加。使用free -h查看 swap 使用情况：\nfree -h total used free shared buff/cache available Mem: 487M 65M 289M 44K 132M 398M Swap: 1.0G 259M 764M 停止所有 swap：\nsudo swapoff -a # 查看内存使用情况，可以看到 Swap 信息都变成0，说明操作成功了 free -h total used free shared buff/cache available Mem: 487M 261M 92M 484K 134M 201M Swap: 0 0 0 ","permalink":"http://localhost:1313/blogs/linux%E4%B8%AD%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4swap%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","summary":"\u003chr\u003e\n\u003ch2 id=\"什么是-swap\"\u003e什么是 swap\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eswap\u003c/code\u003e分区是\u003ccode\u003eLinux\u003c/code\u003e中特殊的一种存储，他在安装系统时被自动创建。\u003c/p\u003e\n\u003cp\u003e用于当内存不够时，操作系统会取出内存中不活跃或不常用的一部分放到\u003ccode\u003eswap\u003c/code\u003e分区中，使内存空闲出一部分空间用于执行其他程序。相当于临时充当一部分内存，当操作系统想要访问\u003ccode\u003eswap\u003c/code\u003e空间上的的数据时，\u003ccode\u003eswap\u003c/code\u003e会把数据放回内存中供操作系统使用。\u003c/p\u003e","title":"Linux中内存交换空间(swap)的使用"},{"content":"","permalink":"http://localhost:1313/photos/","summary":"","title":"照片"},{"content":" Colora - Chrome 扩展 关灯 - Chrome 扩展 OhMyCookie - Chrome 扩展 OhMyBox - Npm 包 Colora Colora 是⼀款基于 Chrome 的扩展程序，它⾮常的轻量级、纯粹并且免费的截图美化⼯具，不滥⽤权限、使⽤最原始、恰到好处的技术实现，并且没有任何⼴告。核⼼逻辑只有不到 5 KB，Chrome 扩展商店搜索「Colora」\n⽆需繁琐⽆聊的设计技巧。只需⼀次点击，就可以获得精美绝伦、惊⼈震撼的图⽚，让图⽚编辑变得更有趣，那就是 Colora，快来享受它吧！\n在 Chrome 扩展商店查看 「Colora」\n关灯 Chrome 扩展程序，暗黑模式一键切换。\n特性 ❇️ 极致小巧，核心代码实现只有不到 3KB\n❇️ 新拟物化 UI 设计，尽显优雅格调\n❇️ 纯粹至极，仅专注于实现必要功能，依赖精简，技术运用恰到好处\n❇️ 安全并且谨慎，仅获取读取 TAB 页面信息权限，用于注入样式。绝不触及任何其他权限与信息\n❇️ 永久免费，这是一个开源项目，随时可以查看最新的源代码\n关于「关灯」的更多\n开源仓库地址\n在 Chrome 扩展商店查看 「关灯」\nOhMyCookie ⽤来扩展 Chrome 浏览器中 Cookie，Local、SessionStorage 的增删改查、导出操作。Chrome 扩展商店搜 「ohmycookie」\n基于开源脚⼿架⼯具 vtemp-chrome-extension， 来实现使⽤ Vue 开发 可编辑 Cookie 8 种属性，并⽀持以 JSON 导出 本⻚⾯全部 Cookie 开源仓库地址\n在 Chrome 扩展商店查看 「OhMyCookie」\nOhMyBox 基于 vue 的移动端滑动组件，类似抖⾳⾸⻚滑屏效果。npm 商店搜「ohmybox」\n内部单元组件使⽤ Slot 插槽，可⾼度⾃定义内容 ⽀持 六种参数 和 两种事件 设置：翻⻚⾼度，持续滚动时⻓，快速翻⻚⾼度、模拟点击 ⽅法等 开源仓库地址\n在 npm 商店查看 「OhMyBox」\n","permalink":"http://localhost:1313/apps/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#colora\"\u003eColora - Chrome 扩展\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%85%B3%E7%81%AF\"\u003e关灯 - Chrome 扩展\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ohmycookie\"\u003eOhMyCookie - Chrome 扩展\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ohmybox\"\u003eOhMyBox - Npm 包\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"colora\"\u003eColora\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eColora 是⼀款基于 Chrome 的扩展程序，它⾮常的轻量级、纯粹并且免费的截图美化⼯具，不滥⽤权限、使⽤最原始、恰到好处的技术实现，并且没有任何⼴告。核⼼逻辑只有不到 5 KB，Chrome 扩展商店搜索「Colora」\u003c/p\u003e","title":"我的应用"},{"content":"如果有一个布尔变量，来控制某个按钮的显示隐藏，就有两种命名方法：\nshow = 布尔值 hide = 布尔值 当使用 show 变量时，好像，代码的逻辑更像是在问 “是否要显示按钮？” 如果答案是肯定的（true），就显示按钮；如果是否定的（false），就隐藏按钮。这种逻辑符合人们日常对于 “展示” 事物的思考方式。\n而 hide 就正好相反，是反直觉的，也许是更强调隐藏这个角度？也许是一种补充的、不是必须的配置，默认是显示的，你将更改默认配置，hide 突出对特殊状态（隐藏状态）的关注，在一些需要重点强调隐藏条件的业务逻辑中，能够使代码的意图更加明确。\n如果业务逻辑侧重于正常情况下元素的展示，强调正向判断流程，“show” 变量无疑是更优选择；而当特殊的隐藏条件较为突出，需要着重关注隐藏状态的设置时，“hide” 变量或许能更好地体现代码意图。但无论选择哪种方式，保持项目内代码风格的统一和清晰的代码注释，都是确保代码质量和可维护性的关键。\n","permalink":"http://localhost:1313/blogs/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%91%BD%E5%90%8D/","summary":"\u003cp\u003e如果有一个布尔变量，来控制某个按钮的显示隐藏，就有两种命名方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eshow = 布尔值\u003c/li\u003e\n\u003cli\u003ehide = 布尔值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当使用 show 变量时，好像，代码的逻辑更像是在问 “是否要显示按钮？” 如果答案是肯定的（true），就显示按钮；如果是否定的（false），就隐藏按钮。这种逻辑符合人们日常对于 “展示” 事物的思考方式。\u003c/p\u003e","title":"有意思的命名"},{"content":" 离散数学中命题逻辑的真值表如下：\nP Q P ∧ Q P ∨ Q ¬ P P → Q P ↔ Q T T T T F T T T F F T F F F F T F T T T F F F F F T T T 下面对各逻辑运算符进行解释：\nP ∧ Q（合取）：仅当 P 和 Q 同时为真时，其结果才为真，否则为假。 P ∨ Q（析取）：只要 P 或者 Q（或者两者同时）为真，结果即为真，否则为假。 ¬ P（否定）：若 P 为假，结果为真；若 P 为真，结果为假。 P → Q（蕴含）：只有在 P 为真且 Q 也为真的情况下，结果才为真（否则为假），常被读作“若 P，则 Q” 。 P ↔ Q（等价）：当且仅当 P 和 Q 的真值一致时，结果为真，否则为假。 以下通过具体例子来进一步说明 合取 假设有两个命题 P 和 Q：\nP：今天天气晴朗。 Q：学校举行户外运动会。 逻辑与运算“P ∧ Q”代表“今天天气晴朗并且学校举行户外运动会”。只有当 P 和 Q 均为真时，整个表达式才是真的。\n析取 依旧使用上述命题 P 和 Q。 逻辑或运算“P ∨ Q”表示“今天天气晴朗或者学校举行户外运动会”。只要 P 或者 Q（或者二者同时）为真，整个表达式就为真。\n否定 使用命题 P：\nP：今天天气晴朗。 逻辑非运算“¬P”即“今天天气不晴朗”。当 P 为真时，¬P 为假；当 P 为假时，¬P 为真。\n蕴含 例子 1：假设有两个命题 P 和 R：\nP：你完成了作业。 R：你可以出去玩。 逻辑蕴含运算“P → R”表示“如果你完成了作业，那么你可以出去玩”。这里，P 是前提（前件），R 是结论（后件）。当 P 为真而 R 为假时，整个表达式为假；在其他情形下（即 P 为真 R 也为真，或者 P 为假时），整个表达式为真。需要注意的是，逻辑蕴含并不等同于因果关系，它仅仅关注真值之间的关联。在实际生活中，我们会说“如果完成了作业（P），那么就可以出去玩（R）”，但这并不表明完成作业是能够出去玩的唯一原因或者必要条件。\n为了更好理解蕴含，再举一个例子： 例子 2：假设有两个命题 P 和 R：\nP：我当选美国总统。 R：我就给你涨工资。 对于蕴含式 P → R ：\n为真的情况：我当选了美国总统，并且我给你涨了工资，此时蕴含式结果为真 。 为假的情况： 我没有当选美国总统，那么无论我是否给你涨工资，整个蕴含式都为假 。 我当选了美国总统，但我没有给你涨工资，此时蕴含式结果为假。 等价 使用命题 P 和另一个命题 S：\nP：你完成了作业。 S：你的作业已经提交。 逻辑等价运算“P ↔ S”表示“你完成了作业当且仅当你的作业已经提交”。当 P 和 S 的真值相同（即都为真或者都为假）时，整个表达式为真；否则为假。这意味着 P 和 S 在逻辑层面是等价的，它们的真假情况必然一致。\n","permalink":"http://localhost:1313/blogs/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8/","summary":"这篇文章先给出离散数学中命题逻辑真值表，介绍了合取、析取、否定、蕴含、等价运算规则及结果，后分别以具体生活实例对每种运算进行详细说明，并特别指出蕴含运算中逻辑关系与因果关系的区别","title":"命题逻辑真值表"},{"content":" 为什么要写这篇博客 最近在和同事午饭的时候聊到这个问题。想到了刚接触编程时粗略了解过，但是又没办法讲清楚，所以决定利用这篇博客复习一下。也希望给相关的二进制存储的疑问画上一个句号。\n先来了解存储数字的标准 计算机是二进制的。浮点数是没有办法用二进制进行精确表示。我们的 CPU 表示浮点数由两个部分组成：指数 和 尾数，这样的表示方法一般会失去一定的精确度，有些浮点数运算也会产生一定的误差，是实数的无限精度跟计算机的有限内存之间的矛盾，通用语言中的浮点数都是按照 二进位浮点数算术标准 (IEEE 754)标准存储。\n一般语言把数字区分整数型和小数型以不同标准存储，但是 js 比较特殊，在 js 中，不管是整数还是小数都是以 IEEE 754 标准中的 双精度浮点法 (Double 64)存储的。整数 1 被当成 1.0 存储。\n那什么是双精度浮点法 ? 先来介绍一下 双精度浮点法，比起 单精度浮点法，双精度浮点法 使用 64 位二进制来储存一个浮点数。它可以表示二进位制的 53 位有效数字，其可以表示的数字的范围为\n$$ [-(2^{53}), 2^{53} - 1] $$\n结构包含 64 位二进制位，分别是符号位，指数位，尾数位。\nsign bit（符号）：用来表示数值正负，0 代表数值为正，1 代表数值为负。占位 1 比特。 exponent（指数）：用来表示次方数，占位越多，可以表示数字的范围越大。可以理解成它表示 小数点 在数字的什么位置上，这也是小数在计算机中被叫做浮点数的原因。占位 11 比特。 mantissa（尾数）：用来表示精确度，可以理解成占位越多，那么保存小数点后更多的位数。占位 52 比特。 二进制转换 那么把一个数字存入到内存中是如何实现的呢？首先先把数字转换计算机可识别二进制格式再通过 双精度浮点法 存储，这里区分两种情况：整数和小数(整数部分和小数部分)\n整数：整数除以 2，记录结果和余数。然后用上次结果继续除以 2，再次记录商和余数。重复这个步骤，直到商为 0 为止。那么所得余数从后往前排列就是这个整数的二进制。\n小数：小数位乘以 2，记录结果，区分整数位和小数位，然后继续用小数位乘以 2，再次记录结果。重复这个步骤，直到小数位为 0 为止，那么其中得到的整数结果从前往后排列就是小数的二进制。\n整数 8 转换二进制过程 8 / 2 = 4 // 余数 0 4 / 2 = 2 // 余数 0 2 / 2 = 1 // 余数 0 1 / 2 = 0 // 余数 1 然后把倒过来把余数排列，1000 就是 8 的二进制结果。\n小数 0.25 转换二进制过程 0.25 * 2 = 0.5 // 整数位：0 小数位：0.5 0.5 * 2 = 1 // 整数位：1 小数位：0 整数位结果从前往后取出得到 01 就是 0.25 的二进制结果。\n8.25 的二进制过程 实际拆解成整数位 8 和小数 0.25，分别按照对应的方法去转换，8 的二进制就是 1000，0.25 的二进制是 01，加个小数点合并到一起就是 1000.01，所以 8.25 的二进制为 1000.01。\n以双精度浮点法存储到内存 按照上述步骤，8.25 转换二进制得到 1000.01，那么 1000.01 是如何以双精度浮点法存储的呢，第一步先用二进制科学记数法表示，得到 1.00001 * 2^3，然后我们把它拆分下，分别存入符号位，指数位，尾数位。\n符号位存入 0，因为 1000.01 是正数 指数位存入 1026 的二进制 10000000010，指数应该是 3，为什么存入 1026 ? 参考下面标题为 为什么指数位要设置偏移量 ? 尾数位存入 00001，把 1.0001 小数点前的 1 省略，因为转换为二进制位后，只可能是 0 和 1，再进行二进制科学记数法，第一位一定大于 0，所以又排除了 0，所以小数点前的数只能是 1，就可以省略掉 至此使用双精度浮点法 8.25 存储的结果为： 为什么指数位要设置偏移量 ? 这里需要解释下，按照上面的例子，指数应该是 3，为什么存入 1026 ?\n是因为指数位有 11 位，可以表示 0 ~ 2^11，也就是 0 ~ 2048， 因为指数可能 正 或 负 的，这种情况下计算机不仅仅要识别指数有多大，还需要识别是正是否，无疑增加了复杂度。\n为了简化这个问题，指数位只存储无符号整数，所以使用了偏移量的概念，因为指数有正负， 0 ~ 2048 没办法表示负数，就把 0 ~ 2048 从中一刀切开，范围变成 -1024 到 +1024， 对了，其中还包括 0 ，就是 -1024 到 +1023 。存储的时候让原本的指数不管正负都加上1024 的偏移量，可以保证，存储的都是整数，当二进制转回十进制的时候，再减去 1024 就可以了，那 1024 + 3 应该是 1027 啊，为什么实际用了 1026 呢，因为人们为了特殊用处，不允许使用 0 和 1023 这两个数字表示指数，因为这两个极值，来表示一些特别的含义，比如 NaN，Infinity，0 等。这样的话少了 2 个数字，偏移量的设置自然就只好采用最大值 1023 了。因为-1023 + 1023 = 0，最小的指数为0，所以指数位 3 + 1023 为 1026 。这就是移码的概念。IEEE 754 的指数位采用移码来表示，为了实现表示的范围都是正数，而小数部分用原码来表示。\n从内存中如何取出使用呢？ 按照 双精度浮点法 存入内存的数字如何拿出来使用呢？先看转换公式：\n$$ (-1)^{sign} \\times 2^{exponent} \\times (1 + mantissa) $$\n还是用 8.25 举例，符号位为 0，指数位为 1026 - 1023 (偏移量) = 3，尾数为 00001，可得：\n$$ (-1)^{0} \\times 2^{3} \\times (1 + 0.00001) = 1 \\times 1000.01 $$\n把二进制结果 1000.01 转换为十进制，先把小数位按照第 1 位的值*2^(-1)，第 2 位的值*2^(-2)，第 3 位的值*2^(-3) …到最后一项 第 n 位的值*2^(-n)，然后把最后结果相加，因为 1000.01 只有两位小数位 .01，按照下面方法计算可得 0.25：\n$$ 0 \\times 2^{-1} + 1 \\times 2^{-2} = 0.25 $$\n整数位 1000 转十进制，和小数位计算方式一样，只是指数从负数换成整数就好了，最终结果是 8，把 小数位 和 **整数位 **结果加到一起就是最终结果了 8.25 了\n$$ 0 \\times 2^{1} + 0 \\times 2^{2} + 0 \\times 2^{3} + 1 \\times 2^{4} = 8 $$\n总结 js 中数字存入内存的步骤：\n分别把整数位、小数位转二进制 使用二进制科学计数法表示 按照双精度浮点法存入符号位、指数位、尾数位 数字从内存中步骤：\n按照公式，替换符号、指数、尾数 得到的结果转十进制 扩展为什么 0.1 + 0.2 !== 0.3 从上文我们知道了一个数是如何存储的，那我们按照上面的方式模拟一下 0.1 + 0.2 的过程：\n0.1 转换为二进制为 0.0001100110011(0011 循环)，因为尾数只能存储 52 位，没办法，就把 52 位以后截取掉了，实际存入结果为：\n0.2 同理，也是循环二进制，存储结果为：\n按照上面的方法分别转回十进制可得：\n0.1 为 0.100000001490116119384765625\n0.2 为 0.20000000298023223876953125\n相加结果为 0.30000000447034836，原因就是在二进制中都只能精准表示 2 除尽的数字 1/2, 1/4, 1/8，当无法精准表示时，会舍弃存储。就好比，十进制的世界中，1/3，是 0.33333\u0026hellip; 是无限循环的，如果人的理解也像计算机一样，是按照固定长度去表示的话，那是无法精准表示的一样。\n","permalink":"http://localhost:1313/blogs/js%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E5%AD%97%E7%9A%84/","summary":"\u003chr\u003e\n\u003ch2 id=\"为什么要写这篇博客\"\u003e为什么要写这篇博客\u003c/h2\u003e\n\u003cp\u003e最近在和同事午饭的时候聊到这个问题。想到了刚接触编程时粗略了解过，但是又没办法讲清楚，所以决定利用这篇博客复习一下。也希望给相关的二进制存储的疑问画上一个句号。\u003c/p\u003e","title":"js是如何存储数字的"},{"content":"为什么要总结这个问题 这几天和我的同事聊到这个问题，他提出了一些深入的问题，想了想，我也有相同的疑问。真是验证了那句话，了解的越多就发现自己了解的越少！so 被迫研究了下这个问题总结起来。便于以后查看和补充。\n单线程和事件循环 因为多线程会产生共享资源，修改彼此，等复杂问题。并且早期 js 只是来显示简单页面的，但今非昔比，或许 js 作者可能都没想到现在的 js 发展的如此迅猛！所以单线程更适合 js ，一直延续至今。那问题来了，只有单线程是如何处理耗时任务且实现不阻塞的呢，这里就用到了事件循环。事件循环(event loop)是一种计算机系统运行机制。作为单线程的 js 来说，事件循环是来解决当执行耗时任务时不阻塞主线程的调度机制。来自维基百科的解释\n事件循环工作流程 以当前最新版 chrome_v98.0 浏览器为准\njs 中的任务可分为\n同步任务 异步任务 打开一个 tab 页面，浏览器会新开辟一个进程。包含执行栈( js 主执行线程)和一些其他线程(属于浏览器)。当一个包含 css， js 的 html 页面被加载时，会从上往下，从左到右按顺序解析。当遇到同步任务时，它的执行上下文会被放入执行栈，执行完毕后，出栈。下一个放入，依次执行。\n当遇到耗时(异步)任务，会根据不同的任务类型，提供给专门的线程来处理，举出一些例子，不限于这些：\nsetInterval / setTimeout\u0026hellip; ⇒ timer 线程 网络请求 ⇒ 网络请求线程 dom 绘制渲染 ⇒gui 线程 dom 元素的事件监听 ⇒ 事件线程 等到这些异步任务应该被执行时，比如用户点击按钮、网络请求、延时器时间到了等，会把相应的回调函数放入异步队列中，按先后顺序排列起来待命。\n直到执行栈的所有同步任务执行完毕后，同步栈会从异步队列中第一位开始取出入栈，依次执行。如果每个异步队列中的任务被执行的过程中，再次产生异步任务，会被放到任务队列的最后，等待执行。\n有一些问题 这些专门线程处理一些任务时候，拿到结果后，都按照先后顺序放入队列被执行，没有办法控制任务优先级，希望一些任务不在队列最末尾排队，而是直接插队执行。为了解决这个问题，在异步任务队列中再细分成两种类型，微任务和宏任务，微任务可以理解是插队的任务，优先级更高。根据类型的不同会被放入不同的队列：\n微任务队列 : promise、 queueMicroTask、 mutationObserver 宏任务队列 : setTimeout、 setInterval、 requestAnimationFrame等 按照先微再宏的顺序执行：每一个宏任务开始前，都先要把上一个宏任务产生的微任务执行完毕再开始新的宏任务，微任务是宏任务的一部分，换句话来说，就是当执行栈空了之后，先检查微任务队列，再检查宏任务队列。\n总结 更通熟易懂事件循环动画参考 B 站\n存在的疑问 在分配宏/微任务时有总的调度系统分配？还是一句代码执行过程中有一次机会，让每个线程依次检查一下，把自己任务拿走 每个宏任务都有属于自己的微任务队列，还是一共只有一条微任务队列？ 回答：node 端的执行规律是一个宏任务队列搭配一个微任务队列，而浏览器是一个单独的宏任务搭配一个微任务队列。但是在 node11 之后，node 和浏览器的规律趋同。 如何区分微任务和宏任务的呢，具体是通过哪些特征分类的？ 最后整一道经典面试题 基于 chrome_v98.0 浏览器环境\nasync function async1() { console.log(\u0026#34;async1 start\u0026#34;); await async2(); console.log(\u0026#34;async1 end\u0026#34;); } async function async2() { console.log(\u0026#34;async2\u0026#34;); } console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); async1(); new Promise(function (resolve) { console.log(\u0026#34;promise1\u0026#34;); resolve(); }).then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); 解析：按照从上往下顺序先执行同步代码，前两个函数async和async2是函数声明，忽略。然后第 1 个输出的是script start，然后看到setTimeout, 由于它是异步且属于宏任务，放到最后执行。然后看到 async1 函数被执行了，进入async1函数体。\n第 2 个输出的是async1 start, 看到 await 规则是：await 右的语句被同步执行，所以第 3 个输出的是async2，await 下的语句(函数体内)被当作 async 函数返回一个 promsise 的回调函数体的语句去处理，且被放入了异步任务队列中，等待中。\n然后跳出 async1 函数体，继续执行同步代码，遇到 new Promise，第 4 次输出promise，看到 resolve，就把 then 中回调，放入任务队列中，然后继续向下执行同步代码，第 5 次输出的最后的script end。\n至此同步执行栈空了，开始把任务队列中的上下文拿到执行栈执行，由于队列先进先出，所以第一个被入栈的是 async1 的回调，也就是第 6 次输出的是async1 end，然后把第二个队列中的上下文放入执行栈，也就是 promise 的 resolve，所以第 7 次输出promise2，至此微任务执行完成，现在执行宏任务，也就是 timeout，所以第 8 次输出为setTimeout。\n最终结果\nscript start async1 start async2 promise1 script end async1 end promise2 setTimeout ","permalink":"http://localhost:1313/blogs/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","summary":"\u003ch2 id=\"为什么要总结这个问题\"\u003e为什么要总结这个问题\u003c/h2\u003e\n\u003cp\u003e这几天和我的同事聊到这个问题，他提出了一些深入的问题，想了想，我也有相同的疑问。真是验证了那句话，了解的越多就发现自己了解的越少！so 被迫研究了下这个问题总结起来。便于以后查看和补充。\u003c/p\u003e","title":"浏览器事件循环"},{"content":"为什么要写这篇博客 一个是感觉自己的计算机网络基础薄弱，关于七层模型和 tcp、udp 看过几次了，都不够透彻，知其然不知其所以然。再一个，最近和同事有聊到这个事，感觉自己也说不明白，又意识到很重要，所以决定整理一下，自己感觉自己会了和可以给别人讲明白这个事儿，区别还是很大的啊。就参考资料和自己理解记录一下。\n先说什么是网络协议 两台设备进行网络通信时，双方要提前约定一些规则。这样才可以让对方设备理解你要做什么。比如，如何发起通信，如何发出/接收数据，如何关闭链接。\n再说 OSI 7 层模型 和 TCP/IP 4 层模型 OSI(Open System Interconnection) 开放式系统互联参考模型，为了统一处理，模块化，易于维护，OSI 采用分层结构。包含七层，每一层实现各自的功能和协议，通过接口提供给更高一层并完成与相邻层的接口通信。\nIOS 7 层模型是一种网络通信理论模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，设备就能互联了。OSI 参考模型是学术上和法律上的国际标准，是完整的权威的网络参考模型。\n关系如下：\nOSI 7 层模型 功能 传送介质 对应 TCP/IP 4 层模型 对应协议 应用层 Application 为应用进程提供网络服务。 报文 应用层 HTTP、FTP、SMTP 表示层 Presentation 数据格式化，加密和解密。 报文 应用层 Telnet、Rlogin、SNMP、Gopher 会话层 Session 建立应用和应用之间的连接。 报文 应用层 SMTP、DNS 传输层 Transport 建立设备和设备之间的连接。 报文 传输层 TCP、UDP 网络层 Network 为数据包选择路由，寻址。 数据包 网络层 IP、ICMP、ARP、RARP、AKP、UUCP 数据链路层 Data Link 根据以太网协议将一组电信号组成一个数据包，称作”帧”，控制传输。通俗说，就是控制数据在网线、光纤传输。 数据帧 链路层 FDDI、Ethernet、Arpanet、PDN、SLIP、PPP 物理层 Physical 把网线，光纤将设备链接起来组网。物理传输介质。 比特流 链路层 IEEE 802.1A、IEEE 802.2 到 IEEE 802.11 TCP/IP 4 层模型 (协议簇) TCP/IP 协议簇是 internet 的基础，是多个协议的统称，命名为 TCP/IP 是因为TCP和IP是其中很重要的两个协议。\nTCP/IP 分为四层，每一个层都有各自的协议和功能，其中 TCP 和 UDP 协议位于 TCP/IP 协议簇的传输层。\nTCP/IP 借鉴了 OSI 的分层概念建立TCP/IP模型，TCP/IP 已被广泛使用，成为网络互联事实上的标准。\n使用 TCP/IP 协议传递数据图解： TCP TCP(Transmission Control Protocol )全称是传输控制协议，是一种面向连接的、可靠的、全双工、单播传输的、基于字节流的传输层通信协议。属于TCP/IP协议簇的传输层。\n面向连接： 即传递数据前在两端建立连接，使用“三次握手”确保两端的发送和接收能力，提供可靠的连接。 仅支持单播传输：只能进行一对一的数据传输，不支持组播和广播传输方式。 拥堵控制：网络拥堵的时，TCP能够减小向网络注入数据的速率和数量，缓解拥堵，提供对流量控制和服务质量的访问。 全双工： 双端既可以当接收者，也可以当发送者。 基于字节流模式： 比如发送端发送 100 字节到目标端，目标端可以分 10 次，每次 10 字节接受，也就是以少量数据分以任意次接收。 UDP UDP(User Data Protocol)全称用户数据报协议，是一种无连接的、不可靠的、支持组播和广播、基于数据报的传输层通信协议。属于TCP/IP协议簇的传输层。\n无连接不可靠： 不需要繁琐的三次握手，确认、重传、拥塞控制等机制，没有这些安全机制，速度更快的同时，安全性变差，易丢包。UDP 使用尽可能最大努力交付，但不保证可靠交付。 支持组播和广播： 可以一对一，一对多，多对一、多对多数据传输。 基于数据报模式： 一次发送对应一次接收，一次只读取一个报文，多个报文不可以合并。 UDP 和 TCP 区别总结 指标 TCP UDP 连接 面向连接 无连接 报文 面向字节流 面向报文 效率 低 高 是否可靠 可靠 不可靠 拥塞控制 有 无 速度 慢 快 双共性 全双工 一对一、一对多、多对一、多对多 使用 nodejs 实现 TCP 连接 服务端\nconst net = require(\u0026#34;net\u0026#34;); const HOST = \u0026#34;127.0.0.1\u0026#34;; const PORT = 8081; const server = net.createServer(); server.on(\u0026#34;listening\u0026#34;, () =\u0026gt; { console.log(`TCP server at ${HOST}:${PORT}`); }); server.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { socket.on(\u0026#34;data\u0026#34;, (buffer) =\u0026gt; { const msg = buffer.toString(); console.log(msg); socket.write(Buffer.from(`来自服务端 ${msg}`)); }); }); server.on(\u0026#34;close\u0026#34;, () =\u0026gt; { console.log(\u0026#34;TCP server close!\u0026#34;); }); server.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(`TCP server error :${err}`); setTimeout(() =\u0026gt; { server.close(); }, 1000); }); server.listen(PORT, HOST); 客户端\nconst net = require(\u0026#34;net\u0026#34;); const HOST = \u0026#34;127.0.0.1\u0026#34;; const PORT = 8081; const client = net.createConnection({ host: HOST, port: PORT, }); client.on(\u0026#34;connect\u0026#34;, () =\u0026gt; { setTimeout(() =\u0026gt; { client.write(\u0026#34;客户端向服务端发送消息: 1\u0026#34;); }, 1000); setTimeout(() =\u0026gt; { client.write(\u0026#34;客户端向服务端发送消息: 2\u0026#34;); }, 2000); setTimeout(() =\u0026gt; { client.write(\u0026#34;客户端向服务端发送消息: 3\u0026#34;); }, 3000); }); client.on(\u0026#34;data\u0026#34;, (buffer) =\u0026gt; { console.log(buffer.toString()); }); client.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(\u0026#34;TCP server error\u0026#34;, err); }); client.on(\u0026#34;close\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;client disconnects\u0026#34;, err); }); 使用 nodejs 实现 UDP 连接 服务端\nconst dgram = require(\u0026#34;dgram\u0026#34;); const HOST = \u0026#34;127.0.0.1\u0026#34;; const PORT = 8082; const server = dgram.createSocket(\u0026#34;udp4\u0026#34;); server.on(\u0026#34;listening\u0026#34;, function () { const address = server.address(); console.log(`UDP server at ${HOST}:${PORT}`); }); server.on(\u0026#34;message\u0026#34;, function (message, remote) { console.log(`来自服务端 ${message}`); }); server.bind(PORT, HOST); 客户端\nconst dgram = require(`dgram`); const PORT = 8082; const HOST = \u0026#34;127.0.0.1\u0026#34;; const client = dgram.createSocket(\u0026#34;udp4\u0026#34;); setTimeout(() =\u0026gt; { sendMsg(Buffer.from(`客户端向服务端发送消息: 1`)); }, 1000); setTimeout(() =\u0026gt; { sendMsg(Buffer.from(`客户端向服务端发送消息: 2`)); }, 2000); setTimeout(() =\u0026gt; { sendMsg(Buffer.from(`客户端向服务端发送消息: 3`)); }, 3000); setTimeout(() =\u0026gt; { client.close(); console.log(\u0026#34;客户端主动关闭\u0026#34;); }, 4000); function sendMsg(_msg) { client.send(_msg, PORT, HOST, function (err, bytes) { if (err) throw err; console.log(_msg.toString()); }); } ","permalink":"http://localhost:1313/blogs/%E4%BB%8Eosi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%88%B0tcp/","summary":"\u003ch2 id=\"为什么要写这篇博客\"\u003e为什么要写这篇博客\u003c/h2\u003e\n\u003cp\u003e一个是感觉自己的计算机网络基础薄弱，关于七层模型和 tcp、udp 看过几次了，都不够透彻，知其然不知其所以然。再一个，最近和同事有聊到这个事，感觉自己也说不明白，又意识到很重要，所以决定整理一下，自己感觉自己会了和可以给别人讲明白这个事儿，区别还是很大的啊。就参考资料和自己理解记录一下。\u003c/p\u003e","title":"从OSI七层模型到TCP"},{"content":" 发布订阅模式 简单来说，需要三个角色\n发布者 事件队列 订阅者 发布者 -\u0026gt; 事件队列 \u0026lt;=\u0026gt; 订阅者\n一次完整流程\n订阅者向事件队列订阅事件E 发布者向事件队列发布事件E 事件队列通知事件E的所有订阅者，订阅者接收 class Event { constructor() { // 事件队列 this.listeners = {}; } // 订阅方法 on(eventType, listener) { if (!this.listeners[eventType]) { this.listeners[eventType] = []; } this.listeners[eventType].push(listener); } // 发布方法 emit(eventType, data) { const callbacks = this.listeners[eventType]; if (callbacks) { callbacks.forEach((c) =\u0026gt; { c(data); }); } } } const event = new Event(); event.on(\u0026#34;open\u0026#34;, (data) =\u0026gt; { console.log(data); }); event.emit(\u0026#34;open\u0026#34;, { open: true }); 观察者模式 需要两个角色\n目标 观察者 目标 \u0026lt;=\u0026gt; 观察者\n一次完整流程\n观察者观察目标 一旦目标发生变化，目标会主动通知观察者 function observer(obj, target, callback) { if (!obj.data) { obj.data = {}; } Object.defineProperty(obj, target, { get() { return this.data[target]; }, set(val) { this.data[target] = val; // 目标通知观察者 callback \u0026amp;\u0026amp; callback(val); }, }); if (obj.data[target]) { callback \u0026amp;\u0026amp; callback(obj.data[target]); } } ","permalink":"http://localhost:1313/blogs/%E8%AE%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"\u003chr\u003e\n\u003ch2 id=\"发布订阅模式\"\u003e发布订阅模式\u003c/h2\u003e\n\u003cp\u003e简单来说，需要三个角色\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e发布者\u003c/li\u003e\n\u003cli\u003e事件队列\u003c/li\u003e\n\u003cli\u003e订阅者\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e发布者\u003c/strong\u003e -\u0026gt; \u003cstrong\u003e事件队列\u003c/strong\u003e \u0026lt;=\u0026gt; \u003cstrong\u003e订阅者\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e一次完整流程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e订阅者\u003c/code\u003e向事件队列订阅\u003ccode\u003e事件E\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e发布者\u003c/code\u003e向事件队列发布\u003ccode\u003e事件E\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e事件队列通知\u003ccode\u003e事件E\u003c/code\u003e的所有\u003ccode\u003e订阅者\u003c/code\u003e，\u003ccode\u003e订阅者\u003c/code\u003e接收\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 事件队列\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 订阅方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003elistener\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003elistener\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 发布方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eemit\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elisteners\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eeventType\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEvent\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;open\u0026#34;\u003c/span\u003e, (\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eemit\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;open\u0026#34;\u003c/span\u003e, { \u003cspan style=\"color:#a6e22e\"\u003eopen\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e });\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"观察者模式\"\u003e观察者模式\u003c/h2\u003e\n\u003cp\u003e需要两个角色\u003c/p\u003e","title":"记发布订阅和观察者模式"},{"content":"旅行者计划 30 多年前，美国发起了一项太空计划：旅行者计划。目的是为了探测木星和土星，其中包含旅行者1号和旅行者2号，在 1977 年，美国向太空发射了这两颗探测器。\n伟大的旅行者 1 号 它重 800 公斤，上面搭载了 11 个探测器，有 16 个推进器和一个燃料箱，和三个核能电池，上面还有一台电脑，只有 74kb，没有内存和硬盘，用磁带存储，就这样一个简陋的设备，到目前为止还在工作。\n旅行者 1 号自 1977 年 9 月 5 号发射，已经飞行了44年，距离地球214亿公里，他已经不在太阳系以内了，是目前人造探测器飞行距离最远的一颗探测器，部分功能到目前为止仍可正常运作。 选择在 1977 年发射也是有原因的，正好那个时候，土星木星天王星海王星冥王星，都在太阳的同一侧，几乎连成一条线。这种情况 175 ～ 176 年才会出现一次。大大减少了探测成本。 关于动力，为什么可以飞这么久，因为它采用两个飞行方式，一个是惯性飞行，一个是重力协助，惯性飞行就是宇宙真空没什么阻力，给它一个力就可以一直飞。重力协助是当飞行到大行星附近时，会被大行星的重力拉过来，当和大行星有一定距离后，也由于重力会被甩出去，也叫引力弹弓。利用这两个飞行方式非常节约能源，基本不需要什么燃料，搭载三颗核能电池也是用于照相机和探测器的工作消耗。 发射旅行者 1 号主要有两个目的：一个是探测木星和土星，另外一个探测地外文明。第一个目的完美的完成了，设计之初，就没准备让这这颗飞行器回到地球，一直飞出太阳系向宇宙深处进发，考虑到这一点，在上面装了一个金唱盘，铜制的，表面镀金。 这个上面记载了太阳系的坐标，里面的行星的具体参数，特别标注的地球，证明唱盘来自这里。大自然的声音，包括滑浪，风，雷，鸟鸣，歌声，鲸鱼等其他动物叫声，并挑选来自不同文化的及年代的音乐。人体构造解刨图，计量单位的标准，时间和长度，里面还有一块非常纯的铀238， 因为铀 238 的半衰期是44.7亿年，收到的人根据衰变程度就可以推断出，就能反推唱盘的生产日期。 如上图，在唱盘的一面上，标注了使用方法，包括旋转周期，唱片的时间单位，地球在银河系的位置，图片读取方式等，内容有一些人类生活，自然的图片。 除此外，还有 90 分钟的歌曲，包括不同文化的古典音乐，其中包括有一首中国曲子：高山流水。还有用 55 种语言说的\u0026quot;你好\u0026quot;，包括普通话和粤语。\n金唱盘内全部内容，见 B 站\n旅行者 1 号，去土星其实是为了要去探测土星的一个卫星，泰坦，因为泰坦的环境地球类似，当旅行者 1 号到达泰坦，果然泰坦上有着厚厚的黄色大气，主要是氮气和甲烷，地表温度为零下179度。 旅行者 1 号在探测完泰坦之后，由于土星重力，偏移了黄道面，也就是 9 大行星的平面。在九年后，nasa 又联系了旅行者 1 号，让它拍一张太阳系全家福，就分别拍了 39 张九大行星照片。 这个项目的首席天文学家：卡尔萨根看完地球照片后写了一本非常著名的书《暗淡蓝点》，其中非常经典的一段话：\n如果再来看一眼这个小点， 那是我们的家园，我们的所有。 你所爱所知的每一个人、所听说乃至所存在过的每一个人，都在小点上度过一生。 欢乐与痛苦，宗教与学说，猎人与强盗，英雄与懦夫，文明的创造者与毁灭者，国王与农夫，情侣，父母，儿童，发明家和探险家，崇高的老师，腐败的政客，耀眼的明星，至高无上的领袖，历史上所有的圣人与罪犯，都住在这里——它仅仅是一粒悬浮再阳光中的浮尘\n拍完暗淡蓝点后，nasa 就把旅行者 1 号的相机永久关闭了，为了省电。现在正在以每秒 14 公里的速度远离太阳向宇宙深处进发，但在 2025 年之后，旅行者一号就会彻底和地球失去联系，并成为漂浮在宇宙中的一艘“流浪探测器”。\n推测再过 4 万年，他将利用引力弹弓到达离太阳系最近的一颗恒星上 gliese 445，大概几百万年后，就能到另外一颗恒星附近，或许那个时候人类已经不存在了。对于最多有 120 年寿命的梦想着星辰大海的人类来说，的确让人感到绝望，可有金唱盘，它可以证明人类在浩瀚无垠的宇宙存在过的的一个证据吧\n在21/05/13，也就是两天前，有一条关于旅行者 1 号的新闻，“旅行者 1 号”听到星际“温柔雨声”\n","permalink":"http://localhost:1313/blogs/%E6%97%85%E8%A1%8C%E8%80%851%E5%8F%B7/","summary":"\u003ch2 id=\"旅行者计划\"\u003e旅行者计划\u003c/h2\u003e\n\u003cp\u003e30 多年前，美国发起了一项太空计划：\u003cstrong\u003e旅行者计划\u003c/strong\u003e。目的是为了探测木星和土星，其中包含\u003ccode\u003e旅行者1号\u003c/code\u003e和\u003ccode\u003e旅行者2号\u003c/code\u003e，在 1977 年，美国向太空发射了这两颗探测器。\u003c/p\u003e","title":"旅行者1号"},{"content":"持续更新，为了高效率访问，也算自己复习！！把遇到的手写题，抽空都撸了一遍。满满干货，不墨迹，直接上代码。总结道这篇博客里，下次面试前快速过一遍，临阵磨刀～\n实现 sleep 函数 // 运行log函数后，希望得到结果：打印1，等待一秒钟，打印2，实现sleep函数 function log() { console.log(1); sleep(1000); console.log(2); } log(); // 解1：阻塞主线程 function sleep(time) { let t = Date.now(); while (Date.now() - t \u0026lt;= time) {} } // 解2：async/await调用 function sleep(time) { return new Promise((res) =\u0026gt; { setTimeOut(() =\u0026gt; { resolve(); }, time); }); } 柯里化(currying) // 题目：实现add函数, 输出6 add(1, 2, 3); add(1)(2)(3); add(1, 2)(3); add(1)(2, 3); // 解1：不确定参数数量，一个方法 function add(...agrg1) { let t = function (...agrg2) { return add( Array.from(agrg1) .concat(Array.from(agrg2)) .reduce((a, b) =\u0026gt; { return a + b; }) ); }; t.toString = () =\u0026gt; { return Array.from(agrg1).reduce((a, b) =\u0026gt; { return a + b; }); }; return t; } console.log(add(1, 2, 3)); // 6 console.log(add(1)(2)(3)); // 6 console.log(add(1, 2)(3)); // 6 console.log(add(1)(2, 3)); // 6 // 解2：确定参数数量，两个方法 function currying(fn, ...args) { if (args.length \u0026gt;= fn.length) { return fn(...args); } else { return (...args2) =\u0026gt; currying(fn, ...args, ...args2); } } // add只可以接受三个参数 let add = function (a, b, c) { return a + b + c; }; // 利用currying函数改造add函数，使add函数具备柯里化 const curry_add = currying(add); console.log(curry_add(1, 2, 3)); // 6 console.log(curry_add(1)(2)(3)); // 6 console.log(curry_add(1, 2)(3)); // 6 console.log(curry_add(1)(2, 3)); // 6 约瑟夫环问题 // N个人围成一圈，第一个人从1开始报数，报M的将被淘汰，下一个人接着从1开始报。如此反复，最后剩下两个，求最后的胜利者。 function f(n) { if (n \u0026lt;= 2) { return n === 1 ? [1] : [1, 2]; } let temp = []; for (let i = 1, len = n + 1; i \u0026lt; len; i++) { temp.push(i); } return fun_inner(temp); function fun_inner(temp, count) { if (temp.length == 2) { return temp; } count = count || 1; for (let i = 0, len = temp.wlength; i \u0026lt; len; i++) { count++; if (count === 3) { temp.splice(i, 1); count = 1; } } return fun_inner(temp, count); } } console.log(f(10)); // [4, 10] console.log(f(11)); // [3, 9] console.log(f(12)); // [6, 9] 字符串相加 let addStrings = function (a, b) { let res = []; let temp = 0; if (a.length \u0026gt; b.length) { let t = a.length - b.length; for (let i = 0; i \u0026lt; t; i++) { b = \u0026#34;0\u0026#34; + b; } } else { let t = b.length - a.length; for (let i = 0; i \u0026lt; t; i++) { a = \u0026#34;0\u0026#34; + a; } } for (let len = Math.max(a.length, b.length) - 1; len \u0026gt;= 0; len--) { let i = len; let t_a = Number(a.charAt(i) || 0); let t_b = Number(b.charAt(i) || 0); let count = String(t_a + t_b + temp); temp = 0; if (count.length \u0026gt; 1) { temp = Number(count.charAt(0)); res.push(count.charAt(1)); } else { res.push(count); } } if (temp !== 0) { res.push(temp); } return res.reverse().join(\u0026#34;\u0026#34;); }; 插入排序 let insertion = function (arr) { let len = arr.length; for (let i = 1; i \u0026lt; len; i++) { let cur = i; let j = i - 1; while (j \u0026gt;= 0) { if (arr[cur] \u0026lt; arr[j]) { [arr[cur], arr[j]] = [arr[j], arr[cur]]; cur = j; // 交换后i值变了，那把交换后的i找回来就可以了 } j--; } } return arr; }; 选择排序 let selection = function (arr) { let len = arr.length; for (let i = 0; i \u0026lt; len; i++) { let idx = i; for (let j = i + 1; j \u0026lt; len; j++) { if (arr[j] \u0026lt; arr[idx]) { idx = j; } } [arr[idx], arr[i]] = [arr[i], arr[idx]]; } return arr; }; 快速排序 let quickSort = function (arr) { if (arr.length \u0026lt;= 1) { return arr; } // 递归边界条件 let pointIdx = Math.floor(arr.length / 2); // 在数组中间位置取一个基准点 let point = arr.splice(pointIdx, 1)[0]; // 通过基准点找到这个值 let left = []; let right = []; for (let i = 0, len = arr.length; i \u0026lt; len; i++) { if (arr[i] \u0026lt; point) { // 循环数组，小于point的放在left中，大的放在right中 left.push(arr[i]); } else { right.push(arr[i]); } } // 递归，让每一个left和right继续排序，直到left或right只有一项为止 return quickSort(left).concat(point, quickSort(right)); }; call \u0026amp; apply \u0026amp; bind 实现 window.name = 2; let obj = { name: 1, }; function fn(a, b) { console.log(this.name, a, b); return 1; } // call Function.prototype.myCall = function (context) { context = context || window; // 如果上下文是null或者undefined，那么默认为window context.fn = this; // 设置执行函数到obj上，利用谁调用，谁就是this的特性，来实现this转换 // let arg = Array.from(arguments).slice(1) 截取参数也能这么写 let arg = [...arguments].slice(1); // 截取除了第一个参数以后的参数 let t = context.fn(...arg); // 传参执行 delete context.fn; // 设置完成后删除 return t; // 并返回 }; // apply Function.prototype.myApply = function (context) { context = context || window; context.fn = this; // 设置执行函数到obj上，利用谁调用，谁就是this的特性，来实现this转换 let arg = [...arguments][1]; // 参数是一个数组 if (!arg) { // 如果没参数，那么就不传参执行 return context.fn(); } let t = context.fn(...arg); delete context.fn; return t; }; // bind Function.prototype.Mybind = function (ref, ...arg) { // 当这个函数被new调用，需要解决两个问题 // 1: 不应该使用ref为this，根据情况判断，如果new调用那么this为实例。普通调用this为ref // 2: \b因为bind返回是新函数，所有要bind新函数要继承_this的原型 let _this = this; let fun = function (...arg2) { // 1的实现：this instanceof fun表达式为true说明被new调用，那么this就是新函数的this，也就是一个新的对象，否则就是第一个参数ref thisArg = this instanceof fun ? this : ref; return _this.apply(ref, [...arg, ...arg2]); }; // 2的实现：如果有prototype，那么继承 _this.prototype \u0026amp;\u0026amp; (fun.prototype = Object.create(_this.prototype)); return fun; }; console.log(fn(1, 2)); console.log(fn.myCall(obj, 1, 2)); console.log(fn.myApply(obj, [1, 2])); console.log(fn.Mybind(obj, [1, 2])()); 二叉树反转 let reverseTree = function (root) { if (!root) return null; if (root.left || root.right) { let temp = root.left; root.left = root.right; root.right = temp; reverseTree(root.left); reverseTree(root.right); } return root; }; 链表反转 var reverseList = function (head) { let [prev, curr] = [null, head]; while (curr) { let tmp = curr.next; // 1. 临时存储当前指针后续内容 curr.next = prev; // 2. 反转链表 prev = curr; // 3. 接收反转结果 curr = tmp; // 4. 接回临时存储的后续内容 } return prev; }; 二叉树遍历 以前序遍历举例\n// 递归版 function preTraverse(root) { if (root) { console.log(root.value); preOrder(root.left); preOrder(root.right); } } // 非递归版 function preTraverse(root) { if (!root) { return false; } let stack = []; let p = root; while (stack.length || p) { if (p) { console.log(p.val); stack.push(p); p = p.left; } else { p = stack.pop(); p = p.right; } } } promise 重试 Promise.retry = function(fn, num = 3){ return new Promise(function(resolve, reject){ while(num\u0026gt;0){ try{ const res = await fn resolve(res) num = 0 } catch(e){ if(!num) reject(e) } num -- } }) } ","permalink":"http://localhost:1313/blogs/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/","summary":"\u003cp\u003e持续更新，为了高效率访问，也算自己复习！！把遇到的手写题，抽空都撸了一遍。满满干货，不墨迹，直接上代码。总结道这篇博客里，下次面试前快速过一遍，临阵磨刀～\u003c/p\u003e","title":"手写代码面试题合集"},{"content":" HTML 和 CSS BFC 全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。\n怎么触发： 根元素 body float： right | left position： absolute | fixed display：inline-block | tabel-cells | flex overflow： hidden | auto | scroll 效果 清除浮动，常用 overflow hidde 垂直方向 margin 会重叠 重排和重绘 网页加载过程大致分为 5 步：\nHTML 代码转化成 DOM CSS 代码转化成 CSSOM 结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 其中第 4 步为排列布局，重排指的就是第 4 步重做；第 5 步是绘制，那重绘指的就是第 5 步重做。按照网页加载顺序，第 4 步之后执行第 5 步，所以重排必将触发重绘，而重绘不一定会触发重排。\n重绘：修改元素字体颜色，背景颜色，阴影效果等 重排：位置发生改变，如margin padding width。 删除增加dom 调用offsetHeight等读取实时量值时\n由于重排性能消耗大，那么减少重排次数也就成了一个优化页面的方法，下面总结几个常用方法：\n不要一条一条修改 css，尽量通过 class 修改，或者 csstext 先 display: none; 再修改样式，然后再 display: block; 一个元素大量修改 css，可以设置为 position: fixed | absolute, 这样重排消耗少，因为不用考虑其他元素位置 react vue 虚拟 dom link 和@import 区别 @import属于 css 语法，只能加载 css，link是 html 语法，不仅可以加载 css，还可以加载网站 icon 等\n为什么要使用 css 预处理语言 类似 scss(sass3+)，less 等预处理 css 语言，扩展了 css，具备变量、mixins、函数, 嵌套，带有作用域，支持块注释 //\nsrc 和 href 的区别 src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系。src 加载资源会阻塞页面，href 是加载并行。\nsrc:\n\u0026lt;img src=\u0026#34;/img.jpg\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; href:\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/main.css\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 行内元素特点 可以设置所有方向margin和padding，但是垂直方向无法更改布局 设置width和height属性无效 不会另起一行 实现换肤功能 设置多种颜色类名，覆盖实现 http 请求动态加载 .css 文件 预编译 css 变量 js 部分 箭头函数和普通函数区别 没有自己 this，继承父级的 this 没有自己 arguments // Uncaught ReferenceError: arguments is not defined 没有原型 // undefined script 的 defer 和 async 属性区别 相比于基本的 script 标签、都可以实现异步加载脚本，只是执行脚本的时机不同，\nasync：加载完成后，立即执行，可以在 dom 没完全加载执行，如果多个 script async，那么哪个先加载完就执行哪个，适合加载无依赖的 js defer：加载完成后，等到dom加载完成后执行，如果多个 script defer，会严格按照他们的书写顺序依次执行，适合加载互相依赖的 js 深拷贝 // 冷门深拷贝利用MessageChannel function deepClone(obj) { return new Promise(function (resolve, reject) { var { port1, port2 } = new MessageChannel(); port1.onmessage = function (e) { resolve(e.data); }; port2.postMessage(obj); }); } // 利用weakmap解决了循环引用报错问题，完全版 function deepClone1(_target, map = new WeakMap()) { if (!_target || typeof _target !== \u0026#34;object\u0026#34;) { return _target; } if (map.get(_target)) { console.log(\u0026#34;进入map判断\u0026#34;); console.log(map.get(_target)); return map.get(_target); } let res = Array.isArray(_target) ? [] : {}; console.log(\u0026#34;map set\u0026#34;); console.log(_target, res); map.set(_target, res); for (let i in _target) { console.log(\u0026#34;循环\u0026#34;); if (typeof _target[i] === \u0026#34;object\u0026#34;) { console.log(\u0026#34;是对象\u0026#34;); res[i] = deepClone1(_target[i], map); } else { console.log(\u0026#34;不是对象\u0026#34;); res[i] = _target[i]; } } return res; } 函数防抖和节流 防抖： function debounce(event, delay) { let timer = null; return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理 timer = setTimeout(() =\u0026gt; { event.apply(this, args); }, delay); }; } 节流： function throttle(event, delay) { let prev = Date.now(); return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 let now = Date.now(); if (now - prev \u0026gt;= delay) { event.apply(this, args); prev = Date.now(); } }; } 查看详解\n继承 原型链继承： Cat 继承了 Animal，缺点：所有 Cat 实例都会共享原型链，不可以向 Animal 传参。\nfunction Cat() {} Cat.prototype = new Animal(); call 继承/构造继承: 解决上面原型链建成俩问题，但是只是 Cat 实例，不是 Animal 的实例\nfunction Cat(name) { Animal.call(this); } 组合继承：也就是前面两个方法合并，解决上面两个继承的缺点，唯一的缺点调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\nfunction Cat(name) { Animal.call(this); } Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; //修复构造函数指向 // 优点： // 既是cat实例，又是Animal实例 // 没有共享原型方法问题，并可以传参数 跨域 jsonp： 利用 script 标签跨域，本质是加载一个外部 js\ncors：全程跨域资源共享，服务端操作，把请求头的origin的值取出，响应头会增加Access-Control-Allow-Origin key 并把值设置为origin取出的值也可以是通配符，浏览器就不会拦截响应了，从而解决跨域问题\npostMassage：利用可访问服务资源的iframe，和当前页面互相通信，传递消息，来实现跨域，postMassage本质是两个页面的消息传递方法。\n// 页面1(可以获取后端数据的)传递数据，第二个参数是url匹配规则，可以是通配符 window.frames[0].postMessage(data, \u0026#34;*\u0026#34;); // 页面2(不能接收后端数据的)，接收页面1的数据 window.addEventListener(\u0026#34;message\u0026#34;, function (e) { console.log(e.data); }); 服务器中转： 由于服务端没跨域，服务端代替客户端请求目标接口，并把响应数据返回给客户端\n数组方法 改变原数组 splice: array.splice(index,howmany,item1,\u0026hellip;..,itemX) 删除/添加 sort: 排序 unshift: 首加 shift: 首删; pop: 尾删; push: 尾加 reverse: 倒序排列 fill: 数组填充 array .fill(value, startIndex | 0, endIndex | array.length) [(1, 2, 3, 4, 5)].fill(\u0026#34;a\u0026#34;, 1, 3); // [1, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, 4, 5] 不改变原数组，生成新数组 slice: 浅拷贝 array.slice(startIdx, endIdx) join: 转字符串并分割 toLocaleString: 转换成字符串数组 concat: 连接数组 可用\u0026hellip;替代 indexOf: 检查下标 includes: 是否包含。可替代 indexOf，indexOf === -1 不够语义化 循环方法 forEach、map、filter every、some、reduce、reduceRight(和 reduce 区别是相反方向) 字符串方法 var str = \u0026#34;hello world\u0026#34;; str.charAt(1); //e 返回指定下标的字符 str.charcodeAt(1); //101 返回指定下标字符的字符编码 str.concat(123); // hello world123 连接字符串，生成新的 str.slice(0, 2); // he 截取字符串，参数为下标 str.substring(0, 2); // he 截取字符串，参数为下标 str.substr(0, 2); // he 截取字符串，第一个参数是起始下标，第二个参数为截取数量 str.indexOf(\u0026#34;h\u0026#34;, 0); // 0 查子字符下标，第一个参数是字符，第二个参数是起始下标 str.lastIndexOf(\u0026#34;h\u0026#34;, 0); // 0 查子字符下标，第一个参数是字符，第二个参数是结尾下标(和indexof区别) str.toLowerCase(); // hello world 转小写 str.toUpperCase(); // HELLO WORLD 转大写 str.trim(); // 删除前后空格 str.split(\u0026#34;e\u0026#34;); // [\u0026#34;h\u0026#34;, \u0026#34;llo world\u0026#34;] 转数组，参数为分割符 str.replace(\u0026#34;o\u0026#34;, \u0026#34;a\u0026#34;); // hella world 替换字符，第一个参数可以是正则 str.match(/hello/g); // [\u0026#34;hello\u0026#34;] 匹配字符串返回一个数组，参数常是正则 js 垃圾回收机制 当内存中的数据不需要时候，js 会自动使用垃圾回收算法释放掉\n引用计算 : 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。这是最初级的垃圾收集算法。 该算法有个限制：无法处理引用循环，两个对象互相引用的情况下，引用次数至少是 1，所以不会被回收掉 标记清除 : 此算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法从根（root）全局对象开始先下查找，找到不可以被获得的对象，然后清除掉 类型检测 typeof: 除了基本数据类型，检测不到具体 object 类型(数组，对象，时间对象，正则，set，map) instanceof: 例 a instanceof Fun 原理是检测 a 是不是 Fun 的实例，缺点就是被检测的值必须是引用，如下所示 new Number(1) instanceof Number; // true 1 instanceof Number; // false constructor: 实例.constructor === 构造器，缺点是 constructor 属性容易被修改 Object.prototype.toString.call: 目前最好用的一个方法，缺点是使用 object 构造函数的 toString 方法，此方法可能被修改 Object.prototype.toString.call(1) // \u0026#34;[object Number]\u0026#34; Object.prototype.toString.call(\u0026#39;1\u0026#39;) // \u0026#34;[object String]\u0026#34; Object.prototype.toString.call([1]) // \u0026#34;[object Array]\u0026#34; // 如果修改原型 Object.prototype.toString = Array.prototype.toString Object.prototype.toString.call([1,2,3]) // \u0026#34;1,2,3\u0026#34; ... valueOf 和 toString valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 对象转字符串或者数字的过程：如果转换成字符串，会优先调用 toString 方法，转数字，会优先调用 valueOf 方法\n相关面试题：\n// 下面代码a在什么值情况下会输出1 var a = ?; if (a == 1 \u0026amp;\u0026amp; a == 2 \u0026amp;\u0026amp; a == 3) { console.log(1); } // 解 var a = { n : 0, valueOf(){ return ++this.n; } }; proxy 和 reflect proxy 对目标读取、函数调用等操作进行拦截，然后操作处理。它不直接操作对象，而是像代理模式。\nlet target = { name: \u0026#34;Tom\u0026#34;, age: 24, }; let handler = { get: function (target, key) { console.log(\u0026#34;getting \u0026#34; + key); return target[key]; // 不是target.key }, set: function (target, key, value) { console.log(\u0026#34;setting \u0026#34; + key); target[key] = value; }, }; // target为目标对象，handler为代理处理 let proxy = new Proxy(target, handler); reflect 优化了 object 内部操作，修改一些函数的返回值，如 Object.defineProperty，Reflect 与 Proxy 是一一对应的对象，是 Proxy 的方法也是 Reflect 的方法，Proxy 修改的过的方法可以在 Reflect 获取默认值。\n// 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 Object.defineProperty(target, property, attributes) // 报错 Reflect.defineProperty(target, property, attributes // false // 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 \u0026#39;assign\u0026#39; in Object // true Reflect.has(Object, \u0026#39;assign\u0026#39;) // true requestAnimationFrame 针对实现动画 setInterval 的优化方法，执行速率和设备屏幕帧率有关系，不需要调用者指定帧速率，交给浏览器自行决定最佳帧效率，每一帧只执行一次，多次改变触发一次重拍，这样不会引起丢帧现象，也不会导致动画卡顿\n事件循环 同步任务在执行栈，异步任务执行后回调区分微任务和宏任务放入对应的微宏队列中，等同步执行栈执行完毕，会先检查微任务队列，执行完毕后，检查宏任务队列，执行。其中 Promise.resolve 调用静态方法，会优先于正常的 promise 的 resolve 方法\n异步微任务有哪些：\nnew Promise() 异步宏任务有哪些：\nsetInterval() setTimeout() 执行顺序： 同步放入执行栈 =\u0026gt; 异步放入任务队列 =\u0026gt; 异步区分微宏任务 =\u0026gt; 微任务 =\u0026gt; 宏任务\nasync/await，await 后的语句是同步的，在函数体内，await 下的语句会被放入 promise 回调函数体中，async 函数默认返回一个 promise 对象\n经典面试题：\nasync function async1() { console.log(\u0026#34;async1 start\u0026#34;); await async2(); console.log(\u0026#34;async1 end\u0026#34;); } async function async2() { console.log(\u0026#34;async2\u0026#34;); } console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); async1(); new Promise(function (resolve) { console.log(\u0026#34;promise1\u0026#34;); resolve(); }).then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); 解析：按照从上往下顺序先执行同步代码，前两个函数async1和async2是函数声明，忽略。然后第 1 个输出的是script start，然后看到setTimeout, 由于它是异步且属于宏任务，放到最后执行。然后看到 async1 函数被执行了，进入async1函数体，第 2 个输出的是async1 start, 看到 await 规则是：await 右的语句被同步执行，所以第 3 个输出的是async2，await 下的语句(函数体内)被当作 async 函数返回一个 promsise 的回调函数体的语句去处理，且被放入了异步任务队列中，等待中。然后跳出 async1 函数体，继续执行同步代码，遇到 new Promise，第 4 次输出promise1，看到 resolve，就把 then 中回调，放入任务队列中，然后继续向下执行同步代码，第 5 次输出的最后的script end。至此同步执行栈空了，开始把任务队列中的上下文拿到执行栈执行，由于队列先进先出，所以第一个被入栈的是 async1 的回调，也就是第 6 次输出的是async1 end，然后把第二个队列中的上下文放入执行栈，也就是 promise 的 resolve，所以第 7 次输出promise2，至此微任务执行完成，现在执行宏任务，也就是 timeout，所以第 8 次输出为setTimeout。\n结果：\nscript start async1 start async2 promise1 script end async1 end promise2 setTimeout 迭代器和生成器 先来瞅一段代码：\nfunction createIterator(items) { var i = 0; return { // 返回一个迭代器对象 next: function () { // 迭代器对象一定有个next()方法 let done = i \u0026gt;= items.length; let value = !done ? items[i++] : undefined; return { value: value, done: done, }; }, }; } var iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // \u0026#34;{ value: 1, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 2, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 3, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: undefiend, done: true}\u0026#34; 这就是迭代器，迭代器是一个特殊对象，可以通过每调用一次 next，获取下一项结果。可以用迭代器替代 for 循环，因为 for 通过下标获取，多层嵌套比较复杂。\n// 用迭代器模拟for var colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;]; var iterator = createIterator(colors); while (!iterator.next().done) { console.log(iterator.next().value); } 迭代器模拟 for 的方法看起来太麻烦了，不如 for 来的方便，这个时候可以用生成器(* 和 yield)来快速生成迭代器。\nfunction* createIterator(items) { for (let i = 0; i \u0026lt; items.length; i++) { yield items[i]; } } let iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // \u0026#34;{ value: 1, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 2, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: 3, done: false}\u0026#34; console.log(iterator.next()); // \u0026#34;{ value: undefiend, done: true}\u0026#34; 通过*和yield关键字创建，*来表示这个函数内部是可以用 yield 返回每次迭代的值，和 async、await 一样。需要组合使用，yield后面接每次迭代的值。这样就可以外部调用.next()获取下一个值。\n在 es6 中，数组、Set、Map、字符串集合，都属于可迭代对象，内部都有默认迭代器，可通过object[Symbol.iterator]()访问默认迭代器。\nes6 中也提供了一个通过方法来快速使用迭代器\nfor(item of 集合迭代器) {...} 常见的迭代器和得到 item 的值：\nobject.keys(): key(对象)/下标(数组) object.values(): 每项 value object.entries(): [下标/key, value] 事件委托与冒泡和捕获 什么是事件委托：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n什么是冒泡和捕获：其实都是事件传播路径。冒泡：从外到事件源进行事件传播；捕获：从内向事件源进行事件传播；\nDOM 标准事件流的触发的先后顺序为：先捕获再冒泡。即当触发 dom 事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。 addEventListener事件监听方法的第三个参数默认值是false，表示冒泡阶段调用，true为捕获阶段调用\n\u0026lt;body\u0026gt; \u0026lt;button\u0026gt;append\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;0\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; window.onload = function () { document.querySelector(\u0026#34;button\u0026#34;).onclick = function (e) { let li = document.createElement(\u0026#34;li\u0026#34;); li.innerHTML = \u0026#34;5\u0026#34;; document.querySelector(\u0026#34;ul\u0026#34;).appendChild(li); }; document.querySelector(\u0026#34;ul\u0026#34;).onclick = function (e) { // li 新增的li也是可以被点击的 console.log(e.target.nodeName.toLowerCase()); }; }; addeventListener 和 onclick 不同点：\naddeventListener 可以给一个事件注册多个 listener addEventListener 可以控制时间传播行为（捕获/冒泡，使用 removeEventListener 来解决） 实现 instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 let objProto = obj.__proto__; while(objProto) { if (objProto === ctor.prototype) { return true; } objProto = objProto.__proto__; } return false; } var Food = function() {}; var Meat = function() {}; Meat.prototype = new Food(); var meat = new Meat(); newInstanceof(meat, Meat) // true newInstanceof(meat, Food) // true meat instanceof Meat // true meat instanceof Food // true 总的来说就是meat.__proto__.constructor === Meat，由于原型链是一条链，所以循环所有__proto__; 直到null为止，符合Meat.prototype === meat.__proto__即返回true，否则返回false。\nconstructor 和 super 关键字 class是ES6新增的关键字，为了看起来更像java等面向对象语言，实际上是一个语法糖，等同于ES5的function来创建构造函数。\nconstructor ：constructors是 class 中默认的一个关键字，会自动调用该方法，class中必须要有constructor，如果没有，会被默认添加。当 new 时，constructor会被执行返回一个 this，就是实例。 super ： 当class有继承时，在constructor内部必须执行一遍 super()函数，B 继承 A，super相当于A.prototype.constructor.call(this, props)，另外 super()也指向父亲 A 的原型对象， 详细解释。如果当前类和父类都有同名方法，如何区分地获取呢，获取父类：super().fun，获取当前类：fun vue 部分 vue 组件通信 props 和 $emit provide inject：在组件 a 声明，在 a 下面所有子组件通过 inject 调用，通过参数传递 event bus： new 出一个 vue，通过 emit 和 on 来派发和监控 vuex 全局状态管理 this.$children 和 this.$parent 层级较深不推荐，provid 可以替代此方法 vue 生命周期父子组件执行顺序 父 beforeCreate -\u0026gt; 父 created -\u0026gt; 父 beforeMount -\u0026gt; 子 beforeCreate -\u0026gt; 子 created -\u0026gt; 子 beforeMount-\u0026gt;子 mounted-\u0026gt;父 mounted\n子组件更新：父 beforeUpdate -\u0026gt; 子 beforeUpdate -\u0026gt; 子 updated -\u0026gt; 父 updated\n父组件更新：父 beforeUpdate -\u0026gt; 父 updated\n销毁：父 beforeDestroy -\u0026gt; 子 beforeDestroy -\u0026gt; 子 destroyed -\u0026gt; 父 destroyed\n总结带 beofre 的生命周期都是从父到子调用，带 ed 的生命周期都是从子到父\n前端路由 hash 14 年前，前端路由都是用 hash 的方式实现的，地址长这个样子url#hash， 修改hash部分不会重载这个页面，每次 hash 改变，可以用 window 的hashchange方法来监听，通过这个方法就可以实现前端路由了\nhistory 在 14 年，HTML5 标准发布，window 上新增了两个 api：pushState和replaceState，也 hash 一样，不刷新来实现前端路由，而且少了#更美观了，由于没#，所以刷新时候，默认会从服务器下载对应 url 资源，这个时候我们需要改下服务器配置，都加载前端 index.html 文件，来实现前端路由\n// 第一个参数是state，用于描述一些特性，会被放入历史栈中，开发者使用 // 第二个参数是title，表示新页面的标题，浏览器都会忽略这个参数 // 第二个参数是url，表示新页面的相对地址 // 跳转 window.history.pushState(null, null, \u0026#34;/profile\u0026#34;); window.history.replaceState(null, null, \u0026#34;/profile\u0026#34;); 和pushState的区别是不会把记录放入历史栈中; 共同点 都不会重载页面 都会把历史记录放入栈中 不同点 hash 只可以#后部分，必须是同源 url，history 没有限制 history 需要修改服务器配置，来解决刷新空白问题，hash 本身就是属于前端的，不需要设置 slot 插槽 匿名插插: 子组件包裹的内容会被显示到slot标签中 \u0026lt;child\u0026gt;父给子的内容\u0026lt;/child\u0026gt; // child组件中, 父给子的内容会显示slot标签里 \u0026lt;slot\u0026gt;父给子的内容\u0026lt;/slot\u0026gt; 具名插插：感觉名字多次显示，可复用 \u0026lt;div slot=\u0026#34;down\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;的内容 会被显示到\u0026lt;slot name=\u0026#34;down\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt;里 数据插槽： // 父亲中 \u0026lt;div v-slot:data=\u0026#34;{data}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 组件中就可以用data了 \u0026lt;myslot v-slot=\u0026#34;data\u0026#34;\u0026gt; {{ slotProps.user.firstName }} \u0026lt;/myslot\u0026gt; keep-alive keep-live 是 vue 提供的内置缓存组件，可以保存组件状态，避免重新渲染，keep-alive 有三个参数：\ninclude 匹配的组件会被缓存，参数：字符串、数组、正则 exclude 匹配的组件不会被缓存，参数：字符串、数组、正则，和 include 同时存在一个组件的的话，exclude 优先级更高 max 可以限制最大可以缓存组件的数量，字符串或者数字 \u0026lt;!-- 组件name为a或者b的组件缓存 --\u0026gt; \u0026lt;keep-alive include=\u0026#34;a,b\u0026#34;\u0026gt; \u0026lt;component\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;!-- 组件name为c的组件不缓存 --\u0026gt; \u0026lt;keep-alive exclude=\u0026#34;c\u0026#34;\u0026gt; \u0026lt;component\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; 缓存组件会多出两个生命周期，activated和deactivated，渲染和销毁\nkeep-alive 可配合 router-view 来实现组件缓存\n\u0026lt;keep-alive\u0026gt; \u0026lt;router-view v-if=\u0026#34;$route.meta.keepAlive\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;router-view v-if=\u0026#34;!$route.meta.keepAlive\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;a\u0026#39;, component: a, meta: { keepAlive: false // 不缓存 } }, { path: \u0026#39;/b\u0026#39;, name: \u0026#39;b\u0026#39;, component: b, meta: { keepAlive: true // 缓存 } } ] }) nextTick nextTick 可以获取下次最新 dom 的方法，因为 vue 的 dom 更新策略是异步的，只有一个事件循环结束后才会被应用来更新 dom，这导致数据的修改不会立即表现在 dom 上，如果要获取更新后的 dom 状态，这时候就需要用到 nextTick\n一些场景：\ncreated 中想要获取 DOM 更改数据获取最新的 dom mixin vue mixin 是针对组件间功能共享来做的。可以对组件的任意部分进行 mixin，也就是说不同的组件，想使用同一个数组，或者方法，那么 mixin 就是来做这个事的，把公共部分提取出来作为 mixin\n声明：\n// 声明 const toggle = { data() { isshowing: false; }, methods: { toggleShow() { this.isshowing = !this.isshowing; }, }, }; // 使用，toggle的方法会自动合并到当前组件中 mixins: [toggle]; vuex 核心概念：\nstate：数据 getter：类似计算属性，用来获取 state mutation： 同步方法，用于修改 state action： 异步方法，最后调用 mutation 修改 state // 声明 import Vuex from \u0026#39;vuex\u0026#39; const store = new Vuex.Store({ state: { count: 0 }, getter: { doneTodos: (state, getters) =\u0026gt; { return state.todos.filter(todo =\u0026gt; todo.done) }, count: (state) =\u0026gt; { return state.count } }, mutations: { increment (state, payload) { state.count++ } }, actions: { addCount(context) { // 可以包含异步操作 // context 是一个与 store 实例具有相同方法和属性的 context 对象 } } }) // 使用 // 调用mutation this.$store.commit(\u0026#39;increment\u0026#39;, 10) // 调用actions this.$store.dispatch(\u0026#39;increment\u0026#39;, 10) // 利用mapGetters mapGetters mapMutations mapActions便捷使用 computed: { ...mapGetters([\u0026#39;audio\u0026#39;]), ...mapState({ this.count 等同于 state.count + this.localCount count(state) { return state.count + this.localCount } }, methods: { ...mapMutations({ add: \u0026#39;increment\u0026#39; // 将 `this.add()` 映射为`this.$store.commit(\u0026#39;increment\u0026#39;)` }), ...mapActions({ add: \u0026#39;increment\u0026#39; // 将 `this.add()` 映射为 `this.$store.dispatch(\u0026#39;increment\u0026#39;)` }) } react 部分 react 生命周期 componentWillMount：在渲染前调用，客户端服务端都会调用 componentDidMount：第一次渲染后调用，只在客户端 componentWillReceiveProps： 接收新的 props 被调用，初始化时不会被调用 shouldComponentUpdate： 组件更新(props,state)时调用；返回布尔值，T 为允许更新组件，F 为不更新组件 componentWillUpdate： 组件更新(props,state)前渲染前被调用，初始化时不会调用 componentDidUpdate：组件完成更新后调用。初始化时不会被调用 componentWillUnmount： 组件要销毁前调用 react 数据响应式 react 的响应式是使用 diff 算法实现的。react 在 state 改变时，会调用 render() 方法，生成一个虚拟 DOM 树，React 会将这棵树与上一次生成的树进行比较，找出其中的差异，并更新差异的部分。这个过程是递归的，react 会以当前组件为根，递归比较所以子节点。为了优化性能，React 提供了 shouldComponentUpdate 生命周期方法，这个方法有两个参数，nextProps和nextState，表示上次 props 和上次 stage，返回值是布尔值，如果这个方法返回 false，react 就跳过这个组件，不做 VDOM 比较，也不更新组件。\n在 react16+版本，对 diff 过程进行了优化，从原来的 diff 树结构+递归的方式优化成 fiber 双向链表+循环执行。整个的 diff 过程分为 render 阶段和 commit 阶段，render 就是对比过程，找到需要改变 dom 的那部分，commit 就是执行改变 dom 的那部分，render 阶段是可以分段的（中断，然后继续完成），类似原生的requestIdleCallback方法，在每个 16ms 帧内，会先执行用户输入，事件回调等优先级高的 js 任务。之后剩下的时间执行分段的 render 部分来进行数据更新，保证视觉上的页面流程度。\nhttp 部分 http 缓存 分为 强缓存 和 协商缓存，如果同时存在，强缓存 优先 协商缓存\n强缓存： 响应头 Expires：Fri, 31 Dec 2024 23:59:59 GMT，在这个时间之前，直接读缓存，否则请求新内容，因为值是一个服务端返回的时间，这是 http 1.0 的产物，如果客户端和服务端时间不一致，就会和预期不符，所以在 http 1.1 中新增 Cache Control 来控制缓存 Cache Control：max-age=x 秒，在 x 秒内直接读缓存，避免了 expires 时间不一致问题 Cache Control 其他的 value：\nPrivate: 私有缓存，资源可以仅可以被客户端缓存（默认值） Public: 资源可以被任何缓存（包括中间代理服务器）缓存 No-Cache: 协商缓存 No-Store: 绝对不缓存 Max-Age：强缓存 协商缓存 （Last-Modified 优先 ETag） 当 Cache Control 设置为 No-Cache 时使用\nLast-Modified / If-Modified-Since：服务器会返回上次修改时间 Last-Modified，浏览器下次请求时请求头会带上 If-Modified-Since ，然后由服务端验证，如果 If-Modified-Since 在 Last-Modified 时间以内 ，就返回 304，浏览器读缓存，否则返回新内容 ETag / If-None-Match：服务器会返回内容 hash ETag 响应头，浏览器下次请求时请求头会带上 If-None-Match ，然后由服务端验证，如果一致，就返回 304，浏览器读缓存，否则返回新内容 附上一张说明图：\nhttps 握手 https 是 http 的安全扩展，相当于 HTTP + SSL(TLS) = HTTPS。SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层即网络层，TLS 是 SSL 的新版本，最后一个 SSL 3.0 版本在 2015 年废弃，之后就是 TLS，现在常见的 TLS 版本是 1.2 和 1.3 版本。那么 TLS 是如何实现的呢？\n浏览器 =\u0026gt; 服务器：请求发起，建立 SSL 连接，发送 TLS 协议版本号 + 支持的加密方法列表 + 客户端随机数 服务器 =\u0026gt; 浏览器：判断加密协议版本是否一致，并确认加密方法，都没问题则返回服务器证书 + 服务端随机数 浏览器 =\u0026gt; 服务器：收到服务器证书，检查颁发机构、过期时间、域名，没有问题，则生成一个字符串（通过上面 客户端随机数 + 服务端随机数 生成），并用公钥（从服务器证书里取出）加密（非对称加密），发给服务器 服务器 =\u0026gt; 浏览器：服务器用自己的私钥解密，得到这个字符串，后续使用这个字符串进行对称加密进行通信 http1.1长连接和http2多路复用区别 http1.1 长连接 同一个域名访问同一个文件的多个请求都可以复用一个 tcp 连接（不用像 1.0 一样 每次请求都需要重新建立连接，但不是并行，只能按顺序执行。\nhttp2 多路复用 同一个域名访问多个文件的多个请求也可以复用一个 tcp 连接，且多个请求可以被并行处理。\n其他 npmRun 会自动到 package.json 找到对应的命令执行。如果没有全局命令，会自动到node_modules/.bin/下找到对应可执行文件执行，这时npm run xxx等同于直接调用/images/node_modules/.bin/xxx\ncookie 的几种属性和作用 name: 名字 value: 值 domain: 可以访问此 cookie 的域名 path: 可以访问此 cookie 的路径 sameSite: 跨站点携带 cookie 设置 None：不限制； Lax：默认值，介于 None 和 Strict 之间，会合理判断携带 cookie 时机，如链接 a 会携带 cookie； Strict：完全禁止跨站点传送 cookie； httponly: 值为 true 则仅在 http 请求中会传递 cookie，不可用 document.cookie 等操作获取 secure: 是否只能使用 https 传递此 cookie expires: 过期时间；值是时间意思是到这个时间，cookie 失效，否则是 session，即退出浏览器后自动失效 输入 url 到页面展示经历了什么 dns 解析：按照这个步骤查询，找到 ip，立即中断返回给客户端（浏览器缓存 =\u0026gt; 操作系统缓存(host) =\u0026gt; 路由器缓存 =\u0026gt; 本地服务器缓存 =\u0026gt; isp dnf 服务器查询 =\u0026gt; 根 dns 服务器）\ntcp 三次握手\n发送 http 请求报文：报文包括：请求行，请求头，请求体\n服务端接收到请求： 进入 web 服务器，如 apache、nginx，然后进入后台程序\n服务器响应报文：报文包括：响应行，响应头，响应体\n浏览器渲染页面\n根据 html 得到 dom 树 根据 css 得到 css 树 根据 dom 树和 css 树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 数据传送完成，四次挥手关闭：\n懒加载 页面中一些大资源加载较慢，比如 iframe，img。针对这个问题可以通过懒加载解决。\n拿img举例，先设置img的src属性为一个默认的资源，然后把真实url放在标签的某个属性中。并设置好图片的宽高，避免完成加载时出现页面闪动问题。\n然后实时监听页面滚动，如果当前图片是可见状态，那么把图片的真实 url 属性值取出替换到默认src上来实现加载图片资源，从而提升页面打开速度和合理使用客户端流量。\n// 获取浏览设备的网页可视高度 let clientHeight = document.documentElement.clientHeight; // 获取已被滚出的页面高度 let scrollTop = document.documentElement.scrollTop; // 图片顶部到网页顶部的高度 let imgOffsetTop = document.querySelector(\u0026#34;img\u0026#34;).offsetTop; // 判断img在可视区域内： imgOffsetTop \u0026lt; clientHeight + scrollTop; commonjs 模块和 es6 模块有什么区别 commonjs:\n对于基本数据类型，是值的拷贝 对于复杂数据类型，是浅拷贝，也就是修改一个模块的值，引用他的值也会发生改变 第一次加载模块会缓存，往后再加载会读取缓存的数据 es6：\n所有数据都是只读引用，当遇到 import 语句时，会生成一个只读引用，等到文件中真的使用到模块中的值时，根据只读引用，到加载中的模块取值 不允许修改模块中的数据，并且是动态的，比如模块中的值发生改变，引入得到的值也会改变。 前端优化 静态资源放在 cdn 首屏加载服务端渲染 可以升级到 http2，可以使用 http2 多路复用 多个请求并行，可以打乱顺序，最后重组 使用字体图标替代图片 gzip 压缩 uglify plugin 优化压缩代码 图片懒加载 图片压缩，优先使用 webp 减少重排，多使用类名或者 csstext 处理样式 多使用 flex，性能优，兼容性好 常见算法介绍 二分查找：也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。\n贪心算法：又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），贪图眼前局部的利益最大化。\n回溯算法：实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。\n分治算法：分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。\n动态规划：动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。\nbabel 工作原理 在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。简单来说就是一种描述源代码的结构，用于被计算机识别到，并成语言引擎执行\n工作原理大致可以理解成，字符串输入=\u0026gt;转换=\u0026gt;输出\n根据 babylon 解析器，把 js 代码按照规范解析成 AST 语法树 按照规则(stage-0,1,2,3),修改 AST 语法树，常见把高级语法，转换成低级语法 最后通过 babel-generator 将修改后的 AST 语法树转换成 js 代码 ","permalink":"http://localhost:1313/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","summary":"\u003c!-- [HTML 和 CSS 部分](#HTML和CSS)\n\n- [BFC](#BFC)\n- [重排和重绘](#重排和重绘)\n- [行内元素特点](#行内元素特点)\n- [实现换肤功能](#实现换肤功能)\n- [link 和@import 区别](#link和@import区别)\n- [为什么要使用 css 预处理语言](#为什么要使用css预处理语言)\n- [src 和 href 的区别](#src和href的区别)\n\n[js 部分](#js部分)\n\n- [箭头函数和普通函数区别](#箭头函数和普通函数区别)\n\n- [script 的 defer 和 async 属性区别](#script的defer和async属性区别)\n- [深拷贝](#深拷贝)\n- [函数防抖和节流](#函数防抖和节流)\n- [继承](#继承)\n- [跨域](#跨域)\n- [数组方法](#数组方法)\n- [字符串方法](#字符串方法)\n- [js 垃圾回收机制](#js垃圾回收机制)\n- [类型检测](#类型检测)\n- [valueOf 和 toString](#valueOf和toString)\n- [proxy 和 reflect](#proxy和reflect)\n- [requestAnimationFrame](#requestAnimationFrame)\n- [事件循环](#事件循环)\n- [迭代器和生成器](#迭代器和生成器)\n- [事件委托与冒泡和捕获](#事件委托与冒泡和捕获)\n- [实现 instanceof](#实现instanceof)\n- [constructor 和 super 关键字](#constructor和super关键字)\n\n[vue 部分](#vue部分)\n\n- [vue 组件通信](#vue组件通信)\n- [vue 生命周期父子组件执行顺序](#vue生命周期父子组件执行顺序)\n- [前端路由](#前端路由)\n- [slot 插槽](#slot插槽)\n- [keep-alive](#keep-alive)\n- [nextTick](#nextTick)\n- [mixin](#mixin)\n- [vuex](#vuex)\n\n[react 部分](#深拷贝)\n\n- [react 生命周期](#react生命周期)\n- [react 数据响应式](#react数据响应式)\n\n[http 部分](#http部分)\n\n- [http 缓存](#http缓存)\n- [https 握手](#https握手)\n- [http1.1 长连接和 http2 多路复用区别](#http1-1长连接和http2多路复用区别)\n\n[其他](#其他)\n\n- [npm run](#npmRun)\n- [cookie 的几种属性和作用](#cookie的几种属性和作用)\n- [输入 url 到页面展示经历了什么](#输入url到页面展示经历了什么)\n- [懒加载](#懒加载)\n- [commonjs 模块和 es6 模块有什么区别](#commonjs模块和es6模块有什么区别)\n- [前端优化](#前端优化)\n- [常见算法介绍](#常见算法介绍)\n- [babel 工作原理](#babel工作原理) --\u003e\n\u003ch1 id=\"html-和-css\"\u003eHTML 和 CSS\u003c/h1\u003e\n\u003ch2 id=\"bfc\"\u003eBFC\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。\u003c/p\u003e","title":"前端面试题总结"},{"content":"diff 算法 和 virtual dom 在现代 mvvm 框架 react 和 vue 中，因为直接操作 dom 相对是要耗费更多性能的，所以 react 和 vue 都使用了 virtual dom 来替代处理 dom，大致的过程是：按照 dom 结构生成一份 virtual dom 为对象结构。如果数据有更新，需要表现在 dom 上，那么先把变化表现在 virtual dom，再通过 diff 算法比对数据更新前后两次 virtual dom 找到差别。最后把仅仅改变的这部分更新到 dom 上，不用重新渲染整个页面。\n总结：diff 算法就是找到两个 virtual dom 树结构的不同\ndiff 原理 首先传入新旧 vnode 到 patch 函数开始比较:\nfunction patch(oldVnode, vnode) { if (sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode); // 如果两个vnode值得比较，调用patchVnode } else { const oEl = oldVnode.el; // oldVnode.el为对应的真实dom元素 let parentEle = api.parentNode(oEl); createEle(vnode); // 按照vnode结构创建真实dom插入父元素，直接替换oldVnode if (parentEle !== null) { api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)); api.removeChild(parentEle, oldVnode.el); oldVnode = null; } } return vnode; } 首先使用 sameVnode 方法判断两个 vnode 是否值得比较，代码如下\nfunction sameVnode(oldVnode, vnode) { // key代表当前节点数据的key属性，大概的意思就是div和span为不同标签。p.class1和p.class2为不同标签 return vnode.key === oldVnode.key \u0026amp;\u0026amp; vnode.sel === oldVnode.sel; } 一致就按照上步骤，继续往下处理。执行 patchVnode 方法，如不一致，直接用新元素 直接替换 到旧元素。\n如果两个 vnode 值得比较，调用 patchVnode:\npatchVnode (oldVnode, vnode) { const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return // 引用相同，就说明相同，直接return if (oldVnode.text !== null \u0026amp;\u0026amp; vnode.text !== null \u0026amp;\u0026amp; oldVnode.text !== vnode.text) { // 如果有文本内容，比较，如果不同直接设置，用新的替换旧的文本 api.setTextContent(el, vnode.text) }else { updateEle(el, vnode, oldVnode) if (oldCh \u0026amp;\u0026amp; ch \u0026amp;\u0026amp; oldCh !== ch) { // 如果都有子节点，且不同，开始比较子节点 updateChildren(el, oldCh, ch) }else if (ch){ // 如果只有新vnode上有子节点，直接新建 createEle(vnode) }else if (oldCh){ // 如果新vnode没子子节，而老vnode有，则删除老节点的子节点 api.removeChildren(el) } } } 如果都有子节点，且不同，开始比较子节点，调用 updateChildren 函数开始比较子节点:\nupdateChildren (parentElm, oldCh, newCh) { // parentElm：真是dom节点。oldCh：老vnode的所有子节点。newCh：新vnode的所有子节点。 // 通过下标，设置新旧vnode的前后两个元素， let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] // 设置一些比较过程需要的变量 let oldKeyToIdx let idxInOld let elmToMove let before // 两对节点，分别从头和尾向中间循环靠拢依次比对，如果起始下标大于结尾下标，证明比对结束，作为循环结束条件 while (oldStartIdx \u0026lt;= oldEndIdx \u0026amp;\u0026amp; newStartIdx \u0026lt;= newEndIdx) { if (oldStartVnode == null) { //对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] }else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx] }else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx] }else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] }else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newEndVnode)) { patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldEndVnode, newStartVnode)) { patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] }else { // 使用key时的比较 if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 } idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] } else { elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) }else { patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) } newStartVnode = newCh[++newStartIdx] } } } if (oldStartIdx \u0026gt; oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) }else if (newStartIdx \u0026gt; newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) } } 总结：\n调用 patch：传入 新旧vnode，调用 sameVnode，返回 true 说明值得比较，则调用 patchVnode，否则直接使用新节点替换旧节点\n调用 patchVnode：更详细的对比新旧 vnode，分几种情况：\n1: 对于新旧 vnode 的.el 真实 dom 属性，并对比，如果===那就证明是同一个，直接 return 2: 如果存在文本节点，直接用新 vnode 内文本替换旧 vnode 文本 3: 判断子节点，如果新 vnode 有，旧 vnode 没有，则直接把新 vnode 的子节点加入到真实 dom，相反就删除掉真实 dom 子节点 4: 如果都有子节点，且不同，调用 updateChildren，详细对比 调用 updateChildren： 从两边向中间收拢循环两个新旧 vnode 的每个子节点，以此对比，头头，尾尾，头尾，尾头。如果这四种比对调用 sameVnode，得到 true，证明值得对比，那么就调用第二步骤的 patchVnode 递归继续比，除了这四种情况。如果有 key，则会对比 key。否则直接替换新元素到真实 dom。\n","permalink":"http://localhost:1313/blogs/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"diff-算法-和-virtual-dom\"\u003ediff 算法 和 virtual dom\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"WechatIMG3177.png\" loading=\"lazy\" src=\"/images/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/HrGjhDp8ebSt62R.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在现代 \u003ccode\u003emvvm\u003c/code\u003e 框架 \u003ccode\u003ereact\u003c/code\u003e 和 \u003ccode\u003evue\u003c/code\u003e 中，因为直接操作 dom 相对是要耗费更多性能的，所以 \u003ccode\u003ereact\u003c/code\u003e 和 \u003ccode\u003evue\u003c/code\u003e 都使用了 \u003ccode\u003evirtual dom\u003c/code\u003e 来替代处理 dom，大致的过程是：按照 dom 结构生成一份 \u003ccode\u003evirtual dom\u003c/code\u003e 为对象结构。如果数据有更新，需要表现在 dom 上，那么先把变化表现在 \u003ccode\u003evirtual dom\u003c/code\u003e，再通过 \u003ccode\u003ediff\u003c/code\u003e 算法比对数据更新前后两次 \u003ccode\u003evirtual dom\u003c/code\u003e 找到差别。最后把仅仅改变的这部分更新到 dom 上，不用重新渲染整个页面。\u003c/p\u003e","title":"vue中的diff算法实现"},{"content":"promise 类 class Pro { callbacks = []; state = \u0026#34;pending\u0026#34;; value = null; constructor(fn) { // 初始化，把resolve作为参数传入，等待调用 fn(this.resolve.bind(this)); } // callback为回调，先注册，也就是放入callbacks数组中 then(callback) { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(callback); } else { // 由于state不是pending, 遵循promise状态只能改一次的要求，我们直接操作回调传入参数执行 callback(this.value); } return this; } // resolve也就是fn的第一次参数，循环执行所有callback resolve(value) { this.state = \u0026#34;fulfilled\u0026#34;; // setTimeout使内部变成异步，在同步执行完最后执行这里，处理fn是同步的情况下then中的回调函数已经注册，然后在这里去执行，不会出现callbacks是空数组的情况 setTimeout(() =\u0026gt; { this.value = value; this.callbacks.forEach((callback) =\u0026gt; callback(value)); }); } } 使用 new Pro((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(0); resolve(\u0026#34;resolve\u0026#34;); }, 2000); }) .then((tip) =\u0026gt; { console.log(1); console.log(tip); }) .then((tip) =\u0026gt; { console.log(2); console.log(tip); }); promise.all 实现 Promise.prototype.all = function (promises) { let results = []; let promiseCount = 0; let promisesLength = promises.length; return new Promise(function (resolve, reject) { for (let item of promises) { // 执行每个item Promise.resolve(item).then( function (res) { promiseCount++; // 按照顺序插入结果 results[i] = res; // 如果全部执行成功，返回成功 if (promiseCount === promisesLength) { return resolve(results); } }, function (err) { return reject(err); } ); } }); }; promise.race 实现 Promise.prototype.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (let item of promises) { Promise.resolve(item) .then((res) =\u0026gt; { return resolve(res); }) .catch((err) =\u0026gt; { return reject(err); }); } }); }; 简单来说就是声明 promise 时，会执行 promise 第一个函数参数和 then 的参数函数。 then 用来把回调传入 callback 数组中，相当于注册，规定好了 reslove 时，回调的执行，然后等待 resolve 调用，resolve 就会把 callback 数组中的函数全部执行\nthen 中 return this，用于实现 then 的链式调用 如果 promise 是同步的，则执行 resolve 的时候 callback 还没注册 ","permalink":"http://localhost:1313/blogs/promise%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"promise-类\"\u003epromise 类\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePro\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;pending\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003efn\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 初始化，把resolve作为参数传入，等待调用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003efn\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ebind\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// callback为回调，先注册，也就是放入callbacks数组中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;pending\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// 由于state不是pending, 遵循promise状态只能改一次的要求，我们直接操作回调传入参数执行\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// resolve也就是fn的第一次参数，循环执行所有callback\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;fulfilled\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// setTimeout使内部变成异步，在同步执行完最后执行这里，处理fn是同步的情况下then中的回调函数已经注册，然后在这里去执行，不会出现callbacks是空数组的情况\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003esetTimeout\u003c/span\u003e(() =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecallbacks\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003ecallback\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"使用\"\u003e使用\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePro\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003esetTimeout\u003c/span\u003e(() =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;resolve\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }, \u003cspan style=\"color:#ae81ff\"\u003e2000\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  .\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  })\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  .\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003etip\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  });\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"promiseall-实现\"\u003epromise.all 实现\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePromise.\u003cspan style=\"color:#a6e22e\"\u003eprototype\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eall\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresults\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromiseCount\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromisesLength\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Promise(\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// 执行每个item\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      Promise.\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003epromiseCount\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 按照顺序插入结果\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#a6e22e\"\u003eresults\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 如果全部执行成功，返回成功\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003epromiseCount\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromisesLength\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eresults\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"promiserace-实现\"\u003epromise.race 实现\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePromise.\u003cspan style=\"color:#a6e22e\"\u003eprototype\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003erace\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Promise((\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epromises\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Promise.\u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        .\u003cspan style=\"color:#a6e22e\"\u003ethen\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresolve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        })\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        .\u003cspan style=\"color:#66d9ef\"\u003ecatch\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereject\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e简单来说就是声明 promise 时，会执行 promise 第一个函数参数和 then 的参数函数。\n\u003ccode\u003ethen\u003c/code\u003e 用来把回调传入 callback 数组中，相当于注册，规定好了 reslove 时，回调的执行，然后等待 resolve 调用，resolve 就会把 callback 数组中的函数全部执行\u003c/p\u003e","title":"promise的实现"},{"content":"index.html 部分 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;v\u0026#34; /\u0026gt; {{v}} \u0026lt;button @click=\u0026#34;reset\u0026#34;\u0026gt;重置\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const vm = new Mvvm({ el: \u0026#34;#app\u0026#34;, data: { v: \u0026#34;hello world\u0026#34;, }, methods: { reset() { this.v = \u0026#34;\u0026#34;; }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; index.js 部分 class Mvvm { constructor(options) { const { el, data, methods } = options; this.methods = methods; this.target = null; // 监听this[data的key]所有属性，让变化可追踪 this.observe(this, data); // dom解析：提取{{}}、v-model、事件重写：@click this.compile(document.querySelector(el)); } // 数据变化监听 observe(_this, data) { Object.keys(data).forEach((key) =\u0026gt; { let val = data[key]; Object.keys(data).forEach((key) =\u0026gt; { // 如果val是数组或者对象，使用递归实现深层监听，直到val为简单数据类型。从而保证所有属性变化都被监听 if (typeof val === \u0026#34;object\u0026#34;) { return this.observe(_this, val); } // dispatcher用来操作订阅者(watcher) add 或者 update。要配合Object.defineProperty的get和set来使用 const dispatcher = new Dispatcher(); Object.defineProperty(_this, key, { get: function () { console.log(\u0026#34;get\u0026#34;); // this.target会在compile方法中出现，把this.target(一个watcher)添加到dispatcher(将要更新的watcher的列表)中，用于未来更新这个watcher对应的dom dispatcher.add(this.target); return val; }, set: function (newV) { // 值无变化，不处理 if (newV === val) { return; } console.log(`set`); val = newV; // 因为set了，值发生变化了，所以要通知get中添加的所有订阅者(watcher)：你们要把对应的dom中使用的值更新成newV dispatcher.notify(newV); }, }); }); }); } // dom解析 compile(dom) { const childs = dom.childNodes; for (const node of childs) { // nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp if (node.nodeType === 1) { const attrs = node.attributes; for (const attr of attrs) { if (attr.name === \u0026#34;v-model\u0026#34;) { const name = attr.value; // 放到订阅者列表中 this.target = new Watcher(node, \u0026#34;input\u0026#34;); // this[name]是为了触发observe的get，才会被监听 this[name]; // 由于是demo，假设只有input一种情况，input就会有双向绑定。使用this[name], 并且赋值input的值，来触发observe的get。实现更新信息的发布 node.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { this[name] = e.target.value; }); } // 使用bind传递this。并代理click事件函数到@click上。这里仅拿click事件实现，实际会有多种事件 if (attr.name === \u0026#34;@click\u0026#34;) { const name = attr.value; node.addEventListener(\u0026#34;click\u0026#34;, this.methods[name].bind(this)); } } } // nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp if (node.nodeType === 3) { // 正则匹配{{}} const reg = /\\{\\{(.*)\\}\\}/; const match = node.nodeValue.match(reg); if (match) { const name = match[1].trim(); // 放到订阅者列表中 this.target = new Watcher(node, \u0026#34;text\u0026#34;); // this[name]是为了触发observe的get，才会被监听 this[name]; } } } } } // 发布者 class Dispatcher { constructor() { this.watchers = []; } // 增加订阅者 add(watcher) { this.watchers.push(watcher); } // 通知所有订阅者更新 notify(value) { this.watchers.forEach((item) =\u0026gt; { item.update(value); }); } } // 订阅者 class Watcher { constructor(node, type) { this.node = node; this.type = type; } update(value) { // 区别dom类型来赋值 if (this.type === \u0026#34;input\u0026#34;) { this.node.value = value; } if (this.type === \u0026#34;text\u0026#34;) { this.node.nodeValue = value; } } } 解释 vue 在初始化后，执行 Observe 函数把 data 利用 Object.defineProperty 属性监听。同时也会使用 Compile 函数循环 dom，提取 vue 相关的关键字，v-bind 或者 v-model，找到这些值，新建一个 Watcher 实例，然后手动 get 使这些 watch 放入 dep 列表中等待订阅。等待调用 Observer 的 set (input 事件，或者手动赋值)，然后通知 dep 中所有 Watcher 调用 update 方法。\n","permalink":"http://localhost:1313/blogs/vue%E5%8E%9F%E7%90%86mvvm%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"indexhtml-部分\"\u003eindex.html 部分\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;!DOCTYPE html\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003ehtml\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elang\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;en\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ehead\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003emeta\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echarset\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UTF-8\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003emeta\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;viewport\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econtent\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003etitle\u003c/span\u003e\u0026gt;Document\u0026lt;/\u003cspan style=\"color:#f92672\"\u003etitle\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ehead\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebody\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;app\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003einput\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev-model\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;v\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {{v}}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e@\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eclick\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;reset\u0026#34;\u003c/span\u003e\u0026gt;重置\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebutton\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;./index.js\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evm\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMvvm\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eel\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;#app\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;hello world\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003ereset\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebody\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ehtml\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"indexjs-部分\"\u003eindex.js 部分\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMvvm\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eoptions\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eel\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e } \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eoptions\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 监听this[data的key]所有属性，让变化可追踪\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobserve\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// dom解析：提取{{}}、v-model、事件重写：@click\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecompile\u003c/span\u003e(document.\u003cspan style=\"color:#a6e22e\"\u003equerySelector\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eel\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 数据变化监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eobserve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003e_this\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object.\u003cspan style=\"color:#a6e22e\"\u003ekeys\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Object.\u003cspan style=\"color:#a6e22e\"\u003ekeys\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 如果val是数组或者对象，使用递归实现深层监听，直到val为简单数据类型。从而保证所有属性变化都被监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003etypeof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;object\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobserve\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003e_this\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// dispatcher用来操作订阅者(watcher) add 或者 update。要配合Object.defineProperty的get和set来使用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edispatcher\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDispatcher\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Object.\u003cspan style=\"color:#a6e22e\"\u003edefineProperty\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003e_this\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e, {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e () {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;get\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// this.target会在compile方法中出现，把this.target(一个watcher)添加到dispatcher(将要更新的watcher的列表)中，用于未来更新这个watcher对应的dom\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#a6e22e\"\u003edispatcher\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#a6e22e\"\u003eset\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 值无变化，不处理\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e`set`\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 因为set了，值发生变化了，所以要通知get中添加的所有订阅者(watcher)：你们要把对应的dom中使用的值更新成newV\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#a6e22e\"\u003edispatcher\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enotify\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enewV\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// dom解析\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003edom\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echilds\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edom\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003echildNodes\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echilds\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeType\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattrs\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eattributes\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eof\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattrs\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;v-model\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 放到订阅者列表中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWatcher\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// this[name]是为了触发observe的get，才会被监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 由于是demo，假设只有input一种情况，input就会有双向绑定。使用this[name], 并且赋值input的值，来触发observe的get。实现更新信息的发布\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddEventListener\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e, (\u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 使用bind传递this。并代理click事件函数到@click上。这里仅拿click事件实现，实际会有多种事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;@click\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eattr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddEventListener\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;click\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emethods\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003ebind\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#75715e\"\u003e// nodeType 参考 https://www.w3school.com.cn/jsref/prop_node_nodetype.asp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeType\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 正则匹配{{}}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereg\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e/\\{\\{(.*)\\}\\}/\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeValue\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ereg\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ematch\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// 放到订阅者列表中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWatcher\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#75715e\"\u003e// this[name]是为了触发observe的get，才会被监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e          \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 发布者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDispatcher\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewatchers\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 增加订阅者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ewatcher\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewatchers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ewatcher\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// 通知所有订阅者更新\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003enotify\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewatchers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003eitem\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eupdate\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 订阅者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWatcher\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003econstructor\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eupdate\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 区别dom类型来赋值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003enodeValue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解释\"\u003e解释\u003c/h2\u003e\n\u003cp\u003evue 在初始化后，执行 \u003cstrong\u003eObserve\u003c/strong\u003e 函数把 data 利用 \u003cstrong\u003eObject.defineProperty\u003c/strong\u003e 属性监听。同时也会使用 \u003cstrong\u003eCompile\u003c/strong\u003e 函数\u003cstrong\u003e循环 dom\u003c/strong\u003e，提取 vue 相关的关键字，v-bind 或者 v-model，找到这些值，新建一个 \u003cstrong\u003eWatcher\u003c/strong\u003e 实例，然后手动 get 使这些 watch 放入 dep 列表中等待订阅。等待调用 \u003cstrong\u003eObserver\u003c/strong\u003e 的 \u003cstrong\u003eset\u003c/strong\u003e (input 事件，或者手动赋值)，然后通知 dep 中所有 \u003cstrong\u003eWatcher\u003c/strong\u003e 调用 \u003cstrong\u003eupdate\u003c/strong\u003e 方法。\u003c/p\u003e","title":"vue原理mvvm实现"},{"content":"环境 macos 10.14 iterm 2 使用 生成密钥 keytool -genkeypair -alias \u0026lt;别名\u0026gt; -keystore \u0026lt;密钥库存储位置和名称\u0026gt;\nkeytool -genkeypair -alias demokey -keystore demo.keystore 内容填写后，生成完毕\n生成签名 jarsigner -verbose -keystore \u0026lt;使用密钥库位置\u0026gt; -signedjar \u0026lt;签名后的包保存位置和名字\u0026gt; \u0026lt;要签名的包保存位置和名字\u0026gt; \u0026lt;别名，对应上面的别名\u0026gt;\njarsigner -verbose -keystore /Users/liangqi/Desktop/apk/demo.keystore -signedjar ./tap_signed.apk ./tap_unsign.apk demokey 即可拿到签名后的包\n","permalink":"http://localhost:1313/blogs/%E4%BD%BF%E7%94%A8jarsigner%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8Dapk%E5%8C%85/","summary":"\u003ch2 id=\"环境\"\u003e环境\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003emacos 10.14\u003c/li\u003e\n\u003cli\u003eiterm 2\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"使用\"\u003e使用\u003c/h2\u003e\n\u003ch3 id=\"生成密钥\"\u003e生成密钥\u003c/h3\u003e\n\u003cp\u003ekeytool -genkeypair -alias \u0026lt;别名\u0026gt; -keystore \u0026lt;密钥库存储位置和名称\u0026gt;\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekeytool -genkeypair -alias demokey -keystore demo.keystore\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e内容填写后，生成完毕\u003c/p\u003e\n\u003ch3 id=\"生成签名\"\u003e生成签名\u003c/h3\u003e\n\u003cp\u003ejarsigner -verbose -keystore \u0026lt;使用密钥库位置\u0026gt; -signedjar \u0026lt;签名后的包保存位置和名字\u0026gt; \u0026lt;要签名的包保存位置和名字\u0026gt; \u0026lt;别名，对应上面的别名\u0026gt;\u003c/p\u003e","title":"使用jarsigner重新签名apk包"},{"content":"防抖（debounce） 什么是防抖？ 一个函数被触发n秒后，才执行此函数 如果n秒内再次触发此函数，那么重新以再次触发的时间开始重新延迟 n 秒后执行此函数 这样的函数 执行行为 叫做函数防抖。\n应用场景 监听设备窗口大小发生改变，只有停止改变后的200ms执行handleResize方法\nwindow.addEventListener(\u0026#34;resize\u0026#34;, debounce(handleResize, 200)); 监听表单填写，表达内容改变都去请求服务端数据，在每次表单执行输入停止的500ms后，才发起请求\ninput.addEventListener(\u0026#34;change\u0026#34;, debounce(handleRequest, 500)); 代码实现 function debounce(event, delay) { let timer = null; return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理 timer = setTimeout(() =\u0026gt; { event.apply(this, args); }, delay); }; } 节流（throttle） 什么是节流？ 单位时间内多次触发函数，函数只进行一次执行 如果在这个单位时间内，多余的触发，全部不做处理。使函数按照规定的速率执行 这样的函数 执行行为 叫做函数节流。\n应用场景 滚动事件，持续滚动，间隔200ms执行\ndom.addEventListener(\u0026#34;scroll\u0026#34;, throttle(handleScroll, 200)); 鼠标滑动事件，一秒钟大概可以执行60次。使用节流函数优化，200ms执行一次。如果不做节流处理，可想而知浏览器压力有多大\ndom.addEventListener(\u0026#34;mousemove\u0026#34;, throttle(handleMove, 200)); 代码实现 function throttle(fun, delay) { let prev = Date.now(); return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 let now = Date.now(); if (now - prev \u0026gt;= delay) { fun.apply(this, args); prev = Date.now(); } }; } ","permalink":"http://localhost:1313/blogs/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","summary":"\u003ch2 id=\"防抖debounce\"\u003e防抖（debounce）\u003c/h2\u003e\n\u003ch3 id=\"什么是防抖\"\u003e什么是防抖？\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e一个函数被触发\u003ccode\u003en\u003c/code\u003e秒后，才执行此函数\u003c/li\u003e\n\u003cli\u003e如果\u003ccode\u003en\u003c/code\u003e秒内再次触发此函数，那么重新以再次触发的时间开始重新延迟 n 秒后执行此函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样的函数 \u003cstrong\u003e执行行为\u003c/strong\u003e 叫做函数防抖。\u003c/p\u003e","title":"函数的防抖和节流"},{"content":"flex 布局概念 flex布局通常被叫做flex box，也叫弹性盒子或容器，是一种一维的布局模型，它能子元素(flex item)之间提供了强大的空间分布和对齐能力。\nflex容器中存在两个轴，一个水平方向main axis，一个竖直方向cross axis，这是flex布局最重要的点，内部元素flex item都是根据这个轴来排列对齐的。\nflex 布局好处 在一个html元素和内部多个子元的组合中。要实现子元素有序的，高度自定义的布局，在传统布局方式中，会使用position，float方式实现，比如多个子元素在父元素中垂直水平居中，比较困难。这个时候就可以用flex布局，只需要简单几句代码就可以优雅的实现。\nflex 容器属性 设置一个盒子为flex容器，首先设置display: flex;\nflex-direction flex-wrap justify-content align-items align-content flex-direction flex-direction属性规定所有flex item在flex容器从 第一个元素 开始的排列方式\nflex-direction: row(默认) | row-reverse | column | column-reverse; row： 从左往右水平展示\nrow-reverse： 从右向左(反向)水平展示\ncolumn： 从上往下垂直展示\ncolumn-reverse： 从下往上(反向)垂直展示\nflex-wrap flex-wrap属性规定flex容器内所有flex item总宽度超出flex容器时换行方式\nflex-wrap: nowrap(默认) | wrap | wrap-reverse; nowrap： 不换行，只展示一行。如果容器不够宽，平均缩小每个item的宽度\nwrap： 换行，向下换行\nwrap-reverse： 以相反方向换行，向上换行\njustify-content justify-content属性规定所有flex item作为一个整体在flex容器在主轴(默认为水平轴，通过flex-direcation设置)上的排列方式\njustify-content: flex-start(默认值) | flex-end | center | space-between | space-around; flex-start： 整体位于容器开头\nflex-end： 整体位于容器结尾\ncenter： 整体位于容器中心\nspace-between： 每个flex item平均分布在容器内； 第一个item和容器开头，最后一个item和容器结尾都无间距\nspace-around： 每个flex item平均分布在容器内， 第一个item和容器开头，最后一个item和容器结尾的间距都为每个item间距的一半\nalign-items align-items属性规定所有flex item作为一个整体在flex容器在副轴(非主轴，和justify-content相反)上的排列方式\nalign-items: stretch(默认值) | center | flex-start | flex-end | baseline; stretch： 整体占满整个主轴的高度, 前提必须是你没有设置 item 的高度(宽度)，否则不生效\ncenter： 整体位于主轴中心\nflex-start： 整体位于主轴开头\nflex-end： 整体位于主轴结尾\nbaseline： 主轴位于item中第一行文字 基线 对齐\n基线的概念：英文中大概就是一个小写字母 x 的最底部，f 的中下部；而中文大概就汉字中下部，不太准确，我没深入了解，有兴趣可以网上了解。\nalign-content align-content属性规定了多条主轴的情况下(只有item换行了，才会产生多条主轴)，这些主轴作为一个整体在他们的排列方向中的排列方式；注意：只有一条主轴(item不换行)不生效\nalign-content: stretch(默认) | center | flex-start | flex-end | space-between | space-around; stretch： 整体被拉伸以适应容器\ncenter： 整体内各个轴紧靠，并且位于容器中心，头尾留白\nflex-start： 整体内各个轴紧靠，并且位于容器头部\nflex-end： 整体内各个轴紧靠，并且位于容器尾部\nspace-between： 整体平分，其中头尾和容器头尾紧靠，中间间隙平分\nspace-around： 整体平分，其中头尾和容器头尾距离为中间 item 的空隙的一半，中间间隙平分\nflex item 属性 order flex-basis flex-grow flex-shrink align-self order order 属性规定了当前flex item排列前后顺序，越小排列越靠前，可以为负数\norder: 0 (默认值) | \u0026lt;number\u0026gt;; flex-basis flex-basis 属性规定了当前flex item的高度(主轴为水平轴则是高度，如果主轴为竖直轴则是宽度，主轴通过flex-direction设置)的伸缩比例或大小\nflex-basis: auto(默认) | number; number： 可以是具体的像素值，如 30px；也可以是 auto 大小百分比\nflex-grow flex-grow属性 前提在所有项目以flex-basis的值排列完如有剩余空间，则规定当前flex item的高度(主轴为水平轴则是高度，如果主轴为竖直轴则是宽度，主轴通过flex-direction设置)的剩余空间份比例\nflex-grow: 0 (默认值) | \u0026lt;number\u0026gt;; number：当剩余空间足够时，如果值为1那么高度(宽度)放大剩余空间1份，如果只有一个元素设置了此属性，那么剩余全部全部分给他；如果多个元素设置了此属性，比如a:1 b:2 c:3则会把剩余空间分成6份，a 在本身的大小基础上增加剩余空间的1/6份 a 则是2/6份 c 则是3/6份，如果剩余空间不足，则取剩余空间最大值，不支持负数\nflex-shrink flex-shrink属性规定了当剩余空间不足时候，当前flex item的高度(主轴为水平轴则是高度，如果主轴为竖直轴则是宽度，主轴通过flex-direction设置)的缩小超出空间份比例，和上面的flex-grow是相反的，一个放大，一个缩小\nflex-shrink: 1 (默认值) | \u0026lt;number\u0026gt;; number：当剩余空间不足时，默认按照比例 1 缩小，如果值为2那么高度(宽度)缩小超出空间2份\nalign-self flex-shrink属性规定当前flex item作为一个整体在flex容器在副轴(非主轴，和justify-content相反)上的排列方式\n注意：这个属性和align-item的区别是align-item影响全部flex item，而align-self只影响当前flex item\nalign-self: auto(默认值) | stretch | center | flex-start | flex-end | baseline; auto：继承父亲align-item的value\nstretch： 占满整个主轴的高度, 前提必须是你没有设置 item 的高度(宽度)，否则不生效\ncenter： 位于主轴中心\nflex-start： 位于主轴开头\nflex-end： 位于主轴结尾\nbaseline： 位于item中第一行文字 基线 对齐\n扩展一道面试题 实现一个元素包含内部两个元素。当 flex 水平轴为主轴，实现左固定，右自适应：\n\u0026lt;div class=\u0026#34;flex2\u0026#34;\u0026gt; \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; div.flex2 { display: flex; border: 1px solid red; width: 100%; height: 300px; } .flex2 p { width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; font-size: 80px; border: 1px solid blue; } .flex2 p:nth-child(1) { width: 200px; // 左侧元素固定为200px宽 } .flex2 p:nth-child(2) { flex-grow: 1; // 右侧元素自适应 } ","permalink":"http://localhost:1313/blogs/flex%E5%B8%83%E5%B1%80/","summary":"\u003ch2 id=\"flex-布局概念\"\u003eflex 布局概念\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eflex\u003c/code\u003e布局通常被叫做\u003ccode\u003eflex box\u003c/code\u003e，也叫\u003ccode\u003e弹性盒子\u003c/code\u003e或\u003ccode\u003e容器\u003c/code\u003e，是一种一维的\u003ccode\u003e布局模型\u003c/code\u003e，它能子元素(\u003ccode\u003eflex item\u003c/code\u003e)之间提供了强大的空间分布和对齐能力。\u003c/p\u003e","title":"flex布局介绍"},{"content":"什么是函数柯里化 在维基百科中，对函数柯里化有着这样的定义：\n在计算机科学领域，柯里化（Currying）指的是将一个接受多个参数的函数转化为一个仅接受单一参数（即原函数的第一个参数）的函数，并且该函数会返回一个新函数，这个新函数能够接收剩余的参数并最终返回计算结果。\n由此可见，函数柯里化是一种函数变形的思想，它本身并不会直接执行函数，函数柯里化的思想可在多种编程语言中实现，但实现方式因语言而异。上述解释已经十分通俗易懂了。简单来讲，当传入的参数数量不足时，柯里化会借助闭包将当前传入的参数保存起来，然后返回一个新函数。后续这个新函数可以继续被调用以获取更多参数，新传入的参数会与闭包中保存的参数合并。当参数数量达到被柯里化函数的形参数量时，函数就会开始执行；若参数数量仍然不足，则会继续返回新函数来保存参数，如此循环往复。下面以 JavaScript 为例进行说明：\nfunction add(...nums) { return nums.reduce((acc, num) =\u0026gt; acc + num, 0); } // 对该函数进行柯里化处理后，就可以将多个参数拆分成单个或多个参数组合的形式传入，最终得到相同的结果。示例如下： curryingAdd(1)(2)(3)(4); // 结果为 10 // 或者 curryingAdd(1, 2)(3)(4); // 结果为 10 // 又或者 curryingAdd(1)(2, 3, 4); // 结果为 10 柯里化的好处 乍看上述例子，你可能会觉得函数柯里化似乎没什么实际用途，反而让实现过程变得更加复杂。但实际上，它是一种高度抽象的编程规范，属于函数式编程思想的一部分，主要有以下优点：\n参数复用 此外，柯里化还具备“提前确认”和“延迟执行”的特性。“提前确认”强调的是提前固定部分参数，明确函数的部分行为，例如在网络请求中提前确定请求方法；“延迟执行”强调的是函数不会立即执行，而是等所有必要参数都传入后才执行。它们虽然侧重点不同，但都体现了柯里化在灵活控制函数调用上的优势。在我看来，参数复用是函数柯里化最为显著的优势。合理运用这一特性，能够编写出更加优雅的代码，让程序的执行过程更贴合人类解决问题的思维方式。下面通过一段代码来进一步说明：\nfunction ajax(method, url) { // 此处为 HTTP 请求的具体实现代码... console.log(`Sending ${method} request to ${url}`); } function currying(fn, ...args) { if (args.length \u0026gt;= fn.length) { return fn(...args); } else { return (...args2) =\u0026gt; currying(fn, ...args, ...args2); } } // 对 ajax 方法进行柯里化处理 let curryingAjax = currying(ajax); // 得到一个专门用于处理 GET 请求的函数，该操作仅需执行一次 let getAjax = curryingAjax(\u0026#34;get\u0026#34;); // 结合具体业务逻辑，获取用户信息的接口请求 let getUserInfo = getAjax(\u0026#34;http://api.test.com/getUserInfo\u0026#34;); // 结合具体业务逻辑，获取订单列表的接口请求 let getOrderList = getAjax(\u0026#34;http://api.test.com/getOrderList\u0026#34;); // 如果是 post 请求 let postAjax = curryingAjax(\u0026#34;post\u0026#34;); let postData = postAjax(\u0026#34;http://api.test.com/submitData\u0026#34;); 从上述代码可以看出，get 方法仅需传入 curryingAjax 函数一次，后续就可以多次调用 get 请求。先确定请求方法，再确定具体的请求地址，这样就实现了参数的复用。\n柯里化完整代码 柯里化函数 currying 的实现逻辑如下：\n首先判断从 currying 函数的第二个参数开始到最后一个参数（即 args）的长度。若该长度等于被柯里化函数 fn 的形参数量，那么直接执行 fn 函数，并将 args 作为参数传入。 若传入的参数（args）数量不足，就利用递归和闭包的特性，暂时保存已传入的参数，然后重新返回 currying 函数。 function currying(fn, ...args) { if (args.length \u0026gt;= fn.length) { return fn(...args); } else { return (...args2) =\u0026gt; currying(fn, ...args, ...args2); } } // 使用示例 const add = (a, b, c) =\u0026gt; { console.log(a + b + c); }; const currying_add = currying(add); // 不同参数传入方式的结果展示 currying_add(1, 2, 3); currying_add(1)(2, 3); currying_add(1, 2)(3); currying_add(1)(2)(3); ","permalink":"http://localhost:1313/blogs/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","summary":"文章介绍函数柯里化，说明其将多参函数转为单参函数的概念，以 JavaScript 举例阐述原理，讲解参数复用等好处并给出 ajax 请求示例，还提供了完整实现代码及用法","title":"函数柯里化(currying)"},{"content":"冒泡排序（Bubble sort） 原理和演示： 依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。 function bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { if (arr[i] \u0026gt; arr[i + 1]) { let temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } console.log(`执行${i + 1}次`); } return arr; } 通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。\nfunction bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { for (let j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } console.log(`执行${i + 1}次`); } } return arr; } 两个变量互换值可以使用es6的解构语法，省去使用temp缓存，语法为[a, b] = [b, a]，即可交换变量a和变量b的值。复杂数据类型Object和Array都适用；如果第二个循环中的大小判断，一次都没有执行，说明当前这组数据是正序无需排序，用一个变量isOk标记下配合break，实现方法优化。\n完整代码： function bubbleSort(arr) { console.time(\u0026#34;耗时\u0026#34;); for (let i = 0, len = arr.length; i \u0026lt; len - 1; i++) { // 要比对的次数，- 1是因为6个数俩俩比较只需要比对5次 let isOk = true; for (let j = 0; j \u0026lt; arr.length - 1 - i; j++) { // 当前和下一项的每次比较。完整进行一次比较后，最大的值就会在最后一位，- i意味着最大这个值不再需要比对了 if (arr[j] \u0026gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 当前值小于下一项，交换位置 isOk = false; // 如果第一次比较时，没有发现一个有效条件，那么说明整个数组默认就是排好序的 } } if (isOk) { break; } } console.timeEnd(\u0026#34;耗时\u0026#34;); return arr; } 冒泡排序动画演示： 选择排序（Selection Sort） 原理： 循环整个数组，找到最小的值，放在数组第一位(和第一位交换位置）。 从数组第二位开始重新循环，依旧找到最小的值，放在数组第二位，重复此步骤，直到对比完最后一组数据。 完整代码： function selectionSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { // arr.length - 1是因为假定数组中n个数，比较需要两个数，所以只需要比较n-1次 let minIndex = i; // 记录每次循环开始位置，等待和最小值交换位置 for (let j = i + 1; j \u0026lt; arr.length; j++) { // j+1 是避免比较自身，j永远是i的后一项，让他们俩做比较 if (arr[j] \u0026lt; arr[minIndex]) { // 如果后面的值小于前面的值，需要调换他们俩位置 minIndex = j; // 保存最小值的下标 } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // 使用es6的结构语法交换值，把最小值放到数组最前面 } return arr; } 选择排序动画演示： 插入排序（Insertion Sort） 原理： 将数组分成两部分，一部分为已排序(默认为数组第一个元素且只有这一个元素)，另一部分为未排序。 依次从未排序数组中取值，和已排序中的值依次做对比，如果未排序元素比已排序元素中某个元素小，那就将已排序元素向后移一位，使他本来位置变成一个空位，再将待排序数据插入空位。 完整代码： function insertionSort(arr) { let len = arr.length; for (let i = 1; i \u0026lt; len; i++) { // 循环未排序部分, i=1而不是0是因为默认0项为已排序部分 let cur = i; // 每次插入后，arr[i]会发生改变，先存下来 let j = i - 1; while (j \u0026gt;= 0) { // 循环已排序部分，默认数组第一项有且只有第一项，下标范围为(0 - (未排序元素下标-1))，也就是例子中的i-1 if (arr[cur] \u0026lt; arr[j]) { // 如果未排序元素比已排序元素小， [arr[cur], arr[j]] = [arr[j], arr[cur]]; // 交换 cur = j; // 交换后i值变了，那把交换后的i找回来就可以了 } j--; } } return arr; } 插入排序动画演示： 快速排序（Quick Sort） 原理： 选择数组中的一个元素作为基准值，用两个新数组分别存储原数组比基准值大的值，和小的值。 继续递归处理这两个新数组，最终用 concat 合并到一起，效果为：比基准值小的数组+基准值+比基准值小的数组。 快速排序有其它种实现方法，这是一种简单的实现，非原地排序，由于新建了多个新的数组，会增加空间复杂度，好处再于非常容易理解，可读性强，适合面试手写代码。\n完整代码： function quickSort(arr) { if (arr.length \u0026lt;= 1) { return arr; } // 递归边界条件 let pointIdx = Math.floor(arr.length / 2); // 在数组中间位置取一个基准点 let point = arr.splice(pointIdx, 1)[0]; // 通过基准点找到这个值，使用splice原因是：要获取这个基准值的同时要把这个基准值从排序数组里删除掉 let left = []; let right = []; for (let i = 0, len = arr.length; i \u0026lt; len; i++) { if (arr[i] \u0026lt; point) { // 循环数组，小于point的放在left中，大的放在right中 left.push(arr[i]); } else { right.push(arr[i]); } } // 递归，让每一个left和right继续排序，直到left或right只有一项为止 return quickSort(left).concat(point, quickSort(right)); } 快速排序动画演示： 另外说一下，js 的原生提供的 sort 排序方法原理：如果数组长度小于10，使用插入排序，否则使用快速排序。如其名，快速排序的性能还是很好的。\n动画来源：菜鸟教程\n查看例子：GitHub\n","permalink":"http://localhost:1313/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/","summary":"\u003ch2 id=\"冒泡排序bubble-sort\"\u003e冒泡排序（Bubble sort）\u003c/h2\u003e\n\u003ch3 id=\"原理和演示\"\u003e原理和演示：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e依次比较数组中相邻的每一对值，如果前面的值 \u003cstrong\u003e大于\u003c/strong\u003e 后面的值，则交换他们俩的位置。如果数组中\u003ccode\u003e5\u003c/code\u003e个数字(length 为 5)，由于比较 \u003cstrong\u003e两个一组\u003c/strong\u003e 的数字，那么只需要\u003ccode\u003e4次\u003c/code\u003e(length - 1)比较，就可以实现把数组中最大的一个数放到最后。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebubbleSort\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etemp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etemp\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e`执行\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e次`\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，\u003ccode\u003ej\u003c/code\u003e对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数\u003ccode\u003e- 1\u003c/code\u003e也就是下面例子中的\u003ccode\u003e- j\u003c/code\u003e。\u003c/p\u003e","title":"常用4种排序介绍"},{"content":"html \u0026lt;div class=\u0026#34;round\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; css 使用background-image渐变属性和动画状态的伪元素遮盖来实现：\n.round { width: 150px; height: 150px; border-radius: 50%; background-color: #eee; background-image: linear-gradient(to right, transparent 50%, blue 0); position: relative; } .round::before { width: 50%; height: 100%; content: \u0026#34;\u0026#34;; position: absolute; top: 0; left: 50%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; animation: spin 5s linear infinite, dye 10s step-end infinite; } @keyframes spin { to { transform: rotate(0.5turn); } } @keyframes dye { 50% { background: blue; } }s 效果 ","permalink":"http://localhost:1313/blogs/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/","summary":"\u003ch3 id=\"html\"\u003ehtml\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;round\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"css\"\u003ecss\u003c/h3\u003e\n\u003cp\u003e使用\u003ccode\u003ebackground-image\u003c/code\u003e渐变属性和动画状态的\u003ccode\u003e伪元素遮盖\u003c/code\u003e来实现：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.\u003cspan style=\"color:#a6e22e\"\u003eround\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewidth\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e150\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003epx\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eheight\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e150\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003epx\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eborder-radius\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ebackground-color\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e#eee\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ebackground-image\u003c/span\u003e: linear-gradient(\u003cspan style=\"color:#66d9ef\"\u003eto\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eright\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003etransparent\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eblue\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eposition\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003erelative\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.\u003cspan style=\"color:#a6e22e\"\u003eround\u003c/span\u003e::\u003cspan style=\"color:#a6e22e\"\u003ebefore\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ewidth\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eheight\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econtent\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eposition\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eabsolute\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003etop\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eborder-radius\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e%\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ebackground-color\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003einherit\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003etransform-origin\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eanimation\u003c/span\u003e: spin \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003es\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elinear\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einfinite\u003c/span\u003e, dye \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003es\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estep-end\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einfinite\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e@\u003cspan style=\"color:#66d9ef\"\u003ekeyframes\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003espin\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003eto\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003etransform\u003c/span\u003e: rotate(\u003cspan style=\"color:#ae81ff\"\u003e0.5\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eturn\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e@\u003cspan style=\"color:#66d9ef\"\u003ekeyframes\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003edye\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e50\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ebackground\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eblue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\u003cspan style=\"color:#f92672\"\u003es\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"效果\"\u003e效果\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"demo.gif\" loading=\"lazy\" src=\"/images/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/E8CM6WZ1hRv7piy.gif\"\u003e\u003c/p\u003e","title":"使用css实现环状进度"},{"content":" 什么是 swap swap分区是Linux中特殊的一种存储，他在安装系统时被自动创建。\n用于当内存不够时，操作系统会取出内存中不活跃或不常用的一部分放到swap分区中，使内存空闲出一部分空间用于执行其他程序。相当于临时充当一部分内存，当操作系统想要访问swap空间上的的数据时，swap会把数据放回内存中供操作系统使用。\n类似windows中的虚拟内存。每个操作系统都有这种内存调度处理，当内存不够用，还想跑点东西，可以临时选择增加swap空间。以达到实际使用内存超过物理内存。由于swap的读取速度远不如内存，最好的办法还是加物理内存。\nswap 分区类型 swap 文件 swap 分区 速度比较：物理内存 \u0026gt; swap 分区 \u0026gt; swap 文件。\n由于swap分区需要一个新的磁盘，当你的磁盘已经装了不少内容，不方便重新规划的话，也只好使用 swap 文件了。本文使用 swap 文件方式。\n查看 swap 信息 基于 Cent OS 7.6\n使用swapon -s命令查看系统中当前swap信息：\nswapon -s Filename Type Size Used Priority /swapfile file 1048572 199668 -2 Filename：swap 分区/文件所在的位置 Type：swap 类型；partition为分区类型，file为文件类型 Size：总容量，单位是 KB Used：已被使用的容量 Priority：优先级，越高越优先被操作系统使用 若查不到 swap 信息，使用free -h命令，查看内存使用情况：\nfree -h total used free shared buff/cache available Mem: 487M 65M 289M 44K 132M 398M Swap: 1.0G 259M 764M 操作 swap 创建swap文件， fallocate命令可以为文件预分配物理空间，和 touch、vim 的区别就是可瞬间创建超大的文件。快速创建的原因是通过分配块并将它们标记为未初始化，无需对数据块进行 IO，可以快速完成预分配。当使用时再使用物理内存。-l后加大小，可以是 k、m、g。再后面是保存位置和名称。\n# 创建一个1g文件swapfile保存到/ sudo fallocate -l 1G /swapfile 修改权限，仅允许文件所有者进行读写操作：\nsudo chmod 600 /swapfile 将这个文件设为 Linux 交换区：\nsudo mkswap /swapfile 激活交换区：\nsudo swapon /swapfile 修改/etc/fstab，实现系统重启自动加载 swap 文件：\necho \u0026#39;/swapfile none swap sw 0 0\u0026#39; | sudo tee -a /etc/fstab 至此完成 swap 文件增加。使用free -h查看 swap 使用情况：\nfree -h total used free shared buff/cache available Mem: 487M 65M 289M 44K 132M 398M Swap: 1.0G 259M 764M 停止所有 swap：\nsudo swapoff -a # 查看内存使用情况，可以看到 Swap 信息都变成0，说明操作成功了 free -h total used free shared buff/cache available Mem: 487M 261M 92M 484K 134M 201M Swap: 0 0 0 ","permalink":"http://localhost:1313/blogs/linux%E4%B8%AD%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4swap%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","summary":"\u003chr\u003e\n\u003ch2 id=\"什么是-swap\"\u003e什么是 swap\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eswap\u003c/code\u003e分区是\u003ccode\u003eLinux\u003c/code\u003e中特殊的一种存储，他在安装系统时被自动创建。\u003c/p\u003e\n\u003cp\u003e用于当内存不够时，操作系统会取出内存中不活跃或不常用的一部分放到\u003ccode\u003eswap\u003c/code\u003e分区中，使内存空闲出一部分空间用于执行其他程序。相当于临时充当一部分内存，当操作系统想要访问\u003ccode\u003eswap\u003c/code\u003e空间上的的数据时，\u003ccode\u003eswap\u003c/code\u003e会把数据放回内存中供操作系统使用。\u003c/p\u003e","title":"Linux中内存交换空间(swap)的使用"},{"content":"","permalink":"http://localhost:1313/photos/","summary":"","title":"照片"}]