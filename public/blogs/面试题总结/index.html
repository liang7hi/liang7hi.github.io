<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>
<meta name="robots" content="index, follow" />
<title>
  前端面试题总结 | slc3a2
</title>
<meta
  name="keywords"
  content="前端"
/> <meta name="description" content="
HTML 和 CSS
BFC

全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。"> <meta name="author" content=""> <link rel="canonical" href="https://slc3a2.github.io/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
<link
  crossorigin="anonymous"
  href="/assets/css/stylesheet.c405402e2da5eb3c4c1c153b39751b2f1aa6a8e8433b86574ec2c5970f00744d.css"
  integrity="sha256-xAVALi2l6zxMHBU7OXUbLxqmqOhDO4ZXTsLFlw8AdE0="
  rel="preload stylesheet"
  as="style"
/> <link rel="icon" href="https://slc3a2.github.io/favicon.ico"> <link
rel="icon" type="image/png" sizes="16x16" href="https://slc3a2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://slc3a2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://slc3a2.github.io/apple-touch-icon.png"> <link rel="mask-icon" href="https://slc3a2.github.io/safari-pinned-tab.svg"> <meta name="theme-color" content="#2e2e33"> <meta name="msapplication-TileColor" content="#2e2e33"> <link rel="alternate" hreflang="zh" href="https://slc3a2.github.io/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" />
<noscript>
  <style>
    #theme-toggle,
    .top-link {
      display: none;
    }
  </style>
  <style>
    @media (prefers-color-scheme: dark) {
      :root {
        --theme: rgb(29, 30, 32);
        --entry: rgb(46, 46, 51);
        --primary: rgb(218, 218, 219);
        --secondary: rgb(155, 156, 157);
        --tertiary: rgb(65, 66, 68);
        --content: rgb(196, 196, 197);
        --code-block-bg: rgb(46, 46, 51);
        --code-bg: rgb(55, 56, 62);
        --border: rgb(51, 51, 51);
      }

      .list {
        background: var(--theme);
      }

      .list:not(.dark)::-webkit-scrollbar-track {
        background: 0 0;
      }

      .list:not(.dark)::-webkit-scrollbar-thumb {
        border-color: var(--theme);
      }
    }
  </style>
</noscript> <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
      ],
    });
  });
</script>
 
<meta property="og:url" content="https://slc3a2.github.io/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
  <meta property="og:site_name" content="slc3a2">
  <meta property="og:title" content="前端面试题总结">
  <meta property="og:description" content=" HTML 和 CSS BFC 全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2020-12-21T19:06:55+08:00">
    <meta property="article:modified_time" content="2020-12-21T19:06:55+08:00">
    <meta property="article:tag" content="前端">
    <meta property="og:image" content="https://slc3a2.github.io/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/cover.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://slc3a2.github.io/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/cover.jpg">
<meta name="twitter:title" content="前端面试题总结">
<meta name="twitter:description" content="
HTML 和 CSS
BFC

全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "日志",
      "item": "https://slc3a2.github.io/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "前端面试题总结",
      "item": "https://slc3a2.github.io/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "前端面试题总结",
  "name": "前端面试题总结",
  "description": " HTML 和 CSS BFC 全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。\n",
  "keywords": [
    "前端"
  ],
  "articleBody": " HTML 和 CSS BFC 全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。\n如何触发 根元素 body float： right | left position： absolute | fixed display：inline-block | tabel-cells | flex overflow： hidden | auto | scroll 效果 清除浮动，常用 overflow hidde 垂直方向 margin 会重叠 重排和重绘 网页加载过程大致分为 5 步：\nHTML 代码转化成 DOM CSS 代码转化成 CSSOM 结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 其中第 4 步为排列布局，重排指的就是第 4 步重做；第 5 步是绘制，那重绘指的就是第 5 步重做。按照网页加载顺序，第 4 步之后执行第 5 步，所以重排必将触发重绘，而重绘不一定会触发重排。\n重绘：修改元素字体颜色，背景颜色，阴影效果等 重排：位置发生改变，如margin padding width。 删除增加dom 调用offsetHeight等读取实时量值时\n由于重排性能消耗大，那么减少重排次数也就成了一个优化页面的方法，下面总结几个常用方法：\n不要一条一条修改 css，尽量通过 class 修改，或者 csstext 先 display: none; 再修改样式，然后再 display: block; 一个元素大量修改 css，可以设置为 position: fixed | absolute, 这样重排消耗少，因为不用考虑其他元素位置 react vue 虚拟 dom link 和@import 区别 @import属于 css 语法，只能加载 css，link是 html 语法，不仅可以加载 css，还可以加载网站 icon 等\n为什么要使用 css 预处理语言 类似 scss(sass3+)，less 等预处理 css 语言，扩展了 css，具备变量、mixins、函数, 嵌套，带有作用域，支持块注释 //\nsrc 和 href 的区别 src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系。src 加载资源会阻塞页面，href 是加载并行。\nsrc:\n\u003cimg src=\"/img.jpg\" /\u003e \u003cscript src=\"/jquery.js\"\u003e\u003c/script\u003e href:\n\u003clink rel=\"stylesheet\" href=\"/main.css\" /\u003e \u003ca href=\"/\"\u003e\u003c/a\u003e 行内元素特点 可以设置所有方向margin和padding，但是垂直方向无法更改布局 设置width和height属性无效 不会另起一行 实现换肤功能 设置多种颜色类名，覆盖实现 http 请求动态加载 .css 文件 预编译 css 变量 js 部分 箭头函数和普通函数区别 没有自己 this，继承父级的 this 没有自己 arguments // Uncaught ReferenceError: arguments is not defined 没有原型 // undefined script 的 defer 和 async 属性区别 相比于基本的 script 标签、都可以实现异步加载脚本，只是执行脚本的时机不同，\nasync：加载完成后，立即执行，可以在 dom 没完全加载执行，如果多个 script async，那么哪个先加载完就执行哪个，适合加载无依赖的 js defer：加载完成后，等到dom加载完成后执行，如果多个 script defer，会严格按照他们的书写顺序依次执行，适合加载互相依赖的 js 深拷贝 // 冷门深拷贝利用MessageChannel function deepClone(obj) { return new Promise(function (resolve, reject) { var { port1, port2 } = new MessageChannel(); port1.onmessage = function (e) { resolve(e.data); }; port2.postMessage(obj); }); } // 利用weakmap解决了循环引用报错问题，完全版 function deepClone1(_target, map = new WeakMap()) { if (!_target || typeof _target !== \"object\") { return _target; } if (map.get(_target)) { console.log(\"进入map判断\"); console.log(map.get(_target)); return map.get(_target); } let res = Array.isArray(_target) ? [] : {}; console.log(\"map set\"); console.log(_target, res); map.set(_target, res); for (let i in _target) { console.log(\"循环\"); if (typeof _target[i] === \"object\") { console.log(\"是对象\"); res[i] = deepClone1(_target[i], map); } else { console.log(\"不是对象\"); res[i] = _target[i]; } } return res; } 函数防抖和节流 防抖： function debounce(event, delay) { let timer = null; return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理 timer = setTimeout(() =\u003e { event.apply(this, args); }, delay); }; } 节流： function throttle(event, delay) { let prev = Date.now(); return function (...args) { // ...args用来接受fun原有的参数，比如事件就是event对象 let now = Date.now(); if (now - prev \u003e= delay) { event.apply(this, args); prev = Date.now(); } }; } 查看详解\n继承 原型链继承： Cat 继承了 Animal，缺点：所有 Cat 实例都会共享原型链，不可以向 Animal 传参。\nfunction Cat() {} Cat.prototype = new Animal(); call 继承/构造继承: 解决上面原型链建成俩问题，但是只是 Cat 实例，不是 Animal 的实例\nfunction Cat(name) { Animal.call(this); } 组合继承：也就是前面两个方法合并，解决上面两个继承的缺点，唯一的缺点调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\nfunction Cat(name) { Animal.call(this); } Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; //修复构造函数指向 // 优点： // 既是cat实例，又是Animal实例 // 没有共享原型方法问题，并可以传参数 跨域 jsonp： 利用 script 标签跨域，本质是加载一个外部 js\ncors：全程跨域资源共享，服务端操作，把请求头的origin的值取出，响应头会增加Access-Control-Allow-Origin key 并把值设置为origin取出的值也可以是通配符，浏览器就不会拦截响应了，从而解决跨域问题\npostMassage：利用可访问服务资源的iframe，和当前页面互相通信，传递消息，来实现跨域，postMassage本质是两个页面的消息传递方法。\n// 页面1(可以获取后端数据的)传递数据，第二个参数是url匹配规则，可以是通配符 window.frames[0].postMessage(data, \"*\"); // 页面2(不能接收后端数据的)，接收页面1的数据 window.addEventListener(\"message\", function (e) { console.log(e.data); }); 服务器中转： 由于服务端没跨域，服务端代替客户端请求目标接口，并把响应数据返回给客户端\n数组方法 改变原数组 splice: array.splice(index,howmany,item1,…..,itemX) 删除/添加 sort: 排序 unshift: 首加 shift: 首删; pop: 尾删; push: 尾加 reverse: 倒序排列 fill: 数组填充 array .fill(value, startIndex | 0, endIndex | array.length) [(1, 2, 3, 4, 5)].fill(\"a\", 1, 3); // [1, \"a\", \"a\", 4, 5] 不改变原数组，生成新数组 slice: 浅拷贝 array.slice(startIdx, endIdx) join: 转字符串并分割 toLocaleString: 转换成字符串数组 concat: 连接数组 可用…替代 indexOf: 检查下标 includes: 是否包含。可替代 indexOf，indexOf === -1 不够语义化 循环方法 forEach、map、filter every、some、reduce、reduceRight(和 reduce 区别是相反方向) 字符串方法 var str = \"hello world\"; str.charAt(1); //e 返回指定下标的字符 str.charcodeAt(1); //101 返回指定下标字符的字符编码 str.concat(123); // hello world123 连接字符串，生成新的 str.slice(0, 2); // he 截取字符串，参数为下标 str.substring(0, 2); // he 截取字符串，参数为下标 str.substr(0, 2); // he 截取字符串，第一个参数是起始下标，第二个参数为截取数量 str.indexOf(\"h\", 0); // 0 查子字符下标，第一个参数是字符，第二个参数是起始下标 str.lastIndexOf(\"h\", 0); // 0 查子字符下标，第一个参数是字符，第二个参数是结尾下标(和indexof区别) str.toLowerCase(); // hello world 转小写 str.toUpperCase(); // HELLO WORLD 转大写 str.trim(); // 删除前后空格 str.split(\"e\"); // [\"h\", \"llo world\"] 转数组，参数为分割符 str.replace(\"o\", \"a\"); // hella world 替换字符，第一个参数可以是正则 str.match(/hello/g); // [\"hello\"] 匹配字符串返回一个数组，参数常是正则 js 垃圾回收机制 当内存中的数据不需要时候，js 会自动使用垃圾回收算法释放掉\n引用计算 : 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。这是最初级的垃圾收集算法。 该算法有个限制：无法处理引用循环，两个对象互相引用的情况下，引用次数至少是 1，所以不会被回收掉 标记清除 : 此算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法从根（root）全局对象开始先下查找，找到不可以被获得的对象，然后清除掉 类型检测 typeof: 除了基本数据类型，检测不到具体 object 类型(数组，对象，时间对象，正则，set，map) instanceof: 例 a instanceof Fun 原理是检测 a 是不是 Fun 的实例，缺点就是被检测的值必须是引用，如下所示 new Number(1) instanceof Number; // true 1 instanceof Number; // false constructor: 实例.constructor === 构造器，缺点是 constructor 属性容易被修改 Object.prototype.toString.call: 目前最好用的一个方法，缺点是使用 object 构造函数的 toString 方法，此方法可能被修改 Object.prototype.toString.call(1) // \"[object Number]\" Object.prototype.toString.call('1') // \"[object String]\" Object.prototype.toString.call([1]) // \"[object Array]\" // 如果修改原型 Object.prototype.toString = Array.prototype.toString Object.prototype.toString.call([1,2,3]) // \"1,2,3\" ... valueOf 和 toString valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 对象转字符串或者数字的过程：如果转换成字符串，会优先调用 toString 方法，转数字，会优先调用 valueOf 方法\n相关面试题：\n// 下面代码a在什么值情况下会输出1 var a = ?; if (a == 1 \u0026\u0026 a == 2 \u0026\u0026 a == 3) { console.log(1); } // 解 var a = { n : 0, valueOf(){ return ++this.n; } }; proxy 和 reflect proxy 对目标读取、函数调用等操作进行拦截，然后操作处理。它不直接操作对象，而是像代理模式。\nlet target = { name: \"Tom\", age: 24, }; let handler = { get: function (target, key) { console.log(\"getting \" + key); return target[key]; // 不是target.key }, set: function (target, key, value) { console.log(\"setting \" + key); target[key] = value; }, }; // target为目标对象，handler为代理处理 let proxy = new Proxy(target, handler); reflect 优化了 object 内部操作，修改一些函数的返回值，如 Object.defineProperty，Reflect 与 Proxy 是一一对应的对象，是 Proxy 的方法也是 Reflect 的方法，Proxy 修改的过的方法可以在 Reflect 获取默认值。\n// 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 Object.defineProperty(target, property, attributes) // 报错 Reflect.defineProperty(target, property, attributes // false // 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 'assign' in Object // true Reflect.has(Object, 'assign') // true requestAnimationFrame 针对实现动画 setInterval 的优化方法，执行速率和设备屏幕帧率有关系，不需要调用者指定帧速率，交给浏览器自行决定最佳帧效率，每一帧只执行一次，多次改变触发一次重拍，这样不会引起丢帧现象，也不会导致动画卡顿\n事件循环 同步任务在执行栈，异步任务执行后回调区分微任务和宏任务放入对应的微宏队列中，等同步执行栈执行完毕，会先检查微任务队列，执行完毕后，检查宏任务队列，执行。其中 Promise.resolve 调用静态方法，会优先于正常的 promise 的 resolve 方法\n异步微任务有哪些：\nnew Promise() 异步宏任务有哪些：\nsetInterval() setTimeout() 执行顺序： 同步放入执行栈 =\u003e 异步放入任务队列 =\u003e 异步区分微宏任务 =\u003e 微任务 =\u003e 宏任务\nasync/await，await 后的语句是同步的，在函数体内，await 下的语句会被放入 promise 回调函数体中，async 函数默认返回一个 promise 对象\n经典面试题：\nasync function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\"); } async function async2() { console.log(\"async2\"); } console.log(\"script start\"); setTimeout(function () { console.log(\"setTimeout\"); }, 0); async1(); new Promise(function (resolve) { console.log(\"promise1\"); resolve(); }).then(function () { console.log(\"promise2\"); }); console.log(\"script end\"); 解析：按照从上往下顺序先执行同步代码，前两个函数async1和async2是函数声明，忽略。然后第 1 个输出的是script start，然后看到setTimeout, 由于它是异步且属于宏任务，放到最后执行。然后看到 async1 函数被执行了，进入async1函数体，第 2 个输出的是async1 start, 看到 await 规则是：await 右的语句被同步执行，所以第 3 个输出的是async2，await 下的语句(函数体内)被当作 async 函数返回一个 promsise 的回调函数体的语句去处理，且被放入了异步任务队列中，等待中。然后跳出 async1 函数体，继续执行同步代码，遇到 new Promise，第 4 次输出promise1，看到 resolve，就把 then 中回调，放入任务队列中，然后继续向下执行同步代码，第 5 次输出的最后的script end。至此同步执行栈空了，开始把任务队列中的上下文拿到执行栈执行，由于队列先进先出，所以第一个被入栈的是 async1 的回调，也就是第 6 次输出的是async1 end，然后把第二个队列中的上下文放入执行栈，也就是 promise 的 resolve，所以第 7 次输出promise2，至此微任务执行完成，现在执行宏任务，也就是 timeout，所以第 8 次输出为setTimeout。\n结果：\nscript start async1 start async2 promise1 script end async1 end promise2 setTimeout 迭代器和生成器 先来瞅一段代码：\nfunction createIterator(items) { var i = 0; return { // 返回一个迭代器对象 next: function () { // 迭代器对象一定有个next()方法 let done = i \u003e= items.length; let value = !done ? items[i++] : undefined; return { value: value, done: done, }; }, }; } var iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // \"{ value: 1, done: false}\" console.log(iterator.next()); // \"{ value: 2, done: false}\" console.log(iterator.next()); // \"{ value: 3, done: false}\" console.log(iterator.next()); // \"{ value: undefiend, done: true}\" 这就是迭代器，迭代器是一个特殊对象，可以通过每调用一次 next，获取下一项结果。可以用迭代器替代 for 循环，因为 for 通过下标获取，多层嵌套比较复杂。\n// 用迭代器模拟for var colors = [\"red\", \"green\", \"blue\"]; var iterator = createIterator(colors); while (!iterator.next().done) { console.log(iterator.next().value); } 迭代器模拟 for 的方法看起来太麻烦了，不如 for 来的方便，这个时候可以用生成器(* 和 yield)来快速生成迭代器。\nfunction* createIterator(items) { for (let i = 0; i \u003c items.length; i++) { yield items[i]; } } let iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // \"{ value: 1, done: false}\" console.log(iterator.next()); // \"{ value: 2, done: false}\" console.log(iterator.next()); // \"{ value: 3, done: false}\" console.log(iterator.next()); // \"{ value: undefiend, done: true}\" 通过*和yield关键字创建，*来表示这个函数内部是可以用 yield 返回每次迭代的值，和 async、await 一样。需要组合使用，yield后面接每次迭代的值。这样就可以外部调用.next()获取下一个值。\n在 es6 中，数组、Set、Map、字符串集合，都属于可迭代对象，内部都有默认迭代器，可通过object[Symbol.iterator]()访问默认迭代器。\nes6 中也提供了一个通过方法来快速使用迭代器\nfor(item of 集合迭代器) {...} 常见的迭代器和得到 item 的值：\nobject.keys(): key(对象)/下标(数组) object.values(): 每项 value object.entries(): [下标/key, value] 事件委托与冒泡和捕获 什么是事件委托：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n什么是冒泡和捕获：其实都是事件传播路径。冒泡：从外到事件源进行事件传播；捕获：从内向事件源进行事件传播；\nDOM 标准事件流的触发的先后顺序为：先捕获再冒泡。即当触发 dom 事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。 addEventListener事件监听方法的第三个参数默认值是false，表示冒泡阶段调用，true为捕获阶段调用\n\u003cbody\u003e \u003cbutton\u003eappend\u003c/button\u003e \u003cul\u003e \u003cli\u003e0\u003c/li\u003e \u003cli\u003e1\u003c/li\u003e \u003cli\u003e2\u003c/li\u003e \u003cli\u003e3\u003c/li\u003e \u003cli\u003e4\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e window.onload = function () { document.querySelector(\"button\").onclick = function (e) { let li = document.createElement(\"li\"); li.innerHTML = \"5\"; document.querySelector(\"ul\").appendChild(li); }; document.querySelector(\"ul\").onclick = function (e) { // li 新增的li也是可以被点击的 console.log(e.target.nodeName.toLowerCase()); }; }; addeventListener 和 onclick 不同点：\naddeventListener 可以给一个事件注册多个 listener addEventListener 可以控制时间传播行为（捕获/冒泡，使用 removeEventListener 来解决） 实现 instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 let objProto = obj.__proto__; while(objProto) { if (objProto === ctor.prototype) { return true; } objProto = objProto.__proto__; } return false; } var Food = function() {}; var Meat = function() {}; Meat.prototype = new Food(); var meat = new Meat(); newInstanceof(meat, Meat) // true newInstanceof(meat, Food) // true meat instanceof Meat // true meat instanceof Food // true 总的来说就是meat.__proto__.constructor === Meat，由于原型链是一条链，所以循环所有__proto__; 直到null为止，符合Meat.prototype === meat.__proto__即返回true，否则返回false。\nconstructor 和 super 关键字 class是ES6新增的关键字，为了看起来更像java等面向对象语言，实际上是一个语法糖，等同于ES5的function来创建构造函数。\nconstructor ：constructors是 class 中默认的一个关键字，会自动调用该方法，class中必须要有constructor，如果没有，会被默认添加。当 new 时，constructor会被执行返回一个 this，就是实例。 super ： 当class有继承时，在constructor内部必须执行一遍 super()函数，B 继承 A，super相当于A.prototype.constructor.call(this, props)，另外 super()也指向父亲 A 的原型对象， 详细解释。如果当前类和父类都有同名方法，如何区分地获取呢，获取父类：super().fun，获取当前类：fun vue 部分 vue 组件通信 props 和 $emit provide inject：在组件 a 声明，在 a 下面所有子组件通过 inject 调用，通过参数传递 event bus： new 出一个 vue，通过 emit 和 on 来派发和监控 vuex 全局状态管理 this.$children 和 this.$parent 层级较深不推荐，provid 可以替代此方法 vue 生命周期父子组件执行顺序 父 beforeCreate -\u003e 父 created -\u003e 父 beforeMount -\u003e 子 beforeCreate -\u003e 子 created -\u003e 子 beforeMount-\u003e子 mounted-\u003e父 mounted\n子组件更新：父 beforeUpdate -\u003e 子 beforeUpdate -\u003e 子 updated -\u003e 父 updated\n父组件更新：父 beforeUpdate -\u003e 父 updated\n销毁：父 beforeDestroy -\u003e 子 beforeDestroy -\u003e 子 destroyed -\u003e 父 destroyed\n总结带 beofre 的生命周期都是从父到子调用，带 ed 的生命周期都是从子到父\n前端路由 hash 14 年前，前端路由都是用 hash 的方式实现的，地址长这个样子url#hash， 修改hash部分不会重载这个页面，每次 hash 改变，可以用 window 的hashchange方法来监听，通过这个方法就可以实现前端路由了\nhistory 在 14 年，HTML5 标准发布，window 上新增了两个 api：pushState和replaceState，也 hash 一样，不刷新来实现前端路由，而且少了#更美观了，由于没#，所以刷新时候，默认会从服务器下载对应 url 资源，这个时候我们需要改下服务器配置，都加载前端 index.html 文件，来实现前端路由\n// 第一个参数是state，用于描述一些特性，会被放入历史栈中，开发者使用 // 第二个参数是title，表示新页面的标题，浏览器都会忽略这个参数 // 第二个参数是url，表示新页面的相对地址 // 跳转 window.history.pushState(null, null, \"/profile\"); window.history.replaceState(null, null, \"/profile\"); 和pushState的区别是不会把记录放入历史栈中; 共同点 都不会重载页面 都会把历史记录放入栈中 不同点 hash 只可以#后部分，必须是同源 url，history 没有限制 history 需要修改服务器配置，来解决刷新空白问题，hash 本身就是属于前端的，不需要设置 slot 插槽 匿名插插: 子组件包裹的内容会被显示到slot标签中 \u003cchild\u003e父给子的内容\u003c/child\u003e // child组件中, 父给子的内容会显示slot标签里 \u003cslot\u003e父给子的内容\u003c/slot\u003e 具名插插：感觉名字多次显示，可复用 \u003cdiv slot=\"down\"\u003e\u003c/div\u003e的内容 会被显示到\u003cslot name=\"down\"\u003e\u003c/slot\u003e里 数据插槽： // 父亲中 \u003cdiv v-slot:data=\"{data}\"\u003e\u003c/div\u003e // 组件中就可以用data了 \u003cmyslot v-slot=\"data\"\u003e {{ slotProps.user.firstName }} \u003c/myslot\u003e keep-alive keep-live 是 vue 提供的内置缓存组件，可以保存组件状态，避免重新渲染，keep-alive 有三个参数：\ninclude 匹配的组件会被缓存，参数：字符串、数组、正则 exclude 匹配的组件不会被缓存，参数：字符串、数组、正则，和 include 同时存在一个组件的的话，exclude 优先级更高 max 可以限制最大可以缓存组件的数量，字符串或者数字 \u003ckeep-alive include=\"a,b\"\u003e \u003ccomponent\u003e\u003c/component\u003e \u003c/keep-alive\u003e \u003ckeep-alive exclude=\"c\"\u003e \u003ccomponent\u003e\u003c/component\u003e \u003c/keep-alive\u003e 缓存组件会多出两个生命周期，activated和deactivated，渲染和销毁\nkeep-alive 可配合 router-view 来实现组件缓存\n\u003ckeep-alive\u003e \u003crouter-view v-if=\"$route.meta.keepAlive\"\u003e\u003c/router-view\u003e \u003c/keep-alive\u003e \u003crouter-view v-if=\"!$route.meta.keepAlive\"\u003e\u003c/router-view\u003e export default new Router({ routes: [ { path: '/', name: 'a', component: a, meta: { keepAlive: false // 不缓存 } }, { path: '/b', name: 'b', component: b, meta: { keepAlive: true // 缓存 } } ] }) nextTick nextTick 可以获取下次最新 dom 的方法，因为 vue 的 dom 更新策略是异步的，只有一个事件循环结束后才会被应用来更新 dom，这导致数据的修改不会立即表现在 dom 上，如果要获取更新后的 dom 状态，这时候就需要用到 nextTick\n一些场景：\ncreated 中想要获取 DOM 更改数据获取最新的 dom mixin vue mixin 是针对组件间功能共享来做的。可以对组件的任意部分进行 mixin，也就是说不同的组件，想使用同一个数组，或者方法，那么 mixin 就是来做这个事的，把公共部分提取出来作为 mixin\n声明：\n// 声明 const toggle = { data() { isshowing: false; }, methods: { toggleShow() { this.isshowing = !this.isshowing; }, }, }; // 使用，toggle的方法会自动合并到当前组件中 mixins: [toggle]; vuex 核心概念：\nstate：数据 getter：类似计算属性，用来获取 state mutation： 同步方法，用于修改 state action： 异步方法，最后调用 mutation 修改 state // 声明 import Vuex from 'vuex' const store = new Vuex.Store({ state: { count: 0 }, getter: { doneTodos: (state, getters) =\u003e { return state.todos.filter(todo =\u003e todo.done) }, count: (state) =\u003e { return state.count } }, mutations: { increment (state, payload) { state.count++ } }, actions: { addCount(context) { // 可以包含异步操作 // context 是一个与 store 实例具有相同方法和属性的 context 对象 } } }) // 使用 // 调用mutation this.$store.commit('increment', 10) // 调用actions this.$store.dispatch('increment', 10) // 利用mapGetters mapGetters mapMutations mapActions便捷使用 computed: { ...mapGetters(['audio']), ...mapState({ this.count 等同于 state.count + this.localCount count(state) { return state.count + this.localCount } }, methods: { ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为`this.$store.commit('increment')` }), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } react 部分 react 生命周期 componentWillMount：在渲染前调用，客户端服务端都会调用 componentDidMount：第一次渲染后调用，只在客户端 componentWillReceiveProps： 接收新的 props 被调用，初始化时不会被调用 shouldComponentUpdate： 组件更新(props,state)时调用；返回布尔值，T 为允许更新组件，F 为不更新组件 componentWillUpdate： 组件更新(props,state)前渲染前被调用，初始化时不会调用 componentDidUpdate：组件完成更新后调用。初始化时不会被调用 componentWillUnmount： 组件要销毁前调用 react 数据响应式 react 的响应式是使用 diff 算法实现的。react 在 state 改变时，会调用 render() 方法，生成一个虚拟 DOM 树，React 会将这棵树与上一次生成的树进行比较，找出其中的差异，并更新差异的部分。这个过程是递归的，react 会以当前组件为根，递归比较所以子节点。为了优化性能，React 提供了 shouldComponentUpdate 生命周期方法，这个方法有两个参数，nextProps和nextState，表示上次 props 和上次 stage，返回值是布尔值，如果这个方法返回 false，react 就跳过这个组件，不做 VDOM 比较，也不更新组件。\n在 react16+版本，对 diff 过程进行了优化，从原来的 diff 树结构+递归的方式优化成 fiber 双向链表+循环执行。整个的 diff 过程分为 render 阶段和 commit 阶段，render 就是对比过程，找到需要改变 dom 的那部分，commit 就是执行改变 dom 的那部分，render 阶段是可以分段的（中断，然后继续完成），类似原生的requestIdleCallback方法，在每个 16ms 帧内，会先执行用户输入，事件回调等优先级高的 js 任务。之后剩下的时间执行分段的 render 部分来进行数据更新，保证视觉上的页面流程度。\nhttp 部分 http 缓存 分为 强缓存 和 协商缓存，如果同时存在，强缓存 优先 协商缓存\n强缓存： 响应头 Expires：Fri, 31 Dec 2024 23:59:59 GMT，在这个时间之前，直接读缓存，否则请求新内容，因为值是一个服务端返回的时间，这是 http 1.0 的产物，如果客户端和服务端时间不一致，就会和预期不符，所以在 http 1.1 中新增 Cache Control 来控制缓存 Cache Control：max-age=x 秒，在 x 秒内直接读缓存，避免了 expires 时间不一致问题 Cache Control 其他的 value：\nPrivate: 私有缓存，资源可以仅可以被客户端缓存（默认值） Public: 资源可以被任何缓存（包括中间代理服务器）缓存 No-Cache: 协商缓存 No-Store: 绝对不缓存 Max-Age：强缓存 协商缓存 （Last-Modified 优先 ETag） 当 Cache Control 设置为 No-Cache 时使用\nLast-Modified / If-Modified-Since：服务器会返回上次修改时间 Last-Modified，浏览器下次请求时请求头会带上 If-Modified-Since ，然后由服务端验证，如果 If-Modified-Since 在 Last-Modified 时间以内 ，就返回 304，浏览器读缓存，否则返回新内容 ETag / If-None-Match：服务器会返回内容 hash ETag 响应头，浏览器下次请求时请求头会带上 If-None-Match ，然后由服务端验证，如果一致，就返回 304，浏览器读缓存，否则返回新内容 附上一张说明图：\nhttps 握手 https 是 http 的安全扩展，相当于 HTTP + SSL(TLS) = HTTPS。SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层即网络层，TLS 是 SSL 的新版本，最后一个 SSL 3.0 版本在 2015 年废弃，之后就是 TLS，现在常见的 TLS 版本是 1.2 和 1.3 版本。那么 TLS 是如何实现的呢？\n浏览器 =\u003e 服务器：请求发起，建立 SSL 连接，发送 TLS 协议版本号 + 支持的加密方法列表 + 客户端随机数 服务器 =\u003e 浏览器：判断加密协议版本是否一致，并确认加密方法，都没问题则返回服务器证书 + 服务端随机数 浏览器 =\u003e 服务器：收到服务器证书，检查颁发机构、过期时间、域名，没有问题，则生成一个字符串（通过上面 客户端随机数 + 服务端随机数 生成），并用公钥（从服务器证书里取出）加密（非对称加密），发给服务器 服务器 =\u003e 浏览器：服务器用自己的私钥解密，得到这个字符串，后续使用这个字符串进行对称加密进行通信 http1.1长连接和http2多路复用区别 http1.1 长连接 同一个域名访问同一个文件的多个请求都可以复用一个 tcp 连接（不用像 1.0 一样 每次请求都需要重新建立连接，但不是并行，只能按顺序执行。\nhttp2 多路复用 同一个域名访问多个文件的多个请求也可以复用一个 tcp 连接，且多个请求可以被并行处理。\n其他 npmRun 会自动到 package.json 找到对应的命令执行。如果没有全局命令，会自动到node_modules/.bin/下找到对应可执行文件执行，这时npm run xxx等同于直接调用/images/node_modules/.bin/xxx\ncookie 的几种属性和作用 name: 名字 value: 值 domain: 可以访问此 cookie 的域名 path: 可以访问此 cookie 的路径 sameSite: 跨站点携带 cookie 设置 None：不限制； Lax：默认值，介于 None 和 Strict 之间，会合理判断携带 cookie 时机，如链接 a 会携带 cookie； Strict：完全禁止跨站点传送 cookie； httponly: 值为 true 则仅在 http 请求中会传递 cookie，不可用 document.cookie 等操作获取 secure: 是否只能使用 https 传递此 cookie expires: 过期时间；值是时间意思是到这个时间，cookie 失效，否则是 session，即退出浏览器后自动失效 输入 url 到页面展示经历了什么 dns 解析：按照这个步骤查询，找到 ip，立即中断返回给客户端（浏览器缓存 =\u003e 操作系统缓存(host) =\u003e 路由器缓存 =\u003e 本地服务器缓存 =\u003e isp dnf 服务器查询 =\u003e 根 dns 服务器）\ntcp 三次握手\n发送 http 请求报文：报文包括：请求行，请求头，请求体\n服务端接收到请求： 进入 web 服务器，如 apache、nginx，然后进入后台程序\n服务器响应报文：报文包括：响应行，响应头，响应体\n浏览器渲染页面\n根据 html 得到 dom 树 根据 css 得到 css 树 根据 dom 树和 css 树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 数据传送完成，四次挥手关闭：\n懒加载 页面中一些大资源加载较慢，比如 iframe，img。针对这个问题可以通过懒加载解决。\n拿img举例，先设置img的src属性为一个默认的资源，然后把真实url放在标签的某个属性中。并设置好图片的宽高，避免完成加载时出现页面闪动问题。\n然后实时监听页面滚动，如果当前图片是可见状态，那么把图片的真实 url 属性值取出替换到默认src上来实现加载图片资源，从而提升页面打开速度和合理使用客户端流量。\n// 获取浏览设备的网页可视高度 let clientHeight = document.documentElement.clientHeight; // 获取已被滚出的页面高度 let scrollTop = document.documentElement.scrollTop; // 图片顶部到网页顶部的高度 let imgOffsetTop = document.querySelector(\"img\").offsetTop; // 判断img在可视区域内： imgOffsetTop \u003c clientHeight + scrollTop; commonjs 模块和 es6 模块有什么区别 commonjs:\n对于基本数据类型，是值的拷贝 对于复杂数据类型，是浅拷贝，也就是修改一个模块的值，引用他的值也会发生改变 第一次加载模块会缓存，往后再加载会读取缓存的数据 es6：\n所有数据都是只读引用，当遇到 import 语句时，会生成一个只读引用，等到文件中真的使用到模块中的值时，根据只读引用，到加载中的模块取值 不允许修改模块中的数据，并且是动态的，比如模块中的值发生改变，引入得到的值也会改变。 前端优化 静态资源放在 cdn 首屏加载服务端渲染 可以升级到 http2，可以使用 http2 多路复用 多个请求并行，可以打乱顺序，最后重组 使用字体图标替代图片 gzip 压缩 uglify plugin 优化压缩代码 图片懒加载 图片压缩，优先使用 webp 减少重排，多使用类名或者 csstext 处理样式 多使用 flex，性能优，兼容性好 常见算法介绍 二分查找：也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。\n贪心算法：又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），贪图眼前局部的利益最大化。\n回溯算法：实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。\n分治算法：分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。\n动态规划：动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。\nbabel 工作原理 在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。简单来说就是一种描述源代码的结构，用于被计算机识别到，并成语言引擎执行\n工作原理大致可以理解成，字符串输入=\u003e转换=\u003e输出\n根据 babylon 解析器，把 js 代码按照规范解析成 AST 语法树 按照规则(stage-0,1,2,3),修改 AST 语法树，常见把高级语法，转换成低级语法 最后通过 babel-generator 将修改后的 AST 语法树转换成 js 代码 ",
  "wordCount" : "11523",
  "inLanguage": "zh",
  "image":"https://slc3a2.github.io/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/cover.jpg","datePublished": "2020-12-21T19:06:55+08:00",
  "dateModified": "2020-12-21T19:06:55+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://slc3a2.github.io/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "slc3a2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://slc3a2.github.io/favicon.ico"
    }
  }
}
</script><script
  async
  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"
></script>
<meta name="referrer" content="no-referrer-when-downgrade" />
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://slc3a2.github.io/" accesskey="h" title="slc3a2 (Alt + H)">slc3a2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://slc3a2.github.io/" title="🏠 首页">
                    <span>🏠 首页</span>
                </a>
            </li>
            <li>
                <a href="https://slc3a2.github.io/blogs/" title="📚 日志">
                    <span>📚 日志</span>
                </a>
            </li>
            <li>
                <a href="https://slc3a2.github.io/photos/" title="🖼️ 照片">
                    <span>🖼️ 照片</span>
                </a>
            </li>
            <li>
                <a href="https://slc3a2.github.io/apps/" title="🚀 应用">
                    <span>🚀 应用</span>
                </a>
            </li>
            <li>
                <a href="https://slc3a2.github.io/search/" title="🔍 搜索">
                    <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://slc3a2.github.io/tags/" title="🧩 分类">
                    <span>🧩 分类</span>
                </a>
            </li>
            <li>
                <a href="https://slc3a2.github.io/archives/" title="⏱ 时间轴">
                    <span>⏱ 时间轴</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<head>
  <style>
    main.main img {
      cursor: zoom-in;
    }
  </style>
</head>

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      前端面试题总结
    </h1>
    <div class="post-meta"><span title='2020-12-21 19:06:55 +0800 CST'>2020-12-21</span>&nbsp; ｜ &nbsp;23 分钟&nbsp; ｜ &nbsp;11523 字


      <span id="busuanzi_container_page_pv">
        &nbsp; ｜ 被阅读
        <span id="busuanzi_value_page_pv"></span>
        次
      </span>
    </div>
  </header> 
<figure class="entry-cover1">
    <img loading="eager" src="https://slc3a2.github.io/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/cover.jpg" alt="cover image" /> <figcaption>封面图来自 Unsplash | 作者 Sergey Zolkin</figcaption>
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#html-%e5%92%8c-css" aria-label="HTML 和 CSS">HTML 和 CSS</a><ul>
                            
                    <li>
                        <a href="#bfc" aria-label="BFC">BFC</a><ul>
                            
                    <li>
                        <a href="#%e5%a6%82%e4%bd%95%e8%a7%a6%e5%8f%91" aria-label="如何触发">如何触发</a></li>
                    <li>
                        <a href="#%e6%95%88%e6%9e%9c" aria-label="效果">效果</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e9%87%8d%e6%8e%92%e5%92%8c%e9%87%8d%e7%bb%98" aria-label="重排和重绘">重排和重绘</a></li>
                    <li>
                        <a href="#link-%e5%92%8cimport-%e5%8c%ba%e5%88%ab" aria-label="link 和@import 区别">link 和@import 区别</a></li>
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-css-%e9%a2%84%e5%a4%84%e7%90%86%e8%af%ad%e8%a8%80" aria-label="为什么要使用 css 预处理语言">为什么要使用 css 预处理语言</a></li>
                    <li>
                        <a href="#src-%e5%92%8c-href-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="src 和 href 的区别">src 和 href 的区别</a></li>
                    <li>
                        <a href="#%e8%a1%8c%e5%86%85%e5%85%83%e7%b4%a0%e7%89%b9%e7%82%b9" aria-label="行内元素特点">行内元素特点</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e6%8d%a2%e8%82%a4%e5%8a%9f%e8%83%bd" aria-label="实现换肤功能">实现换肤功能</a></li></ul>
                    </li>
                    <li>
                        <a href="#js-%e9%83%a8%e5%88%86" aria-label="js 部分">js 部分</a><ul>
                            
                    <li>
                        <a href="#%e7%ae%ad%e5%a4%b4%e5%87%bd%e6%95%b0%e5%92%8c%e6%99%ae%e9%80%9a%e5%87%bd%e6%95%b0%e5%8c%ba%e5%88%ab" aria-label="箭头函数和普通函数区别">箭头函数和普通函数区别</a></li>
                    <li>
                        <a href="#script-%e7%9a%84-defer-%e5%92%8c-async-%e5%b1%9e%e6%80%a7%e5%8c%ba%e5%88%ab" aria-label="script 的 defer 和 async 属性区别">script 的 defer 和 async 属性区别</a></li>
                    <li>
                        <a href="#%e6%b7%b1%e6%8b%b7%e8%b4%9d" aria-label="深拷贝">深拷贝</a></li>
                    <li>
                        <a href="#%e5%87%bd%e6%95%b0%e9%98%b2%e6%8a%96%e5%92%8c%e8%8a%82%e6%b5%81" aria-label="函数防抖和节流">函数防抖和节流</a></li>
                    <li>
                        <a href="#%e7%bb%a7%e6%89%bf" aria-label="继承">继承</a></li>
                    <li>
                        <a href="#%e8%b7%a8%e5%9f%9f" aria-label="跨域">跨域</a></li>
                    <li>
                        <a href="#%e6%95%b0%e7%bb%84%e6%96%b9%e6%b3%95" aria-label="数组方法">数组方法</a><ul>
                            
                    <li>
                        <a href="#%e6%94%b9%e5%8f%98%e5%8e%9f%e6%95%b0%e7%bb%84" aria-label="改变原数组">改变原数组</a></li>
                    <li>
                        <a href="#%e4%b8%8d%e6%94%b9%e5%8f%98%e5%8e%9f%e6%95%b0%e7%bb%84%e7%94%9f%e6%88%90%e6%96%b0%e6%95%b0%e7%bb%84" aria-label="不改变原数组，生成新数组">不改变原数组，生成新数组</a><ul>
                            
                    <li>
                        <a href="#%e5%be%aa%e7%8e%af%e6%96%b9%e6%b3%95" aria-label="循环方法">循环方法</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%96%b9%e6%b3%95" aria-label="字符串方法">字符串方法</a></li>
                    <li>
                        <a href="#js-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6" aria-label="js 垃圾回收机制">js 垃圾回收机制</a></li>
                    <li>
                        <a href="#%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%b5%8b" aria-label="类型检测">类型检测</a></li>
                    <li>
                        <a href="#valueof-%e5%92%8c-tostring" aria-label="valueOf 和 toString">valueOf 和 toString</a></li>
                    <li>
                        <a href="#proxy-%e5%92%8c-reflect" aria-label="proxy 和 reflect">proxy 和 reflect</a><ul>
                            
                    <li>
                        <a href="#proxy" aria-label="proxy">proxy</a></li>
                    <li>
                        <a href="#reflect" aria-label="reflect">reflect</a></li></ul>
                    </li>
                    <li>
                        <a href="#requestanimationframe" aria-label="requestAnimationFrame">requestAnimationFrame</a></li>
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af" aria-label="事件循环">事件循环</a></li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e5%92%8c%e7%94%9f%e6%88%90%e5%99%a8" aria-label="迭代器和生成器">迭代器和生成器</a></li>
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98%e4%b8%8e%e5%86%92%e6%b3%a1%e5%92%8c%e6%8d%95%e8%8e%b7" aria-label="事件委托与冒泡和捕获">事件委托与冒泡和捕获</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0-instanceof" aria-label="实现 instanceof">实现 instanceof</a></li>
                    <li>
                        <a href="#constructor-%e5%92%8c-super-%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="constructor 和 super 关键字">constructor 和 super 关键字</a></li></ul>
                    </li>
                    <li>
                        <a href="#vue-%e9%83%a8%e5%88%86" aria-label="vue 部分">vue 部分</a><ul>
                            
                    <li>
                        <a href="#vue-%e7%bb%84%e4%bb%b6%e9%80%9a%e4%bf%a1" aria-label="vue 组件通信">vue 组件通信</a></li>
                    <li>
                        <a href="#vue-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%88%b6%e5%ad%90%e7%bb%84%e4%bb%b6%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f" aria-label="vue 生命周期父子组件执行顺序">vue 生命周期父子组件执行顺序</a></li>
                    <li>
                        <a href="#%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1" aria-label="前端路由">前端路由</a><ul>
                            
                    <li>
                        <a href="#hash" aria-label="hash">hash</a></li>
                    <li>
                        <a href="#history" aria-label="history">history</a><ul>
                            
                    <li>
                        <a href="#%e5%85%b1%e5%90%8c%e7%82%b9" aria-label="共同点">共同点</a></li>
                    <li>
                        <a href="#%e4%b8%8d%e5%90%8c%e7%82%b9" aria-label="不同点">不同点</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#slot-%e6%8f%92%e6%a7%bd" aria-label="slot 插槽">slot 插槽</a></li>
                    <li>
                        <a href="#keep-alive" aria-label="keep-alive">keep-alive</a></li>
                    <li>
                        <a href="#nexttick" aria-label="nextTick">nextTick</a></li>
                    <li>
                        <a href="#mixin" aria-label="mixin">mixin</a></li>
                    <li>
                        <a href="#vuex" aria-label="vuex">vuex</a></li></ul>
                    </li>
                    <li>
                        <a href="#react-%e9%83%a8%e5%88%86" aria-label="react 部分">react 部分</a><ul>
                            
                    <li>
                        <a href="#react-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="react 生命周期">react 生命周期</a></li>
                    <li>
                        <a href="#react-%e6%95%b0%e6%8d%ae%e5%93%8d%e5%ba%94%e5%bc%8f" aria-label="react 数据响应式">react 数据响应式</a></li></ul>
                    </li>
                    <li>
                        <a href="#http-%e9%83%a8%e5%88%86" aria-label="http 部分">http 部分</a><ul>
                            
                    <li>
                        <a href="#http-%e7%bc%93%e5%ad%98" aria-label="http 缓存">http 缓存</a><ul>
                            
                    <li>
                        <a href="#%e5%bc%ba%e7%bc%93%e5%ad%98" aria-label="强缓存：">强缓存：</a></li>
                    <li>
                        <a href="#%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98-last-modified-%e4%bc%98%e5%85%88-etag" aria-label="协商缓存 （Last-Modified 优先 ETag）">协商缓存 （Last-Modified 优先 ETag）</a></li></ul>
                    </li>
                    <li>
                        <a href="#https-%e6%8f%a1%e6%89%8b" aria-label="https 握手">https 握手</a></li>
                    <li>
                        <a href="#http1-1%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%92%8chttp2%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e5%8c%ba%e5%88%ab" aria-label=" http1.1长连接和http2多路复用区别"> http1.1长连接和http2多路复用区别</a><ul>
                            
                    <li>
                        <a href="#http11-%e9%95%bf%e8%bf%9e%e6%8e%a5" aria-label="http1.1 长连接">http1.1 长连接</a></li>
                    <li>
                        <a href="#http2-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8" aria-label="http2 多路复用">http2 多路复用</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a><ul>
                            
                    <li>
                        <a href="#npmrun" aria-label="npmRun">npmRun</a></li>
                    <li>
                        <a href="#cookie-%e7%9a%84%e5%87%a0%e7%a7%8d%e5%b1%9e%e6%80%a7%e5%92%8c%e4%bd%9c%e7%94%a8" aria-label="cookie 的几种属性和作用">cookie 的几种属性和作用</a></li>
                    <li>
                        <a href="#%e8%be%93%e5%85%a5-url-%e5%88%b0%e9%a1%b5%e9%9d%a2%e5%b1%95%e7%a4%ba%e7%bb%8f%e5%8e%86%e4%ba%86%e4%bb%80%e4%b9%88" aria-label="输入 url 到页面展示经历了什么">输入 url 到页面展示经历了什么</a></li>
                    <li>
                        <a href="#%e6%87%92%e5%8a%a0%e8%bd%bd" aria-label="懒加载">懒加载</a></li>
                    <li>
                        <a href="#commonjs-%e6%a8%a1%e5%9d%97%e5%92%8c-es6-%e6%a8%a1%e5%9d%97%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="commonjs 模块和 es6 模块有什么区别">commonjs 模块和 es6 模块有什么区别</a></li>
                    <li>
                        <a href="#%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96" aria-label="前端优化">前端优化</a></li>
                    <li>
                        <a href="#%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95%e4%bb%8b%e7%bb%8d" aria-label="常见算法介绍">常见算法介绍</a></li>
                    <li>
                        <a href="#babel-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="babel 工作原理">babel 工作原理</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><!-- [HTML 和 CSS 部分](#HTML和CSS)

- [BFC](#BFC)
- [重排和重绘](#重排和重绘)
- [行内元素特点](#行内元素特点)
- [实现换肤功能](#实现换肤功能)
- [link 和@import 区别](#link和@import区别)
- [为什么要使用 css 预处理语言](#为什么要使用css预处理语言)
- [src 和 href 的区别](#src和href的区别)

[js 部分](#js部分)

- [箭头函数和普通函数区别](#箭头函数和普通函数区别)

- [script 的 defer 和 async 属性区别](#script的defer和async属性区别)
- [深拷贝](#深拷贝)
- [函数防抖和节流](#函数防抖和节流)
- [继承](#继承)
- [跨域](#跨域)
- [数组方法](#数组方法)
- [字符串方法](#字符串方法)
- [js 垃圾回收机制](#js垃圾回收机制)
- [类型检测](#类型检测)
- [valueOf 和 toString](#valueOf和toString)
- [proxy 和 reflect](#proxy和reflect)
- [requestAnimationFrame](#requestAnimationFrame)
- [事件循环](#事件循环)
- [迭代器和生成器](#迭代器和生成器)
- [事件委托与冒泡和捕获](#事件委托与冒泡和捕获)
- [实现 instanceof](#实现instanceof)
- [constructor 和 super 关键字](#constructor和super关键字)

[vue 部分](#vue部分)

- [vue 组件通信](#vue组件通信)
- [vue 生命周期父子组件执行顺序](#vue生命周期父子组件执行顺序)
- [前端路由](#前端路由)
- [slot 插槽](#slot插槽)
- [keep-alive](#keep-alive)
- [nextTick](#nextTick)
- [mixin](#mixin)
- [vuex](#vuex)

[react 部分](#深拷贝)

- [react 生命周期](#react生命周期)
- [react 数据响应式](#react数据响应式)

[http 部分](#http部分)

- [http 缓存](#http缓存)
- [https 握手](#https握手)
- [http1.1 长连接和 http2 多路复用区别](#http1-1长连接和http2多路复用区别)

[其他](#其他)

- [npm run](#npmRun)
- [cookie 的几种属性和作用](#cookie的几种属性和作用)
- [输入 url 到页面展示经历了什么](#输入url到页面展示经历了什么)
- [懒加载](#懒加载)
- [commonjs 模块和 es6 模块有什么区别](#commonjs模块和es6模块有什么区别)
- [前端优化](#前端优化)
- [常见算法介绍](#常见算法介绍)
- [babel 工作原理](#babel工作原理) -->
<h1 id="html-和-css">HTML 和 CSS<a hidden class="anchor" aria-hidden="true" href="#html-和-css">#</a></h1>
<h2 id="bfc">BFC<a hidden class="anchor" aria-hidden="true" href="#bfc">#</a></h2>
<blockquote>
<p>全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。</p></blockquote>
<h3 id="如何触发">如何触发<a hidden class="anchor" aria-hidden="true" href="#如何触发">#</a></h3>
<ul>
<li>根元素 body</li>
<li>float： right | left</li>
<li>position： absolute | fixed</li>
<li>display：inline-block | tabel-cells | flex</li>
<li>overflow： hidden | auto | scroll</li>
</ul>
<h3 id="效果">效果<a hidden class="anchor" aria-hidden="true" href="#效果">#</a></h3>
<ul>
<li>清除浮动，常用 overflow hidde</li>
<li>垂直方向 margin 会重叠</li>
</ul>
<h2 id="重排和重绘">重排和重绘<a hidden class="anchor" aria-hidden="true" href="#重排和重绘">#</a></h2>
<p>网页加载过程大致分为 5 步：</p>
<ol>
<li>HTML 代码转化成 DOM</li>
<li>CSS 代码转化成 CSSOM</li>
<li>结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息）</li>
<li>生成布局（layout），即将所有渲染树的所有节点进行平面合成</li>
<li>将布局绘制（paint）在屏幕上</li>
</ol>
<p>其中第 4 步为排列布局，重排指的就是第 4 步重做；第 5 步是绘制，那重绘指的就是第 5 步重做。按照网页加载顺序，第 4 步之后执行第 5 步，所以重排必将触发重绘，而重绘不一定会触发重排。</p>
<p><strong>重绘</strong>：修改元素字体颜色，背景颜色，阴影效果等
<strong>重排</strong>：位置发生改变，如<code>margin</code> <code>padding</code> <code>width</code>。 <code>删除增加dom</code> <code>调用offsetHeight</code>等读取实时量值时</p>
<p>由于重排性能消耗大，那么减少重排次数也就成了一个优化页面的方法，下面总结几个常用方法：</p>
<ol>
<li>不要一条一条修改 css，尽量通过 class 修改，或者 csstext</li>
<li>先 display: none; 再修改样式，然后再 display: block;</li>
<li>一个元素大量修改 css，可以设置为 position: fixed | absolute, 这样重排消耗少，因为不用考虑其他元素位置</li>
<li>react vue 虚拟 dom</li>
</ol>
<h2 id="link-和import-区别">link 和@import 区别<a hidden class="anchor" aria-hidden="true" href="#link-和import-区别">#</a></h2>
<p><code>@import</code>属于 css 语法，只能加载 css，<code>link</code>是 html 语法，不仅可以加载 css，还可以加载网站 icon 等</p>
<h2 id="为什么要使用-css-预处理语言">为什么要使用 css 预处理语言<a hidden class="anchor" aria-hidden="true" href="#为什么要使用-css-预处理语言">#</a></h2>
<p>类似 scss(sass3+)，less 等预处理 css 语言，扩展了 css，具备<code>变量</code>、<code>mixins</code>、<code>函数</code>, <code>嵌套</code>，带有<code>作用域</code>，<code>支持块注释 //</code></p>
<h2 id="src-和-href-的区别">src 和 href 的区别<a hidden class="anchor" aria-hidden="true" href="#src-和-href-的区别">#</a></h2>
<p>src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系。src 加载资源会阻塞页面，href 是加载并行。</p>
<p>src:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">img</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/img.jpg&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/jquery.js&#34;</span>&gt;&lt;/<span style="color:#f92672">script</span>&gt;
</span></span></code></pre></div><p>href:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">link</span> <span style="color:#a6e22e">rel</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;stylesheet&#34;</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/main.css&#34;</span> /&gt; &lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
</span></span></code></pre></div><h2 id="行内元素特点">行内元素特点<a hidden class="anchor" aria-hidden="true" href="#行内元素特点">#</a></h2>
<ul>
<li>可以设置所有方向<code>margin</code>和<code>padding</code>，但是垂直方向无法更改布局</li>
<li>设置<code>width</code>和<code>height</code>属性无效</li>
<li>不会另起一行</li>
</ul>
<h2 id="实现换肤功能">实现换肤功能<a hidden class="anchor" aria-hidden="true" href="#实现换肤功能">#</a></h2>
<ul>
<li>设置多种颜色类名，覆盖实现</li>
<li>http 请求动态加载 .css 文件</li>
<li>预编译 css 变量</li>
</ul>
<h1 id="js-部分">js 部分<a hidden class="anchor" aria-hidden="true" href="#js-部分">#</a></h1>
<h2 id="箭头函数和普通函数区别">箭头函数和普通函数区别<a hidden class="anchor" aria-hidden="true" href="#箭头函数和普通函数区别">#</a></h2>
<ul>
<li>没有自己 this，继承父级的 this</li>
<li>没有自己 arguments // Uncaught ReferenceError: arguments is not defined</li>
<li>没有原型 // undefined</li>
</ul>
<h2 id="script-的-defer-和-async-属性区别">script 的 defer 和 async 属性区别<a hidden class="anchor" aria-hidden="true" href="#script-的-defer-和-async-属性区别">#</a></h2>
<p>相比于基本的 script 标签、都可以实现<code>异步加载脚本</code>，只是执行脚本的时机不同，</p>
<ul>
<li><strong>async</strong>：加载完成后，<code>立即执行</code>，可以在 dom 没完全加载执行，如果多个 script async，那么哪个<code>先加载完就</code>执行哪个，适合加载<code>无依</code>赖的 js</li>
<li><strong>defer</strong>：加载完成后，等到<code>dom加载完成后</code>执行，如果多个 script defer，会严格按照他们的书写顺序<code>依次执行</code>，适合加载<code>互相依赖</code>的 js</li>
</ul>
<h2 id="深拷贝">深拷贝<a hidden class="anchor" aria-hidden="true" href="#深拷贝">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 冷门深拷贝利用MessageChannel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">deepClone</span>(<span style="color:#a6e22e">obj</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> { <span style="color:#a6e22e">port1</span>, <span style="color:#a6e22e">port2</span> } <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MessageChannel</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">port1</span>.<span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">port2</span>.<span style="color:#a6e22e">postMessage</span>(<span style="color:#a6e22e">obj</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 利用weakmap解决了循环引用报错问题，完全版
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">deepClone1</span>(<span style="color:#a6e22e">_target</span>, <span style="color:#a6e22e">map</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WeakMap</span>()) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">_target</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">_target</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;object&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_target</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">_target</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;进入map判断&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">_target</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">_target</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> Array.<span style="color:#a6e22e">isArray</span>(<span style="color:#a6e22e">_target</span>) <span style="color:#f92672">?</span> [] <span style="color:#f92672">:</span> {};
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;map set&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">_target</span>, <span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">_target</span>, <span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">_target</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;循环&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">_target</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;object&#34;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;是对象&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">deepClone1</span>(<span style="color:#a6e22e">_target</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">map</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;不是对象&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">_target</span>[<span style="color:#a6e22e">i</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="函数防抖和节流">函数防抖和节流<a hidden class="anchor" aria-hidden="true" href="#函数防抖和节流">#</a></h2>
<ul>
<li><strong>防抖</strong>：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">debounce</span>(<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">delay</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">timer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (...<span style="color:#a6e22e">args</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...args用来接受fun原有的参数，比如事件就是event对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">clearTimeout</span>(<span style="color:#a6e22e">timer</span>); <span style="color:#75715e">// 利用clearTimeout的特性，处理delay内，再此触发函数不做处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">timer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">args</span>);
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">delay</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>节流</strong>：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">throttle</span>(<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">delay</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (...<span style="color:#a6e22e">args</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...args用来接受fun原有的参数，比如事件就是event对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">now</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">now</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">prev</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">delay</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">args</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://slc3a2.github.io/2020/10/20/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/">查看详解</a></p>
<h2 id="继承">继承<a hidden class="anchor" aria-hidden="true" href="#继承">#</a></h2>
<ul>
<li>
<p><strong>原型链继承</strong>： Cat 继承了 Animal，缺点：所有 Cat 实例都会共享原型链，不可以向 Animal 传参。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Cat</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Cat</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Animal</span>();
</span></span></code></pre></div></li>
<li>
<p><strong>call 继承/构造继承</strong>: 解决上面原型链建成俩问题，但是只是 Cat 实例，不是 Animal 的实例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Cat</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Animal</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>组合继承</strong>：也就是前面两个方法合并，解决上面两个继承的缺点，唯一的缺点调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Cat</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Animal</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Cat</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Animal</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Cat</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">constructor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Cat</span>; <span style="color:#75715e">//修复构造函数指向
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 优点：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 既是cat实例，又是Animal实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 没有共享原型方法问题，并可以传参数
</span></span></span></code></pre></div></li>
</ul>
<h2 id="跨域">跨域<a hidden class="anchor" aria-hidden="true" href="#跨域">#</a></h2>
<ul>
<li>
<p><strong>jsonp</strong>： 利用 script 标签跨域，本质是加载一个外部 js</p>
</li>
<li>
<p><strong>cors</strong>：全程跨域资源共享，服务端操作，把请求头的<code>origin</code>的值取出，响应头会增加<code>Access-Control-Allow-Origin</code> key 并把值设置为<code>origin</code>取出的值也可以是通配符，浏览器就不会拦截响应了，从而解决跨域问题</p>
</li>
<li>
<p><strong>postMassage</strong>：利用可访问服务资源的<code>iframe</code>，和当前页面互相通信，传递消息，来实现跨域，<code>postMassage</code>本质是两个页面的消息传递方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 页面1(可以获取后端数据的)传递数据，第二个参数是url匹配规则，可以是通配符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>window.<span style="color:#a6e22e">frames</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">postMessage</span>(<span style="color:#a6e22e">data</span>, <span style="color:#e6db74">&#34;*&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 页面2(不能接收后端数据的)，接收页面1的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>window.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;message&#34;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div></li>
<li>
<p><strong>服务器中转</strong>： 由于服务端没跨域，服务端代替客户端请求目标接口，并把响应数据返回给客户端</p>
</li>
</ul>
<h2 id="数组方法">数组方法<a hidden class="anchor" aria-hidden="true" href="#数组方法">#</a></h2>
<h3 id="改变原数组">改变原数组<a hidden class="anchor" aria-hidden="true" href="#改变原数组">#</a></h3>
<ul>
<li>splice: array.splice(index,howmany,item1,&hellip;..,itemX) 删除/添加</li>
<li>sort: 排序</li>
<li>unshift: 首加 shift: 首删; pop: 尾删; push: 尾加</li>
<li>reverse: 倒序排列</li>
<li>fill: 数组填充</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">array</span>
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">fill</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">startIndex</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">endIndex</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">array</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  [(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)].<span style="color:#a6e22e">fill</span>(<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// [1, &#34;a&#34;, &#34;a&#34;, 4, 5]
</span></span></span></code></pre></div><h3 id="不改变原数组生成新数组">不改变原数组，生成新数组<a hidden class="anchor" aria-hidden="true" href="#不改变原数组生成新数组">#</a></h3>
<ul>
<li>slice: 浅拷贝 array.slice(startIdx, endIdx)</li>
<li>join: 转字符串并分割</li>
<li>toLocaleString: 转换成字符串数组</li>
<li>concat: 连接数组 可用&hellip;替代</li>
<li>indexOf: 检查下标</li>
<li>includes: 是否包含。可替代 indexOf，indexOf === -1 不够语义化</li>
</ul>
<h4 id="循环方法">循环方法<a hidden class="anchor" aria-hidden="true" href="#循环方法">#</a></h4>
<ul>
<li>forEach、map、filter</li>
<li>every、some、reduce、reduceRight(和 reduce 区别是相反方向)</li>
</ul>
<h2 id="字符串方法">字符串方法<a hidden class="anchor" aria-hidden="true" href="#字符串方法">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">charAt</span>(<span style="color:#ae81ff">1</span>); <span style="color:#75715e">//e 返回指定下标的字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">charcodeAt</span>(<span style="color:#ae81ff">1</span>); <span style="color:#75715e">//101 返回指定下标字符的字符编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">concat</span>(<span style="color:#ae81ff">123</span>); <span style="color:#75715e">// hello world123 连接字符串，生成新的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// he 截取字符串，参数为下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// he 截取字符串，参数为下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">substr</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// he 截取字符串，第一个参数是起始下标，第二个参数为截取数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#e6db74">&#34;h&#34;</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 0 查子字符下标，第一个参数是字符，第二个参数是起始下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">lastIndexOf</span>(<span style="color:#e6db74">&#34;h&#34;</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 0 查子字符下标，第一个参数是字符，第二个参数是结尾下标(和indexof区别)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">toLowerCase</span>(); <span style="color:#75715e">// hello world 转小写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// HELLO WORLD 转大写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">trim</span>(); <span style="color:#75715e">// 删除前后空格
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;e&#34;</span>); <span style="color:#75715e">// [&#34;h&#34;, &#34;llo world&#34;] 转数组，参数为分割符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#34;o&#34;</span>, <span style="color:#e6db74">&#34;a&#34;</span>); <span style="color:#75715e">// hella world 替换字符，第一个参数可以是正则
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">match</span>(<span style="color:#e6db74">/hello/g</span>); <span style="color:#75715e">// [&#34;hello&#34;] 匹配字符串返回一个数组，参数常是正则
</span></span></span></code></pre></div><h2 id="js-垃圾回收机制">js 垃圾回收机制<a hidden class="anchor" aria-hidden="true" href="#js-垃圾回收机制">#</a></h2>
<blockquote>
<p>当内存中的数据不需要时候，js 会自动使用垃圾回收算法释放掉</p></blockquote>
<ul>
<li><strong>引用计算</strong> : 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。这是最初级的垃圾收集算法。 该算法有个限制：无法处理引用循环，两个对象互相引用的情况下，引用次数至少是 1，所以不会被回收掉</li>
<li><strong>标记清除</strong> : 此算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法从根（root）全局对象开始先下查找，找到不可以被获得的对象，然后清除掉</li>
</ul>
<h2 id="类型检测">类型检测<a hidden class="anchor" aria-hidden="true" href="#类型检测">#</a></h2>
<ul>
<li><strong>typeof</strong>: 除了基本数据类型，检测不到具体 object 类型(数组，对象，时间对象，正则，set，map)</li>
<li><strong>instanceof</strong>: 例 a instanceof Fun 原理是检测 a 是不是 Fun 的实例，缺点就是被检测的值必须是引用，如下所示</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Number(<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">instanceof</span> Number;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">instanceof</span> Number;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// false
</span></span></span></code></pre></div><ul>
<li><strong>constructor</strong>: 实例.constructor === 构造器，缺点是 constructor 属性容易被修改</li>
<li><strong>Object.prototype.toString.call</strong>: 目前最好用的一个方法，缺点是使用 object 构造函数的 toString 方法，此方法可能被修改</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>	Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">toString</span>.<span style="color:#a6e22e">call</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// &#34;[object Number]&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">toString</span>.<span style="color:#a6e22e">call</span>(<span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// &#34;[object String]&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">toString</span>.<span style="color:#a6e22e">call</span>([<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// &#34;[object Array]&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果修改原型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">=</span> Array.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">toString</span>
</span></span><span style="display:flex;"><span>	Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">toString</span>.<span style="color:#a6e22e">call</span>([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// &#34;1,2,3&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span></code></pre></div><h2 id="valueof-和-tostring">valueOf 和 toString<a hidden class="anchor" aria-hidden="true" href="#valueof-和-tostring">#</a></h2>
<ul>
<li><strong>valueOf</strong>: 返回对象的原始值表示</li>
<li><strong>toString</strong>: 返回对象的字符串表示</li>
</ul>
<p>对象转字符串或者数字的过程：如果转换成字符串，会优先调用 toString 方法，转数字，会优先调用 valueOf 方法</p>
<p>相关面试题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span> <span style="color:#75715e">// 下面代码a在什么值情况下会输出1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">valueOf</span>(){
</span></span><span style="display:flex;"><span>	        <span style="color:#66d9ef">return</span> <span style="color:#f92672">++</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">n</span>;
</span></span><span style="display:flex;"><span>	    }
</span></span><span style="display:flex;"><span>	};
</span></span></code></pre></div><h2 id="proxy-和-reflect">proxy 和 reflect<a hidden class="anchor" aria-hidden="true" href="#proxy-和-reflect">#</a></h2>
<h3 id="proxy">proxy<a hidden class="anchor" aria-hidden="true" href="#proxy">#</a></h3>
<blockquote>
<p>对目标读取、函数调用等操作进行拦截，然后操作处理。它不直接操作对象，而是像代理模式。</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tom&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">24</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">get</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;getting &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#75715e">// 不是target.key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;setting &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// target为目标对象，handler为代理处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">proxy</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler</span>);
</span></span></code></pre></div><h3 id="reflect">reflect<a hidden class="anchor" aria-hidden="true" href="#reflect">#</a></h3>
<blockquote>
<p>优化了 object 内部操作，修改一些函数的返回值，如 Object.defineProperty，Reflect 与 Proxy 是一一对应的对象，是 Proxy 的方法也是 Reflect 的方法，Proxy 修改的过的方法可以在 Reflect 获取默认值。</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">property</span>, <span style="color:#a6e22e">attributes</span>) <span style="color:#75715e">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">property</span>, <span style="color:#a6e22e">attributes</span> <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#39;assign&#39;</span> <span style="color:#66d9ef">in</span> Object <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">has</span>(Object, <span style="color:#e6db74">&#39;assign&#39;</span>) <span style="color:#75715e">// true
</span></span></span></code></pre></div><h2 id="requestanimationframe">requestAnimationFrame<a hidden class="anchor" aria-hidden="true" href="#requestanimationframe">#</a></h2>
<p>针对实现动画 setInterval 的优化方法，执行速率和设备屏幕帧率有关系，不需要调用者指定帧速率，交给浏览器自行决定最佳帧效率，每一帧只执行一次，多次改变触发一次重拍，这样不会引起丢帧现象，也不会导致动画卡顿</p>
<h2 id="事件循环">事件循环<a hidden class="anchor" aria-hidden="true" href="#事件循环">#</a></h2>
<p>同步任务在执行栈，异步任务执行后回调区分微任务和宏任务放入对应的微宏队列中，等同步执行栈执行完毕，会先检查微任务队列，执行完毕后，检查宏任务队列，执行。其中 Promise.resolve 调用静态方法，会优先于正常的 promise 的 resolve 方法</p>
<p>异步微任务有哪些：</p>
<ul>
<li>new Promise()</li>
</ul>
<p>异步宏任务有哪些：</p>
<ul>
<li>setInterval()</li>
<li>setTimeout()</li>
</ul>
<p>执行顺序： 同步放入执行栈 =&gt; 异步放入任务队列 =&gt; 异步区分微宏任务 =&gt; 微任务 =&gt; 宏任务</p>
<p>async/await，await 后的语句是同步的，在函数体内，await 下的语句会被放入 promise 回调函数体中，async 函数默认返回一个 promise 对象</p>
<p>经典面试题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">async1</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;async1 start&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">async2</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;async1 end&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">async2</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;async2&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;script start&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;setTimeout&#34;</span>);
</span></span><span style="display:flex;"><span>}, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">async1</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;promise1&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resolve</span>();
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;promise2&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;script end&#34;</span>);
</span></span></code></pre></div><p>解析：按照从上往下顺序先执行同步代码，前两个函数<code>async1</code>和<code>async2</code>是函数声明，忽略。然后第 1 个输出的是<code>script start</code>，然后看到<code>setTimeout</code>, 由于它是异步且属于宏任务，放到最后执行。然后看到 async1 函数被执行了，进入<code>async1</code>函数体，第 2 个输出的是<code>async1 start</code>, 看到 await 规则是：await 右的语句被同步执行，所以第 3 个输出的是<code>async2</code>，await 下的语句(函数体内)被当作 async 函数返回一个 promsise 的回调函数体的语句去处理，且被放入了异步任务队列中，等待中。然后跳出 async1 函数体，继续执行同步代码，遇到 new Promise，第 4 次输出<code>promise1</code>，看到 resolve，就把 then 中回调，放入任务队列中，然后继续向下执行同步代码，第 5 次输出的最后的<code>script end</code>。至此同步执行栈空了，开始把任务队列中的上下文拿到执行栈执行，由于队列先进先出，所以第一个被入栈的是 async1 的回调，也就是第 6 次输出的是<code>async1 end</code>，然后把第二个队列中的上下文放入执行栈，也就是 promise 的 resolve，所以第 7 次输出<code>promise2</code>，至此微任务执行完成，现在执行宏任务，也就是 timeout，所以第 8 次输出为<code>setTimeout</code>。</p>
<p>结果：</p>
<pre tabindex="0"><code>script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
</code></pre><h2 id="迭代器和生成器">迭代器和生成器<a hidden class="anchor" aria-hidden="true" href="#迭代器和生成器">#</a></h2>
<p>先来瞅一段代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createIterator</span>(<span style="color:#a6e22e">items</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回一个迭代器对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 迭代器对象一定有个next()方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">done</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">items</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">done</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>] <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">done</span>,
</span></span><span style="display:flex;"><span>      };
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createIterator</span>([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: 1, done: false}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: 2, done: false}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: 3, done: false}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: undefiend, done: true}&#34;
</span></span></span></code></pre></div><p>这就是迭代器，迭代器是一个特殊对象，可以通过每调用一次 next，获取下一项结果。可以用迭代器替代 for 循环，因为 for 通过下标获取，多层嵌套比较复杂。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 用迭代器模拟for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">colors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>, <span style="color:#e6db74">&#34;blue&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createIterator</span>(<span style="color:#a6e22e">colors</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">done</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>迭代器模拟 for 的方法看起来太麻烦了，不如 for 来的方便，这个时候可以用<code>生成器</code>(* 和 yield)来快速生成迭代器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">createIterator</span>(<span style="color:#a6e22e">items</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">items</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">i</span>];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">iterator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createIterator</span>([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: 1, done: false}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: 2, done: false}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: 3, done: false}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">iterator</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// &#34;{ value: undefiend, done: true}&#34;
</span></span></span></code></pre></div><p>通过<code>*</code>和<code>yield</code>关键字创建，<code>*</code>来表示这个函数内部是可以用 yield 返回每次迭代的值，和 async、await 一样。需要组合使用，<code>yield</code>后面接每次迭代的值。这样就可以外部调用.next()获取下一个值。</p>
<p>在 es6 中，数组、Set、Map、字符串集合，都属于可迭代对象，内部都有默认迭代器，可通过<code>object[Symbol.iterator]()</code>访问默认迭代器。</p>
<p>es6 中也提供了一个通过方法来快速使用迭代器</p>
<pre tabindex="0"><code>for(item of 集合迭代器) {...}
</code></pre><p>常见的迭代器和得到 item 的值：</p>
<ul>
<li>object.keys(): key(对象)/下标(数组)</li>
<li>object.values(): 每项 value</li>
<li>object.entries(): [下标/key, value]</li>
</ul>
<h2 id="事件委托与冒泡和捕获">事件委托与冒泡和捕获<a hidden class="anchor" aria-hidden="true" href="#事件委托与冒泡和捕获">#</a></h2>
<blockquote>
<p>什么是事件委托：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>什么是冒泡和捕获：其实都是事件传播路径。冒泡：从外到事件源进行事件传播；捕获：从内向事件源进行事件传播；</p></blockquote>
<p>DOM 标准事件流的触发的先后顺序为：先捕获再冒泡。即当触发 dom 事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。
<code>addEventListener</code>事件监听方法的第三个参数默认值是<code>false</code>，表示冒泡阶段调用，<code>true</code>为捕获阶段调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>  &lt;<span style="color:#f92672">button</span>&gt;append&lt;/<span style="color:#f92672">button</span>&gt;
</span></span><span style="display:flex;"><span>  &lt;<span style="color:#f92672">ul</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">li</span>&gt;0&lt;/<span style="color:#f92672">li</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">li</span>&gt;1&lt;/<span style="color:#f92672">li</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">li</span>&gt;2&lt;/<span style="color:#f92672">li</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">li</span>&gt;3&lt;/<span style="color:#f92672">li</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">li</span>&gt;4&lt;/<span style="color:#f92672">li</span>&gt;
</span></span><span style="display:flex;"><span>  &lt;/<span style="color:#f92672">ul</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">body</span>&gt;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>window.<span style="color:#a6e22e">onload</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>  document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#34;button&#34;</span>).<span style="color:#a6e22e">onclick</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">li</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#34;li&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">li</span>.<span style="color:#a6e22e">innerHTML</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5&#34;</span>;
</span></span><span style="display:flex;"><span>    document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#34;ul&#34;</span>).<span style="color:#a6e22e">appendChild</span>(<span style="color:#a6e22e">li</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#34;ul&#34;</span>).<span style="color:#a6e22e">onclick</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// li 新增的li也是可以被点击的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">nodeName</span>.<span style="color:#a6e22e">toLowerCase</span>());
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>addeventListener 和 onclick 不同点：</p>
<ul>
<li>addeventListener 可以给一个事件注册多个 listener</li>
<li>addEventListener 可以控制时间传播行为（捕获/冒泡，使用 removeEventListener 来解决）</li>
</ul>
<h2 id="实现-instanceof">实现 instanceof<a hidden class="anchor" aria-hidden="true" href="#实现-instanceof">#</a></h2>
<blockquote>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
<img alt="6D190A1F-A82A-4F86-BC85-3AD9F5EA672B.png" loading="lazy" src="/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/bB3Sj9h8nyoOIVs.png"></p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">objProto</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">__proto__</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">while</span>(<span style="color:#a6e22e">objProto</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">objProto</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">ctor</span>.<span style="color:#a6e22e">prototype</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">objProto</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">objProto</span>.<span style="color:#a6e22e">__proto__</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">Food</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">Meat</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Meat</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Food</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">meat</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Meat</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">newInstanceof</span>(<span style="color:#a6e22e">meat</span>, <span style="color:#a6e22e">Meat</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">newInstanceof</span>(<span style="color:#a6e22e">meat</span>, <span style="color:#a6e22e">Food</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">meat</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">Meat</span> <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">meat</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">Food</span> <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>总的来说就是<code>meat.__proto__.constructor === Meat</code>，由于原型链是一条链，所以循环所有<code>__proto__</code>;
直到<code>null</code>为止，符合<code>Meat.prototype === meat.__proto__</code>即返回<code>true</code>，否则返回<code>false</code>。</p>
<h2 id="constructor-和-super-关键字">constructor 和 super 关键字<a hidden class="anchor" aria-hidden="true" href="#constructor-和-super-关键字">#</a></h2>
<p><code>class</code>是<code>ES6</code>新增的关键字，为了看起来更像<code>java</code>等面向对象语言，实际上是一个语法糖，等同于<code>ES5</code>的<code>function</code>来创建构造函数。</p>
<ul>
<li>constructor ：<code>constructors</code>是 class 中默认的一个关键字，会自动调用该方法，<code>class</code>中必须要有<code>constructor</code>，如果没有，会被默认添加。当 new 时，<code>constructor</code>会被执行返回一个 this，就是实例。</li>
<li>super ： 当<code>class</code>有继承时，在<code>constructor</code>内部必须执行一遍 super()函数，B 继承 A，<code>super</code>相当于<code>A.prototype.constructor.call(this, props)</code>，另外 super()也指向父亲 A 的原型对象， <a href="https://juejin.cn/post/6844903638674980872">详细解释</a>。如果当前类和父类都有同名方法，如何区分地获取呢，获取父类：super().fun，获取当前类：fun</li>
</ul>
<h1 id="vue-部分">vue 部分<a hidden class="anchor" aria-hidden="true" href="#vue-部分">#</a></h1>
<h2 id="vue-组件通信">vue 组件通信<a hidden class="anchor" aria-hidden="true" href="#vue-组件通信">#</a></h2>
<ul>
<li>props 和 $emit</li>
<li>provide inject：在组件 a 声明，在 a 下面所有子组件通过 inject 调用，通过参数传递</li>
<li>event bus： new 出一个 vue，通过 emit 和 on 来派发和监控</li>
<li>vuex 全局状态管理</li>
<li>this.$children 和 this.$parent 层级较深不推荐，provid 可以替代此方法</li>
</ul>
<h2 id="vue-生命周期父子组件执行顺序">vue 生命周期父子组件执行顺序<a hidden class="anchor" aria-hidden="true" href="#vue-生命周期父子组件执行顺序">#</a></h2>
<ul>
<li>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>
</li>
<li>
<p>子组件更新：父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li>
<p>父组件更新：父 beforeUpdate -&gt; 父 updated</p>
</li>
<li>
<p>销毁：父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<p>总结带 beofre 的生命周期都是<strong>从父到子</strong>调用，带 ed 的生命周期都是<strong>从子到父</strong></p>
<h2 id="前端路由">前端路由<a hidden class="anchor" aria-hidden="true" href="#前端路由">#</a></h2>
<h3 id="hash">hash<a hidden class="anchor" aria-hidden="true" href="#hash">#</a></h3>
<p>14 年前，前端路由都是用 hash 的方式实现的，地址长这个样子<strong>url#hash</strong>， 修改<code>hash</code>部分不会重载这个页面，每次 hash 改变，可以用 window 的<code>hashchange</code>方法来监听，通过这个方法就可以实现前端路由了</p>
<h3 id="history">history<a hidden class="anchor" aria-hidden="true" href="#history">#</a></h3>
<p>在 14 年，HTML5 标准发布，window 上新增了两个 api：<code>pushState</code>和<code>replaceState</code>，也 hash 一样，不刷新来实现前端路由，而且少了#更美观了，由于没#，所以刷新时候，默认会从服务器下载对应 url 资源，这个时候我们需要改下服务器配置，都加载前端 index.html 文件，来实现前端路由</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 第一个参数是state，用于描述一些特性，会被放入历史栈中，开发者使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 第二个参数是title，表示新页面的标题，浏览器都会忽略这个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 第二个参数是url，表示新页面的相对地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 跳转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>window.<span style="color:#a6e22e">history</span>.<span style="color:#a6e22e">pushState</span>(<span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#34;/profile&#34;</span>);
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">history</span>.<span style="color:#a6e22e">replaceState</span>(<span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#34;/profile&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">和pushState的区别是不会把记录放入历史栈中</span>;
</span></span></code></pre></div><h4 id="共同点">共同点<a hidden class="anchor" aria-hidden="true" href="#共同点">#</a></h4>
<ul>
<li>都不会重载页面</li>
<li>都会把历史记录放入栈中</li>
</ul>
<h4 id="不同点">不同点<a hidden class="anchor" aria-hidden="true" href="#不同点">#</a></h4>
<ul>
<li>hash 只可以#后部分，必须是同源 url，history 没有限制</li>
<li>history 需要修改服务器配置，来解决刷新空白问题，hash 本身就是属于前端的，不需要设置</li>
</ul>
<h2 id="slot-插槽">slot 插槽<a hidden class="anchor" aria-hidden="true" href="#slot-插槽">#</a></h2>
<ul>
<li>匿名插插: 子组件包裹的内容会被显示到<code>slot</code>标签中</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">child</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">父给子的内容</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/child&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// child组件中, 父给子的内容会显示slot标签里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">slot</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">父给子的内容</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/slot&gt;</span>
</span></span></code></pre></div><ul>
<li>具名插插：感觉名字多次显示，可复用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">slot</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;down&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;的内容</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">会被显示到</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">slot</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;down&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/slot&gt;里</span>
</span></span></code></pre></div><ul>
<li>数据插槽：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 父亲中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">v</span><span style="color:#f92672">-</span><span style="color:#a6e22e">slot</span><span style="color:#f92672">:</span><span style="color:#a6e22e">data</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{data}&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 组件中就可以用data了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">myslot</span> <span style="color:#a6e22e">v</span><span style="color:#f92672">-</span><span style="color:#a6e22e">slot</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;data&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span> {{ <span style="color:#a6e22e">slotProps</span>.<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">firstName</span> }}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/myslot&gt;</span>
</span></span></code></pre></div><h2 id="keep-alive">keep-alive<a hidden class="anchor" aria-hidden="true" href="#keep-alive">#</a></h2>
<p>keep-live 是 vue 提供的内置缓存组件，可以保存组件状态，避免重新渲染，keep-alive 有三个参数：</p>
<ul>
<li>include 匹配的组件会被缓存，参数：字符串、数组、正则</li>
<li>exclude 匹配的组件不会被缓存，参数：字符串、数组、正则，和 include 同时存在一个组件的的话，exclude 优先级更高</li>
<li>max 可以限制最大可以缓存组件的数量，字符串或者数字</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">&lt;!--</span> <span style="color:#a6e22e">组件name为a或者b的组件缓存</span> <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">keep</span><span style="color:#f92672">-</span><span style="color:#a6e22e">alive</span> <span style="color:#a6e22e">include</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;a,b&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">component</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/component&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/keep-alive&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!--</span> <span style="color:#a6e22e">组件name为c的组件不缓存</span> <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">keep</span><span style="color:#f92672">-</span><span style="color:#a6e22e">alive</span> <span style="color:#a6e22e">exclude</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">component</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/component&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/keep-alive&gt;</span>
</span></span></code></pre></div><p>缓存组件会多出两个生命周期，<code>activated</code>和<code>deactivated</code>，渲染和销毁</p>
<p>keep-alive 可配合 router-view 来实现组件缓存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">keep</span><span style="color:#f92672">-</span><span style="color:#a6e22e">alive</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">router</span><span style="color:#f92672">-</span><span style="color:#a6e22e">view</span> <span style="color:#a6e22e">v</span><span style="color:#f92672">-</span><span style="color:#66d9ef">if</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;$route.meta.keepAlive&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/router-view&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/keep-alive&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">router</span><span style="color:#f92672">-</span><span style="color:#a6e22e">view</span> <span style="color:#a6e22e">v</span><span style="color:#f92672">-</span><span style="color:#66d9ef">if</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;!$route.meta.keepAlive&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/router-view&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Router</span>({
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">routes</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">path</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;/&#39;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;a&#39;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">component</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">a</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">meta</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">keepAlive</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> <span style="color:#75715e">// 不缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">path</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;/b&#39;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;b&#39;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">component</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">b</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">meta</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">keepAlive</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span> <span style="color:#75715e">// 缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="nexttick">nextTick<a hidden class="anchor" aria-hidden="true" href="#nexttick">#</a></h2>
<p>nextTick 可以获取下次最新 dom 的方法，因为 vue 的 dom 更新策略是异步的，只有一个事件循环结束后才会被应用来更新 dom，这导致数据的修改不会立即表现在 dom 上，如果要获取更新后的 dom 状态，这时候就需要用到 nextTick</p>
<p>一些场景：</p>
<ul>
<li>created 中想要获取 DOM</li>
<li>更改数据获取最新的 dom</li>
</ul>
<h2 id="mixin">mixin<a hidden class="anchor" aria-hidden="true" href="#mixin">#</a></h2>
<p>vue mixin 是针对组件间功能共享来做的。可以对组件的任意部分进行 mixin，也就是说不同的组件，想使用同一个数组，或者方法，那么 mixin 就是来做这个事的，把公共部分提取出来作为 mixin</p>
<p>声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">toggle</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">data</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">isshowing</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">methods</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">toggleShow</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isshowing</span> <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isshowing</span>;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用，toggle的方法会自动合并到当前组件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mixins</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">toggle</span>];
</span></span></code></pre></div><h2 id="vuex">vuex<a hidden class="anchor" aria-hidden="true" href="#vuex">#</a></h2>
<p>核心概念：</p>
<ul>
<li>state：数据</li>
<li>getter：类似计算属性，用来获取 state</li>
<li>mutation： 同步方法，用于修改 state</li>
<li>action： 异步方法，最后调用 mutation 修改 state</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Vuex</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;vuex&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">store</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Vuex</span>.<span style="color:#a6e22e">Store</span>({
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">state</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getter</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doneTodos</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">state</span>, <span style="color:#a6e22e">getters</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">todos</span>.<span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">todo</span> =&gt; <span style="color:#a6e22e">todo</span>.<span style="color:#a6e22e">done</span>)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">state</span>) =&gt; {
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">mutations</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">increment</span> (<span style="color:#a6e22e">state</span>, <span style="color:#a6e22e">payload</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">actions</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">addCount</span>(<span style="color:#a6e22e">context</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 可以包含异步操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// context 是一个与 store 实例具有相同方法和属性的 context 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 调用mutation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">$store</span>.<span style="color:#a6e22e">commit</span>(<span style="color:#e6db74">&#39;increment&#39;</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 调用actions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">$store</span>.<span style="color:#a6e22e">dispatch</span>(<span style="color:#e6db74">&#39;increment&#39;</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 利用mapGetters mapGetters mapMutations mapActions便捷使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">computed</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>	...<span style="color:#a6e22e">mapGetters</span>([<span style="color:#e6db74">&#39;audio&#39;</span>]),
</span></span><span style="display:flex;"><span>	...<span style="color:#a6e22e">mapState</span>({
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span> <span style="color:#a6e22e">等同于</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">localCount</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">count</span>(<span style="color:#a6e22e">state</span>) {
</span></span><span style="display:flex;"><span>	      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">localCount</span>
</span></span><span style="display:flex;"><span>	    }
</span></span><span style="display:flex;"><span>},
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">methods</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>  ...<span style="color:#a6e22e">mapMutations</span>({
</span></span><span style="display:flex;"><span>  	  <span style="color:#a6e22e">add</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;increment&#39;</span> <span style="color:#75715e">// 将 `this.add()` 映射为`this.$store.commit(&#39;increment&#39;)`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }),
</span></span><span style="display:flex;"><span>  ...<span style="color:#a6e22e">mapActions</span>({
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">add</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;increment&#39;</span> <span style="color:#75715e">// 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="react-部分">react 部分<a hidden class="anchor" aria-hidden="true" href="#react-部分">#</a></h1>
<h2 id="react-生命周期">react 生命周期<a hidden class="anchor" aria-hidden="true" href="#react-生命周期">#</a></h2>
<ul>
<li><strong>componentWillMount</strong>：在渲染前调用，客户端服务端都会调用</li>
<li><strong>componentDidMount</strong>：第一次渲染后调用，只在客户端</li>
<li><strong>componentWillReceiveProps</strong>： 接收新的 props 被调用，初始化时不会被调用</li>
<li><strong>shouldComponentUpdate</strong>： 组件更新(props,state)时调用；返回布尔值，T 为允许更新组件，F 为不更新组件</li>
<li><strong>componentWillUpdate</strong>： 组件更新(props,state)前渲染前被调用，初始化时不会调用</li>
<li><strong>componentDidUpdate</strong>：组件完成更新后调用。初始化时不会被调用</li>
<li><strong>componentWillUnmount</strong>： 组件要销毁前调用</li>
</ul>
<h2 id="react-数据响应式">react 数据响应式<a hidden class="anchor" aria-hidden="true" href="#react-数据响应式">#</a></h2>
<p>react 的响应式是使用 diff 算法实现的。react 在 state 改变时，会调用 render() 方法，生成一个虚拟 DOM 树，React 会将这棵树与上一次生成的树进行比较，找出其中的差异，并更新差异的部分。这个过程是递归的，react 会以当前组件为根，递归比较所以子节点。为了优化性能，React 提供了 shouldComponentUpdate 生命周期方法，这个方法有两个参数，<strong>nextProps</strong>和<strong>nextState</strong>，表示上次 props 和上次 stage，返回值是布尔值，如果这个方法返回 false，react 就跳过这个组件，不做 VDOM 比较，也不更新组件。</p>
<p>在 react16+版本，对 diff 过程进行了优化，从原来的 diff 树结构+递归的方式优化成 fiber 双向链表+循环执行。整个的 diff 过程分为 render 阶段和 commit 阶段，render 就是对比过程，找到需要改变 dom 的那部分，commit 就是执行改变 dom 的那部分，render 阶段是可以分段的（中断，然后继续完成），类似原生的<strong>requestIdleCallback</strong>方法，在每个 16ms 帧内，会先执行用户输入，事件回调等优先级高的 js 任务。之后剩下的时间执行分段的 render 部分来进行数据更新，保证视觉上的页面流程度。</p>
<h1 id="http-部分">http 部分<a hidden class="anchor" aria-hidden="true" href="#http-部分">#</a></h1>
<h2 id="http-缓存">http 缓存<a hidden class="anchor" aria-hidden="true" href="#http-缓存">#</a></h2>
<p>分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong>，如果同时存在，<strong>强缓存</strong> 优先 <strong>协商缓存</strong></p>
<h3 id="强缓存">强缓存：<a hidden class="anchor" aria-hidden="true" href="#强缓存">#</a></h3>
<ul>
<li>响应头 Expires：<em>Fri, 31 Dec 2024 23:59:59 GMT</em>，在这个时间之前，直接读缓存，否则请求新内容，因为值是一个服务端返回的时间，这是 http 1.0 的产物，如果客户端和服务端时间不一致，就会和预期不符，所以在 http 1.1 中新增 Cache Control 来控制缓存</li>
<li>Cache Control：max-age=x 秒，在 x 秒内直接读缓存，避免了 expires 时间不一致问题</li>
</ul>
<p>Cache Control 其他的 value：</p>
<ul>
<li>Private: 私有缓存，资源可以仅可以被客户端缓存（默认值）</li>
<li>Public: 资源可以被任何缓存（包括中间代理服务器）缓存</li>
<li>No-Cache: 协商缓存</li>
<li>No-Store: 绝对不缓存</li>
<li>Max-Age：强缓存</li>
</ul>
<h3 id="协商缓存-last-modified-优先-etag">协商缓存 （Last-Modified 优先 ETag）<a hidden class="anchor" aria-hidden="true" href="#协商缓存-last-modified-优先-etag">#</a></h3>
<p>当 Cache Control 设置为 No-Cache 时使用</p>
<ul>
<li>Last-Modified / If-Modified-Since：服务器会返回上次修改时间 Last-Modified，浏览器下次请求时请求头会带上 If-Modified-Since ，然后由服务端验证，如果 If-Modified-Since 在 Last-Modified 时间以内 ，就返回 304，浏览器读缓存，否则返回新内容</li>
<li>ETag / If-None-Match：服务器会返回内容 hash ETag 响应头，浏览器下次请求时请求头会带上 If-None-Match ，然后由服务端验证，如果一致，就返回 304，浏览器读缓存，否则返回新内容</li>
</ul>
<p>附上一张说明图：</p>
<p><img alt="632130-20170210141453338-1263276228.png" loading="lazy" src="/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/FvAIM258yHCTQba.png"></p>
<h2 id="https-握手">https 握手<a hidden class="anchor" aria-hidden="true" href="#https-握手">#</a></h2>
<p>https 是 http 的安全扩展，相当于 HTTP + SSL(TLS) = HTTPS。SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层即网络层，TLS 是 SSL 的新版本，最后一个 SSL 3.0 版本在 2015 年废弃，之后就是 TLS，现在常见的 TLS 版本是 1.2 和 1.3 版本。那么 TLS 是如何实现的呢？</p>
<ul>
<li><strong>浏览器</strong> =&gt; 服务器：请求发起，建立 SSL 连接，发送 TLS 协议版本号 + 支持的加密方法列表 + 客户端随机数</li>
<li>服务器 =&gt; <strong>浏览器</strong>：判断加密协议版本是否一致，并确认加密方法，都没问题则返回服务器证书 + 服务端随机数</li>
<li><strong>浏览器</strong> =&gt; 服务器：收到服务器证书，检查颁发机构、过期时间、域名，没有问题，则生成一个字符串（通过上面 客户端随机数 + 服务端随机数 生成），并用公钥（从服务器证书里取出）加密（非对称加密），发给服务器</li>
<li>服务器 =&gt; <strong>浏览器</strong>：服务器用自己的私钥解密，得到这个字符串，后续使用这个字符串进行对称加密进行通信</li>
</ul>
<h2 id="http1-1长连接和http2多路复用区别"> http1.1长连接和http2多路复用区别<a hidden class="anchor" aria-hidden="true" href="#http1-1长连接和http2多路复用区别">#</a></h2>
<h3 id="http11-长连接">http1.1 长连接<a hidden class="anchor" aria-hidden="true" href="#http11-长连接">#</a></h3>
<p>同一个域名访问同一个文件的多个请求都可以复用一个 tcp 连接（不用像 1.0 一样 每次请求都需要重新建立连接，但不是并行，只能按顺序执行。</p>
<h3 id="http2-多路复用">http2 多路复用<a hidden class="anchor" aria-hidden="true" href="#http2-多路复用">#</a></h3>
<p>同一个域名访问多个文件的多个请求也可以复用一个 tcp 连接，且多个请求可以被并行处理。</p>
<h1 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h1>
<h2 id="npmrun">npmRun<a hidden class="anchor" aria-hidden="true" href="#npmrun">#</a></h2>
<p>会自动到 package.json 找到对应的命令执行。如果没有全局命令，会自动到<code>node_modules/.bin/</code>下找到对应可执行文件执行，这时<code>npm run xxx</code>等同于直接调用<code>/images/node_modules/.bin/xxx</code></p>
<h2 id="cookie-的几种属性和作用">cookie 的几种属性和作用<a hidden class="anchor" aria-hidden="true" href="#cookie-的几种属性和作用">#</a></h2>
<ul>
<li><strong>name</strong>: 名字</li>
<li><strong>value</strong>: 值</li>
<li><strong>domain</strong>: 可以访问此 cookie 的域名</li>
<li><strong>path</strong>: 可以访问此 cookie 的路径</li>
<li><strong>sameSite</strong>: 跨站点携带 cookie 设置
<ul>
<li>None：不限制；</li>
<li>Lax：默认值，介于 None 和 Strict 之间，会合理判断携带 cookie 时机，如链接 a 会携带 cookie；</li>
<li>Strict：完全禁止跨站点传送 cookie；</li>
</ul>
</li>
<li><strong>httponly</strong>: 值为 true 则仅在 http 请求中会传递 cookie，不可用 document.cookie 等操作获取</li>
<li><strong>secure</strong>: 是否只能使用 https 传递此 cookie</li>
<li><strong>expires</strong>: 过期时间；值是时间意思是到这个时间，cookie 失效，否则是 session，即退出浏览器后自动失效</li>
</ul>
<h2 id="输入-url-到页面展示经历了什么">输入 url 到页面展示经历了什么<a hidden class="anchor" aria-hidden="true" href="#输入-url-到页面展示经历了什么">#</a></h2>
<ul>
<li>
<p><strong>dns 解析</strong>：按照这个步骤查询，找到 ip，立即中断返回给客户端（浏览器缓存 =&gt; 操作系统缓存(host) =&gt; 路由器缓存 =&gt; 本地服务器缓存 =&gt; isp dnf 服务器查询 =&gt; 根 dns 服务器）</p>
</li>
<li>
<p><strong>tcp 三次握手</strong></p>
</li>
<li>
<p><strong>发送 http 请求报文</strong>：报文包括：请求行，请求头，请求体</p>
</li>
<li>
<p><strong>服务端接收到请求</strong>： 进入 web 服务器，如 apache、nginx，然后进入后台程序</p>
</li>
<li>
<p><strong>服务器响应报文</strong>：报文包括：响应行，响应头，响应体</p>
</li>
<li>
<p><strong>浏览器渲染页面</strong></p>
<ol>
<li>根据 html 得到 dom 树</li>
<li>根据 css 得到 css 树</li>
<li>根据 dom 树和 css 树，生成渲染树</li>
<li>根据渲染树计算每一个节点的信息</li>
<li>根据计算好的信息绘制页面</li>
</ol>
</li>
<li>
<p><strong>数据传送完成，四次挥手关闭</strong>：</p>
</li>
</ul>
<h2 id="懒加载">懒加载<a hidden class="anchor" aria-hidden="true" href="#懒加载">#</a></h2>
<p>页面中一些大资源加载较慢，比如 iframe，img。针对这个问题可以通过懒加载解决。</p>
<p>拿<code>img</code>举例，先设置<code>img</code>的<code>src</code>属性为一个默认的资源，然后把真实<code>url</code>放在标签的某个属性中。并设置好图片的宽高，避免完成加载时出现页面闪动问题。</p>
<p>然后实时监听页面滚动，如果当前图片是可见状态，那么把图片的真实 url 属性值取出替换到默认<code>src</code>上来实现加载图片资源，从而提升页面打开速度和合理使用客户端流量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 获取浏览设备的网页可视高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">clientHeight</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">documentElement</span>.<span style="color:#a6e22e">clientHeight</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取已被滚出的页面高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scrollTop</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">documentElement</span>.<span style="color:#a6e22e">scrollTop</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 图片顶部到网页顶部的高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">imgOffsetTop</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#34;img&#34;</span>).<span style="color:#a6e22e">offsetTop</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断img在可视区域内：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">imgOffsetTop</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">clientHeight</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">scrollTop</span>;
</span></span></code></pre></div><h2 id="commonjs-模块和-es6-模块有什么区别">commonjs 模块和 es6 模块有什么区别<a hidden class="anchor" aria-hidden="true" href="#commonjs-模块和-es6-模块有什么区别">#</a></h2>
<p>commonjs:</p>
<ul>
<li>对于基本数据类型，是值的拷贝</li>
<li>对于复杂数据类型，是浅拷贝，也就是修改一个模块的值，引用他的值也会发生改变</li>
<li>第一次加载模块会缓存，往后再加载会读取缓存的数据</li>
</ul>
<p>es6：</p>
<ul>
<li>所有数据都是只读引用，当遇到 import 语句时，会生成一个只读引用，等到文件中真的使用到模块中的值时，根据只读引用，到加载中的模块取值</li>
<li>不允许修改模块中的数据，并且是动态的，比如模块中的值发生改变，引入得到的值也会改变。</li>
</ul>
<h2 id="前端优化">前端优化<a hidden class="anchor" aria-hidden="true" href="#前端优化">#</a></h2>
<ul>
<li>静态资源放在 cdn</li>
<li>首屏加载服务端渲染</li>
<li>可以升级到 http2，可以使用 http2 多路复用 多个请求并行，可以打乱顺序，最后重组</li>
<li>使用字体图标替代图片</li>
<li>gzip 压缩</li>
<li>uglify plugin 优化压缩代码</li>
<li>图片懒加载</li>
<li>图片压缩，优先使用 webp</li>
<li>减少重排，多使用类名或者 csstext 处理样式</li>
<li>多使用 flex，性能优，兼容性好</li>
</ul>
<h2 id="常见算法介绍">常见算法介绍<a hidden class="anchor" aria-hidden="true" href="#常见算法介绍">#</a></h2>
<ul>
<li>
<p><strong>二分查找</strong>：也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。</p>
</li>
<li>
<p><strong>贪心算法</strong>：又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），贪图眼前局部的利益最大化。</p>
</li>
<li>
<p><strong>回溯算法</strong>：实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
</li>
<li>
<p><strong>分治算法</strong>：分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
</li>
<li>
<p><strong>动态规划</strong>：动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p>
</li>
</ul>
<h2 id="babel-工作原理">babel 工作原理<a hidden class="anchor" aria-hidden="true" href="#babel-工作原理">#</a></h2>
<blockquote>
<p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。简单来说就是一种描述源代码的结构，用于被计算机识别到，并成语言引擎执行</p></blockquote>
<p>工作原理大致可以理解成，<code>字符串输入</code>=&gt;<code>转换</code>=&gt;<code>输出</code></p>
<ul>
<li>根据 babylon 解析器，把 js 代码按照规范解析成 AST 语法树</li>
<li>按照规则(stage-0,1,2,3),修改 AST 语法树，常见把高级语法，转换成低级语法</li>
<li>最后通过 babel-generator 将修改后的 AST 语法树转换成 js 代码</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://slc3a2.github.io/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://slc3a2.github.io/blogs/%E7%9C%9F%E7%9D%A1%E5%90%8E%E6%94%B6%E5%85%A5gtx1660s%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E5%B0%8F%E8%AE%B0/">
    <span class="title">« 上一页</span>
    <br>
    <span>真睡后收入-以太坊挖矿小记</span>
  </a>
  <a class="next" href="https://slc3a2.github.io/blogs/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">
    <span class="title">下一页 »</span>
    <br>
    <span>Vue 中的 diff 算法实现</span>
  </a>
</nav>

  </footer><script>
  function createGiscusScript(data) {
    const giscusScript = document.createElement("script");

    Object.entries(data).forEach(([key, value]) =>
      giscusScript.setAttribute(key, value)
    );

    document.querySelector("article").appendChild(giscusScript);

    const toggle = document.querySelector('label[for="switch_default"]');
    if (toggle) {
      toggle.addEventListener("click", function () {
        const theme = document.body.classList.contains("dark")
          ? "transparent_dark"
          : "light";

        console.log(theme);
        giscusScript.setAttribute("data-theme", theme);

        sendMessage({ setConfig: { theme } });
      });
    }
  }

  function sendMessage(message) {
    const iframe = document.querySelector("iframe.giscus-frame");
    if (iframe) {
      iframe.contentWindow.postMessage(
        { giscus: message },
        "https://giscus.app"
      );
    }
  }

  document.addEventListener("DOMContentLoaded", function () {
    
    const giscusAttributes = {
      src: "https://giscus.app/client.js",
      "data-repo": "slc3a2/slc3a2.github.io",
      "data-repo-id": "R_kgDOOOP9Qg",
      "data-category": "Announcements",
      "data-category-id": "DIC_kwDOOOP9Qs4Cof61",
      "data-mapping": "title",
      "data-strict": "0",
      "data-reactions-enabled": "1",
      "data-emit-metadata": "0",
      "data-input-position": "top",
      "data-theme": "preferred_color_scheme",
      "data-lang": "zh-CN",
      crossorigin: "anonymous",
      async: "",
    };

    giscusAttributes["data-theme"] = document.body.classList.contains("dark")
      ? "transparent_dark"
      : "light";

    createGiscusScript(giscusAttributes);

    const bodyObserver = new MutationObserver(() => {
      const theme = document.body.classList.contains("dark")
        ? "transparent_dark"
        : "light";
      sendMessage({ setConfig: { theme } });
    });

    bodyObserver.observe(document.body, {
      attributes: true,
      attributeFilter: ["class"],
    });
  });
</script>

</article>

<script src="/js/view-image.min.js"></script>
<script>
  window.ViewImage && ViewImage.init("main.main img");
</script>
    </main>
    
<footer class="footer">
        <span>&copy; 2016 - 2025 <a href="https://slc3a2.github.io/">slc3a2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数 <span id="busuanzi_value_site_uv"></span> 人次
    </span>
    </div></footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
