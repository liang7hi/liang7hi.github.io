<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>前端 on slc3a2</title>
    <link>http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on slc3a2</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 22 Jun 2022 18:06:30 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>js 是如何存储数字的</title>
      <link>http://localhost:1313/blogs/js%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E5%AD%97%E7%9A%84/</link>
      <pubDate>Wed, 22 Jun 2022 18:06:30 +0800</pubDate>
      <guid>http://localhost:1313/blogs/js%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E5%AD%97%E7%9A%84/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;为什么要写这篇博客&#34;&gt;为什么要写这篇博客&lt;/h2&gt;
&lt;p&gt;最近在和同事午饭的时候聊到这个问题。想到了刚接触编程时粗略了解过，但是又没办法讲清楚，所以决定利用这篇博客复习一下。也希望给相关的二进制存储的疑问画上一个句号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>浏览器事件循环</title>
      <link>http://localhost:1313/blogs/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 06 Mar 2022 10:53:20 +0800</pubDate>
      <guid>http://localhost:1313/blogs/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid>
      <description>&lt;h2 id=&#34;为什么要总结这个问题&#34;&gt;为什么要总结这个问题&lt;/h2&gt;
&lt;p&gt;这几天和我的同事聊到这个问题，他提出了一些深入的问题，我想了想，也有相同的疑问。真是验证了那句话，了解的越多就发现自己了解的越少！所以被迫研究了下这个问题总结起来。便于以后查看和补充。&lt;/p&gt;</description>
    </item>
    <item>
      <title>前端面试题总结</title>
      <link>http://localhost:1313/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 21 Dec 2020 19:06:55 +0800</pubDate>
      <guid>http://localhost:1313/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;!-- [HTML 和 CSS 部分](#HTML和CSS)

- [BFC](#BFC)
- [重排和重绘](#重排和重绘)
- [行内元素特点](#行内元素特点)
- [实现换肤功能](#实现换肤功能)
- [link 和@import 区别](#link和@import区别)
- [为什么要使用 css 预处理语言](#为什么要使用css预处理语言)
- [src 和 href 的区别](#src和href的区别)

[js 部分](#js部分)

- [箭头函数和普通函数区别](#箭头函数和普通函数区别)

- [script 的 defer 和 async 属性区别](#script的defer和async属性区别)
- [深拷贝](#深拷贝)
- [函数防抖和节流](#函数防抖和节流)
- [继承](#继承)
- [跨域](#跨域)
- [数组方法](#数组方法)
- [字符串方法](#字符串方法)
- [js 垃圾回收机制](#js垃圾回收机制)
- [类型检测](#类型检测)
- [valueOf 和 toString](#valueOf和toString)
- [proxy 和 reflect](#proxy和reflect)
- [requestAnimationFrame](#requestAnimationFrame)
- [事件循环](#事件循环)
- [迭代器和生成器](#迭代器和生成器)
- [事件委托与冒泡和捕获](#事件委托与冒泡和捕获)
- [实现 instanceof](#实现instanceof)
- [constructor 和 super 关键字](#constructor和super关键字)

[vue 部分](#vue部分)

- [vue 组件通信](#vue组件通信)
- [vue 生命周期父子组件执行顺序](#vue生命周期父子组件执行顺序)
- [前端路由](#前端路由)
- [slot 插槽](#slot插槽)
- [keep-alive](#keep-alive)
- [nextTick](#nextTick)
- [mixin](#mixin)
- [vuex](#vuex)

[react 部分](#深拷贝)

- [react 生命周期](#react生命周期)
- [react 数据响应式](#react数据响应式)

[http 部分](#http部分)

- [http 缓存](#http缓存)
- [https 握手](#https握手)
- [http1.1 长连接和 http2 多路复用区别](#http1-1长连接和http2多路复用区别)

[其他](#其他)

- [npm run](#npmRun)
- [cookie 的几种属性和作用](#cookie的几种属性和作用)
- [输入 url 到页面展示经历了什么](#输入url到页面展示经历了什么)
- [懒加载](#懒加载)
- [commonjs 模块和 es6 模块有什么区别](#commonjs模块和es6模块有什么区别)
- [前端优化](#前端优化)
- [常见算法介绍](#常见算法介绍)
- [babel 工作原理](#babel工作原理) --&gt;
&lt;h1 id=&#34;html-和-css&#34;&gt;HTML 和 CSS&lt;/h1&gt;
&lt;h2 id=&#34;bfc&#34;&gt;BFC&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;全称「块格式化上下文」(Block Formatting Context), 是一块独立的 css 作用域，外部如何变化都影响不到他。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vue 中的 diff 算法实现</title>
      <link>http://localhost:1313/blogs/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 05 Nov 2020 18:36:39 +0800</pubDate>
      <guid>http://localhost:1313/blogs/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>介绍 React 和 Vue 中虚拟 DOM 替代直接操作 DOM 的原理，详细阐述 diff 算法如何比对新旧虚拟 DOM 实现高效更新</description>
    </item>
    <item>
      <title>Promise 的实现</title>
      <link>http://localhost:1313/blogs/promise-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 30 Oct 2020 16:59:53 +0800</pubDate>
      <guid>http://localhost:1313/blogs/promise-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>实现了一个简易的 Promise 类，并对 Promise.all 和 Promise.race 方法进行了自定义实现</description>
    </item>
    <item>
      <title>基于 Vue 思想的 MVVM 实现</title>
      <link>http://localhost:1313/blogs/vue%E5%8E%9F%E7%90%86mvvm%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 27 Oct 2020 18:46:33 +0800</pubDate>
      <guid>http://localhost:1313/blogs/vue%E5%8E%9F%E7%90%86mvvm%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>一个简单的基于 Vue 思想实现的 MVVM 数据架构的代码示例，这里我们将实现一个简单的响应式数据绑定功能</description>
    </item>
    <item>
      <title>函数的防抖和节流</title>
      <link>http://localhost:1313/blogs/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</link>
      <pubDate>Tue, 20 Oct 2020 18:02:56 +0800</pubDate>
      <guid>http://localhost:1313/blogs/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</guid>
      <description>&lt;h2 id=&#34;防抖debounce&#34;&gt;防抖（debounce）&lt;/h2&gt;
&lt;h3 id=&#34;什么是防抖&#34;&gt;什么是防抖？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个函数被触发&lt;code&gt;n&lt;/code&gt;秒后，才执行此函数&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;n&lt;/code&gt;秒内再次触发此函数，那么重新以再次触发的时间开始重新延迟 n 秒后执行此函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的函数 &lt;strong&gt;执行行为&lt;/strong&gt; 叫做函数防抖。&lt;/p&gt;</description>
    </item>
    <item>
      <title>flex 布局介绍</title>
      <link>http://localhost:1313/blogs/flex%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 11 Sep 2020 14:03:49 +0800</pubDate>
      <guid>http://localhost:1313/blogs/flex%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;h2 id=&#34;flex-布局概念&#34;&gt;flex 布局概念&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;flex&lt;/code&gt;布局通常被叫做&lt;code&gt;flex box&lt;/code&gt;，也叫&lt;code&gt;弹性盒子&lt;/code&gt;或&lt;code&gt;容器&lt;/code&gt;，是一种一维的&lt;code&gt;布局模型&lt;/code&gt;，它能子元素(&lt;code&gt;flex item&lt;/code&gt;)之间提供了强大的空间分布和对齐能力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 css 实现环状进度</title>
      <link>http://localhost:1313/blogs/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/</link>
      <pubDate>Sat, 22 Aug 2020 09:44:03 +0800</pubDate>
      <guid>http://localhost:1313/blogs/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/</guid>
      <description>使用纯 css 实现一个圆环的进度效果，主要使用了&lt;code&gt;background-image&lt;/code&gt;渐变属性和动画状态的&lt;code&gt;伪元素遮盖&lt;/code&gt;来实现</description>
    </item>
  </channel>
</rss>
