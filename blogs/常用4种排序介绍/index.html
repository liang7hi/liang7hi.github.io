<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>常用4种排序介绍 | slc3a2</title>
<meta name=keywords content="计算机科学"><meta name=description content="冒泡排序（Bubble sort）
原理和演示：

依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。

function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] > arr[i + 1]) {
      let temp = arr[i];
      arr[i] = arr[i + 1];
      arr[i + 1] = temp;
    }
    console.log(`执行${i + 1}次`);
  }
  return arr;
}


通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。"><meta name=author content="slc3a2"><link rel=canonical href=https://slc3a2.github.io/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/><link crossorigin=anonymous href=/assets/css/stylesheet.03380b421b43a59cef22aa8ddc67c8077da9081a7c7a95ef8104001f8af6ac13.css integrity="sha256-AzgLQhtDpZzvIqqN3GfIB32pCBp8epXvgQQAH4r2rBM=" rel="preload stylesheet" as=style><link rel=icon href=https://slc3a2.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slc3a2.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slc3a2.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://slc3a2.github.io/apple-touch-icon.png><link rel=mask-icon href=https://slc3a2.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://slc3a2.github.io/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://slc3a2.github.io/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/"><meta property="og:site_name" content="slc3a2"><meta property="og:title" content="常用4种排序介绍"><meta property="og:description" content="冒泡排序（Bubble sort） 原理和演示： 依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。 function bubbleSort(arr) { for (let i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { let temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } console.log(`执行${i + 1}次`); } return arr; } 通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2020-09-02T16:07:43+08:00"><meta property="article:modified_time" content="2020-09-02T16:07:43+08:00"><meta property="article:tag" content="计算机科学"><meta property="og:image" content="https://slc3a2.github.io/images/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://slc3a2.github.io/images/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8/cover.jpg"><meta name=twitter:title content="常用4种排序介绍"><meta name=twitter:description content="冒泡排序（Bubble sort）
原理和演示：

依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。

function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] > arr[i + 1]) {
      let temp = arr[i];
      arr[i] = arr[i + 1];
      arr[i + 1] = temp;
    }
    console.log(`执行${i + 1}次`);
  }
  return arr;
}


通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"日志","item":"https://slc3a2.github.io/blogs/"},{"@type":"ListItem","position":2,"name":"常用4种排序介绍","item":"https://slc3a2.github.io/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"常用4种排序介绍","name":"常用4种排序介绍","description":"冒泡排序（Bubble sort） 原理和演示： 依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。 function bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length - 1; i++) { if (arr[i] \u0026gt; arr[i + 1]) { let temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } console.log(`执行${i + 1}次`); } return arr; } 通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。\n","keywords":["计算机科学"],"articleBody":"冒泡排序（Bubble sort） 原理和演示： 依次比较数组中相邻的每一对值，如果前面的值 大于 后面的值，则交换他们俩的位置。如果数组中5个数字(length 为 5)，由于比较 两个一组 的数字，那么只需要4次(length - 1)比较，就可以实现把数组中最大的一个数放到最后。 function bubbleSort(arr) { for (let i = 0; i \u003c arr.length - 1; i++) { if (arr[i] \u003e arr[i + 1]) { let temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } console.log(`执行${i + 1}次`); } return arr; } 通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，j对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数- 1也就是下面例子中的- j。\nfunction bubbleSort(arr) { for (let i = 0; i \u003c arr.length - 1; i++) { for (let j = 0; j \u003c arr.length - 1 - i; j++) { if (arr[j] \u003e arr[j + 1]) { let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } console.log(`执行${i + 1}次`); } } return arr; } 两个变量互换值可以使用es6的解构语法，省去使用temp缓存，语法为[a, b] = [b, a]，即可交换变量a和变量b的值。复杂数据类型Object和Array都适用；如果第二个循环中的大小判断，一次都没有执行，说明当前这组数据是正序无需排序，用一个变量isOk标记下配合break，实现方法优化。\n完整代码： function bubbleSort(arr) { console.time(\"耗时\"); for (let i = 0, len = arr.length; i \u003c len - 1; i++) { // 要比对的次数，- 1是因为6个数俩俩比较只需要比对5次 let isOk = true; for (let j = 0; j \u003c arr.length - 1 - i; j++) { // 当前和下一项的每次比较。完整进行一次比较后，最大的值就会在最后一位，- i意味着最大这个值不再需要比对了 if (arr[j] \u003e arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 当前值小于下一项，交换位置 isOk = false; // 如果第一次比较时，没有发现一个有效条件，那么说明整个数组默认就是排好序的 } } if (isOk) { break; } } console.timeEnd(\"耗时\"); return arr; } 冒泡排序动画演示： 选择排序（Selection Sort） 原理： 循环整个数组，找到最小的值，放在数组第一位(和第一位交换位置）。 从数组第二位开始重新循环，依旧找到最小的值，放在数组第二位，重复此步骤，直到对比完最后一组数据。 完整代码： function selectionSort(arr) { for (let i = 0; i \u003c arr.length - 1; i++) { // arr.length - 1是因为假定数组中n个数，比较需要两个数，所以只需要比较n-1次 let minIndex = i; // 记录每次循环开始位置，等待和最小值交换位置 for (let j = i + 1; j \u003c arr.length; j++) { // j+1 是避免比较自身，j永远是i的后一项，让他们俩做比较 if (arr[j] \u003c arr[minIndex]) { // 如果后面的值小于前面的值，需要调换他们俩位置 minIndex = j; // 保存最小值的下标 } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // 使用es6的结构语法交换值，把最小值放到数组最前面 } return arr; } 选择排序动画演示： 插入排序（Insertion Sort） 原理： 将数组分成两部分，一部分为已排序(默认为数组第一个元素且只有这一个元素)，另一部分为未排序。 依次从未排序数组中取值，和已排序中的值依次做对比，如果未排序元素比已排序元素中某个元素小，那就将已排序元素向后移一位，使他本来位置变成一个空位，再将待排序数据插入空位。 完整代码： function insertionSort(arr) { let len = arr.length; for (let i = 1; i \u003c len; i++) { // 循环未排序部分, i=1而不是0是因为默认0项为已排序部分 let cur = i; // 每次插入后，arr[i]会发生改变，先存下来 let j = i - 1; while (j \u003e= 0) { // 循环已排序部分，默认数组第一项有且只有第一项，下标范围为(0 - (未排序元素下标-1))，也就是例子中的i-1 if (arr[cur] \u003c arr[j]) { // 如果未排序元素比已排序元素小， [arr[cur], arr[j]] = [arr[j], arr[cur]]; // 交换 cur = j; // 交换后i值变了，那把交换后的i找回来就可以了 } j--; } } return arr; } 插入排序动画演示： 快速排序（Quick Sort） 原理： 选择数组中的一个元素作为基准值，用两个新数组分别存储原数组比基准值大的值，和小的值。 继续递归处理这两个新数组，最终用 concat 合并到一起，效果为：比基准值小的数组+基准值+比基准值小的数组。 快速排序有其它种实现方法，这是一种简单的实现，非原地排序，由于新建了多个新的数组，会增加空间复杂度，好处再于非常容易理解，可读性强，适合面试手写代码。\n完整代码： function quickSort(arr) { if (arr.length \u003c= 1) { return arr; } // 递归边界条件 let pointIdx = Math.floor(arr.length / 2); // 在数组中间位置取一个基准点 let point = arr.splice(pointIdx, 1)[0]; // 通过基准点找到这个值，使用splice原因是：要获取这个基准值的同时要把这个基准值从排序数组里删除掉 let left = []; let right = []; for (let i = 0, len = arr.length; i \u003c len; i++) { if (arr[i] \u003c point) { // 循环数组，小于point的放在left中，大的放在right中 left.push(arr[i]); } else { right.push(arr[i]); } } // 递归，让每一个left和right继续排序，直到left或right只有一项为止 return quickSort(left).concat(point, quickSort(right)); } 快速排序动画演示： 另外说一下，js 的原生提供的 sort 排序方法原理：如果数组长度小于10，使用插入排序，否则使用快速排序。如其名，快速排序的性能还是很好的。\n动画来源：菜鸟教程\n查看例子：GitHub\n","wordCount":"2020","inLanguage":"zh","image":"https://slc3a2.github.io/images/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8/cover.jpg","datePublished":"2020-09-02T16:07:43+08:00","dateModified":"2020-09-02T16:07:43+08:00","author":{"@type":"Person","name":"slc3a2"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://slc3a2.github.io/blogs/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/"},"publisher":{"@type":"Organization","name":"slc3a2","logo":{"@type":"ImageObject","url":"https://slc3a2.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://slc3a2.github.io/ accesskey=h title="slc3a2 (Alt + H)">slc3a2</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://slc3a2.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://slc3a2.github.io/blogs/ title="📚 日志"><span>📚 日志</span></a></li><li><a href=https://slc3a2.github.io/apps/ title="🚀 应用"><span>🚀 应用</span></a></li><li><a href=https://slc3a2.github.io/search/ title="🔍 搜索"><span>🔍 搜索</span></a></li><li><a href=https://slc3a2.github.io/tags/ title="🧩 分类"><span>🧩 分类</span></a></li><li><a href=https://slc3a2.github.io/archives/ title="⏱ 时间轴"><span>⏱ 时间轴</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">常用4种排序介绍</h1><div class=post-meta><span title='2020-09-02 16:07:43 +0800 +0800'>2020-09-02</span>&nbsp; ｜ &nbsp;5 分钟&nbsp; ｜ &nbsp;2020 字&nbsp; ｜ &nbsp;slc3a2</div></header><figure class=entry-cover1><img loading=eager src=https://slc3a2.github.io/images/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8/cover.jpg alt="cover image"><figcaption>封面图来自 Unsplash | 作者 Jakob Owens</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#冒泡排序bubble-sort>冒泡排序（Bubble sort）</a><ul><li><a href=#原理和演示>原理和演示：</a></li><li><a href=#完整代码>完整代码：</a></li><li><a href=#冒泡排序动画演示>冒泡排序动画演示：</a></li></ul></li><li><a href=#选择排序selection-sort>选择排序（Selection Sort）</a><ul><li><a href=#原理>原理：</a></li><li><a href=#完整代码-1>完整代码：</a></li><li><a href=#选择排序动画演示>选择排序动画演示：</a></li></ul></li><li><a href=#插入排序insertion-sort>插入排序（Insertion Sort）</a><ul><li><a href=#原理-1>原理：</a></li><li><a href=#完整代码-2>完整代码：</a></li><li><a href=#插入排序动画演示>插入排序动画演示：</a></li></ul></li><li><a href=#快速排序quick-sort>快速排序（Quick Sort）</a><ul><li><a href=#原理-2>原理：</a></li><li><a href=#完整代码-3>完整代码：</a></li><li><a href=#快速排序动画演示>快速排序动画演示：</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=冒泡排序bubble-sort>冒泡排序（Bubble sort）<a hidden class=anchor aria-hidden=true href=#冒泡排序bubble-sort>#</a></h2><h3 id=原理和演示>原理和演示：<a hidden class=anchor aria-hidden=true href=#原理和演示>#</a></h3><ul><li>依次比较数组中相邻的每一对值，如果前面的值 <strong>大于</strong> 后面的值，则交换他们俩的位置。如果数组中<code>5</code>个数字(length 为 5)，由于比较 <strong>两个一组</strong> 的数字，那么只需要<code>4次</code>(length - 1)比较，就可以实现把数组中最大的一个数放到最后。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bubbleSort</span>(<span style=color:#a6e22e>arr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>temp</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>temp</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`执行</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>次`</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>通过第一步得到最大的一个数放在数组最后。那么剩下的前三个数继续执行第一步，结果找到第二大的数，放在数组倒数第二位，重复此步骤，直到比对完数组中最后一组数。由于第一步骤每次得到一个最大值放最后，<code>j</code>对应的正好是数组最后有多少个最大值，可以免去比较。所以上步骤每次循环可以优化一下每次少算一个最大值，每次循环总数<code>- 1</code>也就是下面例子中的<code>- j</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bubbleSort</span>(<span style=color:#a6e22e>arr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>temp</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>];
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>temp</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`执行</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>次`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>两个变量互换值可以使用<code>es6</code>的解构语法，省去使用<code>temp</code>缓存，语法为<code>[a, b] = [b, a]</code>，即可交换<code>变量a</code>和<code>变量b</code>的值。复杂数据类型<code>Object</code>和<code>Array</code>都适用；如果第二个循环中的大小判断，一次都没有执行，说明当前这组数据是正序无需排序，用一个变量<code>isOk</code>标记下配合<code>break</code>，实现方法优化。</p></li></ul><h3 id=完整代码>完整代码：<a hidden class=anchor aria-hidden=true href=#完整代码>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bubbleSort</span>(<span style=color:#a6e22e>arr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>time</span>(<span style=color:#e6db74>&#34;耗时&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>len</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>len</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 要比对的次数，- 1是因为6个数俩俩比较只需要比对5次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isOk</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 当前和下一项的每次比较。完整进行一次比较后，最大的值就会在最后一位，- i意味着最大这个值不再需要比对了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> [<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>]]; <span style=color:#75715e>// 当前值小于下一项，交换位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>isOk</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// 如果第一次比较时，没有发现一个有效条件，那么说明整个数组默认就是排好序的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isOk</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>timeEnd</span>(<span style=color:#e6db74>&#34;耗时&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=冒泡排序动画演示>冒泡排序动画演示：<a hidden class=anchor aria-hidden=true href=#冒泡排序动画演示>#</a></h3><p><img alt="bubble sort.gif" loading=lazy src=/images/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/KWrN6slZTEFAuhv.gif></p><h2 id=选择排序selection-sort>选择排序（Selection Sort）<a hidden class=anchor aria-hidden=true href=#选择排序selection-sort>#</a></h2><h3 id=原理>原理：<a hidden class=anchor aria-hidden=true href=#原理>#</a></h3><ul><li>循环整个数组，找到<strong>最小</strong>的值，放在数组<strong>第一位</strong>(和第一位交换位置）。</li><li>从数组<strong>第二位</strong>开始重新循环，依旧找到<strong>最小</strong>的值，放在数组第二位，重复此步骤，直到对比完最后一组数据。</li></ul><h3 id=完整代码-1>完整代码：<a hidden class=anchor aria-hidden=true href=#完整代码-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>selectionSort</span>(<span style=color:#a6e22e>arr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// arr.length - 1是因为假定数组中n个数，比较需要两个数，所以只需要比较n-1次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>minIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i</span>; <span style=color:#75715e>// 记录每次循环开始位置，等待和最小值交换位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// j+1 是避免比较自身，j永远是i的后一项，让他们俩做比较
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>minIndex</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果后面的值小于前面的值，需要调换他们俩位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>minIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>j</span>; <span style=color:#75715e>// 保存最小值的下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    [<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>minIndex</span>]] <span style=color:#f92672>=</span> [<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>minIndex</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]]; <span style=color:#75715e>// 使用es6的结构语法交换值，把最小值放到数组最前面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=选择排序动画演示>选择排序动画演示：<a hidden class=anchor aria-hidden=true href=#选择排序动画演示>#</a></h3><p><img alt="section sort.gif" loading=lazy src=/images/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/ibLoIgDEnRJrUas.gif></p><h2 id=插入排序insertion-sort>插入排序（Insertion Sort）<a hidden class=anchor aria-hidden=true href=#插入排序insertion-sort>#</a></h2><h3 id=原理-1>原理：<a hidden class=anchor aria-hidden=true href=#原理-1>#</a></h3><ul><li>将数组分成<strong>两部分</strong>，一部分为<strong>已排序</strong>(默认为数组第一个元素且只有这一个元素)，另一部分为<strong>未排序</strong>。</li><li>依次从未排序数组中取值，和已排序中的值<strong>依次做对</strong>比，如果<strong>未排序元素</strong>比<strong>已排序元素</strong>中某个元素<strong>小</strong>，那就将<strong>已排序元素</strong>向<strong>后移</strong>一位，使他本来位置变成一个<strong>空位</strong>，再将<strong>待排序数据</strong>插入空位。</li></ul><h3 id=完整代码-2>完整代码：<a hidden class=anchor aria-hidden=true href=#完整代码-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>insertionSort</span>(<span style=color:#a6e22e>arr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>len</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>len</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 循环未排序部分, i=1而不是0是因为默认0项为已排序部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i</span>; <span style=color:#75715e>// 每次插入后，arr[i]会发生改变，先存下来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>j</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 循环已排序部分，默认数组第一项有且只有第一项，下标范围为(0 - (未排序元素下标-1))，也就是例子中的i-1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>cur</span>] <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果未排序元素比已排序元素小，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        [<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>cur</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>]] <span style=color:#f92672>=</span> [<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>cur</span>]]; <span style=color:#75715e>// 交换
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>cur</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>j</span>; <span style=color:#75715e>// 交换后i值变了，那把交换后的i找回来就可以了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>j</span><span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=插入排序动画演示>插入排序动画演示：<a hidden class=anchor aria-hidden=true href=#插入排序动画演示>#</a></h3><p><img alt="insertion sort.gif" loading=lazy src=/images/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/5z82iWpVIJbLfu7.gif></p><h2 id=快速排序quick-sort>快速排序（Quick Sort）<a hidden class=anchor aria-hidden=true href=#快速排序quick-sort>#</a></h2><h3 id=原理-2>原理：<a hidden class=anchor aria-hidden=true href=#原理-2>#</a></h3><ul><li>选择数组中的一个元素作为<strong>基准值</strong>，用两个新数组<strong>分别存储</strong>原数组比基准值<strong>大</strong>的值，和<strong>小</strong>的值。</li><li>继续<strong>递归处理</strong>这两个新数组，最终用 concat 合并到一起，效果为：比基准值小的数组+基准值+比基准值小的数组。</li></ul><blockquote><p>快速排序有其它种实现方法，这是一种简单的实现，非原地排序，由于新建了多个新的数组，会增加空间复杂度，好处再于非常容易理解，可读性强，适合面试手写代码。</p></blockquote><h3 id=完整代码-3>完整代码：<a hidden class=anchor aria-hidden=true href=#完整代码-3>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>quickSort</span>(<span style=color:#a6e22e>arr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>;
</span></span><span style=display:flex><span>  } <span style=color:#75715e>// 递归边界条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>pointIdx</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>); <span style=color:#75715e>// 在数组中间位置取一个基准点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>point</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>splice</span>(<span style=color:#a6e22e>pointIdx</span>, <span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>0</span>]; <span style=color:#75715e>// 通过基准点找到这个值，使用splice原因是：要获取这个基准值的同时要把这个基准值从排序数组里删除掉
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>len</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>len</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>point</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 循环数组，小于point的放在left中，大的放在right中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 递归，让每一个left和right继续排序，直到left或right只有一项为止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quickSort</span>(<span style=color:#a6e22e>left</span>).<span style=color:#a6e22e>concat</span>(<span style=color:#a6e22e>point</span>, <span style=color:#a6e22e>quickSort</span>(<span style=color:#a6e22e>right</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=快速排序动画演示>快速排序动画演示：<a hidden class=anchor aria-hidden=true href=#快速排序动画演示>#</a></h3><p><img alt="quick sort.gif" loading=lazy src=/images/%E5%B8%B8%E7%94%A84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D/DzWckAlLmVU9JuN.gif></p><hr><p>另外说一下，js 的原生提供的 <code>sort</code> 排序方法原理：如果数组长度<code>小于10</code>，使用插入排序，否则使用快速排序。如其名，快速排序的性能还是很好的。</p><hr><p>动画来源：<a href=https://www.runoob.com/w3cnote/merge-sort.html>菜鸟教程</a><br>查看例子：<a href=https://github.com/slc3a2/docs/tree/main/javascript_sort>GitHub</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://slc3a2.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/>计算机科学</a></li></ul><nav class=paginav><a class=prev href=https://slc3a2.github.io/blogs/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/><span class=title>« 上一页</span><br><span>函数柯里化(currying)</span>
</a><a class=next href=https://slc3a2.github.io/blogs/%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%8E%AF%E7%8A%B6%E8%BF%9B%E5%BA%A6/><span class=title>下一页 »</span><br><span>使用css实现圆环加载</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://slc3a2.github.io/>slc3a2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>